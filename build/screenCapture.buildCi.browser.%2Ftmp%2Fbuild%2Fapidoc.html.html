<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/Reactive-Extensions/RxJS">rx (v4.1.0)</a>
</h1>
<h4>Library for composing asynchronous and event-based operations in JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx">module rx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObservable">
            function <span class="apidocSignatureSpan">rx.</span>AnonymousObservable
            <span class="apidocSignatureSpan">(subscribe, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObserver">
            function <span class="apidocSignatureSpan">rx.</span>AnonymousObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject">
            function <span class="apidocSignatureSpan">rx.</span>AnonymousSubject
            <span class="apidocSignatureSpan">(observer, observable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ArgumentOutOfRangeError">
            function <span class="apidocSignatureSpan">rx.</span>ArgumentOutOfRangeError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject">
            function <span class="apidocSignatureSpan">rx.</span>AsyncSubject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject">
            function <span class="apidocSignatureSpan">rx.</span>BehaviorSubject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BinaryDisposable">
            function <span class="apidocSignatureSpan">rx.</span>BinaryDisposable
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.CompositeDisposable">
            function <span class="apidocSignatureSpan">rx.</span>CompositeDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.CompositeError">
            function <span class="apidocSignatureSpan">rx.</span>CompositeError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ConnectableObservable">
            function <span class="apidocSignatureSpan">rx.</span>ConnectableObservable
            <span class="apidocSignatureSpan">(source, subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable">
            function <span class="apidocSignatureSpan">rx.</span>Disposable
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.EmptyError">
            function <span class="apidocSignatureSpan">rx.</span>EmptyError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.FlatMapObservable">
            function <span class="apidocSignatureSpan">rx.</span>FlatMapObservable
            <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.HistoricalScheduler">
            function <span class="apidocSignatureSpan">rx.</span>HistoricalScheduler
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.MockDisposable">
            function <span class="apidocSignatureSpan">rx.</span>MockDisposable
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.NAryDisposable">
            function <span class="apidocSignatureSpan">rx.</span>NAryDisposable
            <span class="apidocSignatureSpan">(disposables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.NotImplementedError">
            function <span class="apidocSignatureSpan">rx.</span>NotImplementedError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.NotSupportedError">
            function <span class="apidocSignatureSpan">rx.</span>NotSupportedError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification">
            function <span class="apidocSignatureSpan">rx.</span>Notification
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ObjectDisposedError">
            function <span class="apidocSignatureSpan">rx.</span>ObjectDisposedError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable">
            function <span class="apidocSignatureSpan">rx.</span>Observable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ObservableBase">
            function <span class="apidocSignatureSpan">rx.</span>ObservableBase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer">
            function <span class="apidocSignatureSpan">rx.</span>Observer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Pauser">
            function <span class="apidocSignatureSpan">rx.</span>Pauser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Recorded">
            function <span class="apidocSignatureSpan">rx.</span>Recorded
            <span class="apidocSignatureSpan">(time, value, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.RefCountDisposable">
            function <span class="apidocSignatureSpan">rx.</span>RefCountDisposable
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject">
            function <span class="apidocSignatureSpan">rx.</span>ReplaySubject
            <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler">
            function <span class="apidocSignatureSpan">rx.</span>Scheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SerialDisposable">
            function <span class="apidocSignatureSpan">rx.</span>SerialDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SingleAssignmentDisposable">
            function <span class="apidocSignatureSpan">rx.</span>SingleAssignmentDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject">
            function <span class="apidocSignatureSpan">rx.</span>Subject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subscription">
            function <span class="apidocSignatureSpan">rx.</span>Subscription
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler">
            function <span class="apidocSignatureSpan">rx.</span>TestScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TimeoutError">
            function <span class="apidocSignatureSpan">rx.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler">
            function <span class="apidocSignatureSpan">rx.</span>VirtualTimeScheduler
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver">
            function <span class="apidocSignatureSpan">rx.</span>internals.AbstractObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable">
            function <span class="apidocSignatureSpan">rx.</span>internals.Enumerable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue">
            function <span class="apidocSignatureSpan">rx.</span>internals.PriorityQueue
            <span class="apidocSignatureSpan">(capacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.SchedulePeriodicRecursive">
            function <span class="apidocSignatureSpan">rx.</span>internals.SchedulePeriodicRecursive
            <span class="apidocSignatureSpan">(scheduler, state, period, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem">
            function <span class="apidocSignatureSpan">rx.</span>internals.ScheduledItem
            <span class="apidocSignatureSpan">(scheduler, state, action, dueTime, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver">
            function <span class="apidocSignatureSpan">rx.</span>internals.ScheduledObserver
            <span class="apidocSignatureSpan">(scheduler, observer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>AnonymousObservable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>AnonymousObserver.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>AnonymousSubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>AsyncSubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>BehaviorSubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>BinaryDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>CompositeDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>ConnectableObservable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Disposable.empty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Disposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>FlatMapObservable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>HistoricalScheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>MockDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>NAryDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Notification.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Observable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>ObservableBase.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Observer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Pauser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>ReactiveTest</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Recorded.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>RefCountDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>ReplaySubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Rx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Scheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>SerialDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>SingleAssignmentDisposable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Subject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Subscription.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>TestScheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>VirtualTimeScheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>doneEnumerator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals.AbstractObserver.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals.Enumerable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals.PriorityQueue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals.SchedulePeriodicRecursive.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals.ScheduledItem.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>internals.ScheduledObserver.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AnonymousObservable">module rx.AnonymousObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObservable.AnonymousObservable">
            function <span class="apidocSignatureSpan">rx.</span>AnonymousObservable
            <span class="apidocSignatureSpan">(subscribe, parent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AnonymousObservable.prototype">module rx.AnonymousObservable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObservable.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.AnonymousObservable.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObservable.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.AnonymousObservable.prototype.</span>constructor
            <span class="apidocSignatureSpan">(subscribe, parent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AnonymousObserver">module rx.AnonymousObserver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObserver.AnonymousObserver">
            function <span class="apidocSignatureSpan">rx.</span>AnonymousObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AnonymousObserver.prototype">module rx.AnonymousObserver.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObserver.prototype.completed">
            function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>completed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObserver.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>constructor
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObserver.prototype.error">
            function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>error
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousObserver.prototype.next">
            function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AnonymousSubject">module rx.AnonymousSubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.AnonymousSubject">
            function <span class="apidocSignatureSpan">rx.</span>AnonymousSubject
            <span class="apidocSignatureSpan">(observer, observable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AnonymousSubject.prototype">module rx.AnonymousSubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.asObserver">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>asObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.checked">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>checked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">(observer, observable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.makeSafe">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>makeSafe
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.notifyOn">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>notifyOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.onCompleted">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>onCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.onError">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.onNext">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>onNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AnonymousSubject.prototype.toNotifier">
            function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>toNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AsyncSubject">module rx.AsyncSubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.AsyncSubject">
            function <span class="apidocSignatureSpan">rx.</span>AsyncSubject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.AsyncSubject.prototype">module rx.AsyncSubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.asObserver">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>asObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.checked">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>checked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.hasObservers">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>hasObservers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.makeSafe">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>makeSafe
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.notifyOn">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>notifyOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.onCompleted">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>onCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.onError">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.onNext">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>onNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.AsyncSubject.prototype.toNotifier">
            function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>toNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.BehaviorSubject">module rx.BehaviorSubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.BehaviorSubject">
            function <span class="apidocSignatureSpan">rx.</span>BehaviorSubject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.BehaviorSubject.prototype">module rx.BehaviorSubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.asObserver">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>asObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.checked">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>checked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.getValue">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>getValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.hasObservers">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>hasObservers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.makeSafe">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>makeSafe
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.notifyOn">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>notifyOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.onCompleted">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>onCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.onError">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.onNext">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>onNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BehaviorSubject.prototype.toNotifier">
            function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>toNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.BinaryDisposable">module rx.BinaryDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BinaryDisposable.BinaryDisposable">
            function <span class="apidocSignatureSpan">rx.</span>BinaryDisposable
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.BinaryDisposable.prototype">module rx.BinaryDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.BinaryDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.BinaryDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.CompositeDisposable">module rx.CompositeDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.CompositeDisposable.CompositeDisposable">
            function <span class="apidocSignatureSpan">rx.</span>CompositeDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.CompositeDisposable.prototype">module rx.CompositeDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.CompositeDisposable.prototype.add">
            function <span class="apidocSignatureSpan">rx.CompositeDisposable.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.CompositeDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.CompositeDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.CompositeDisposable.prototype.remove">
            function <span class="apidocSignatureSpan">rx.CompositeDisposable.prototype.</span>remove
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ConnectableObservable">module rx.ConnectableObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ConnectableObservable.ConnectableObservable">
            function <span class="apidocSignatureSpan">rx.</span>ConnectableObservable
            <span class="apidocSignatureSpan">(source, subject)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ConnectableObservable.prototype">module rx.ConnectableObservable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ConnectableObservable.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ConnectableObservable.prototype.connect">
            function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ConnectableObservable.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>constructor
            <span class="apidocSignatureSpan">(source, subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ConnectableObservable.prototype.refCount">
            function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>refCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Disposable">module rx.Disposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable.Disposable">
            function <span class="apidocSignatureSpan">rx.</span>Disposable
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable._fixup">
            function <span class="apidocSignatureSpan">rx.Disposable.</span>_fixup
            <span class="apidocSignatureSpan">(result)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable.checkDisposed">
            function <span class="apidocSignatureSpan">rx.Disposable.</span>checkDisposed
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable.create">
            function <span class="apidocSignatureSpan">rx.Disposable.</span>create
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable.isDisposable">
            function <span class="apidocSignatureSpan">rx.Disposable.</span>isDisposable
            <span class="apidocSignatureSpan">(d)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Disposable.</span>empty</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Disposable.empty">module rx.Disposable.empty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable.empty.dispose">
            function <span class="apidocSignatureSpan">rx.Disposable.empty.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Disposable.prototype">module rx.Disposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Disposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.Disposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.FlatMapObservable">module rx.FlatMapObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.FlatMapObservable.FlatMapObservable">
            function <span class="apidocSignatureSpan">rx.</span>FlatMapObservable
            <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.FlatMapObservable.prototype">module rx.FlatMapObservable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.FlatMapObservable.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.FlatMapObservable.prototype.</span>constructor
            <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.FlatMapObservable.prototype.subscribeCore">
            function <span class="apidocSignatureSpan">rx.FlatMapObservable.prototype.</span>subscribeCore
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.HistoricalScheduler">module rx.HistoricalScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.HistoricalScheduler.HistoricalScheduler">
            function <span class="apidocSignatureSpan">rx.</span>HistoricalScheduler
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.HistoricalScheduler.prototype">module rx.HistoricalScheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.HistoricalScheduler.prototype.add">
            function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>add
            <span class="apidocSignatureSpan">(absolute, relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.HistoricalScheduler.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>constructor
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.HistoricalScheduler.prototype.toAbsoluteTime">
            function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>toAbsoluteTime
            <span class="apidocSignatureSpan">(absolute)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.HistoricalScheduler.prototype.toRelativeTime">
            function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>toRelativeTime
            <span class="apidocSignatureSpan">(timeSpan)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.MockDisposable">module rx.MockDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.MockDisposable.MockDisposable">
            function <span class="apidocSignatureSpan">rx.</span>MockDisposable
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.MockDisposable.prototype">module rx.MockDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.MockDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.MockDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.NAryDisposable">module rx.NAryDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.NAryDisposable.NAryDisposable">
            function <span class="apidocSignatureSpan">rx.</span>NAryDisposable
            <span class="apidocSignatureSpan">(disposables)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.NAryDisposable.prototype">module rx.NAryDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.NAryDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.NAryDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Notification">module rx.Notification</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.Notification">
            function <span class="apidocSignatureSpan">rx.</span>Notification
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.createOnCompleted">
            function <span class="apidocSignatureSpan">rx.Notification.</span>createOnCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.createOnError">
            function <span class="apidocSignatureSpan">rx.Notification.</span>createOnError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.createOnNext">
            function <span class="apidocSignatureSpan">rx.Notification.</span>createOnNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Notification.prototype">module rx.Notification.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.prototype._accept">
            function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>_accept
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.prototype._acceptObserver">
            function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>_acceptObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.prototype.accept">
            function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>accept
            <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Notification.prototype.toObservable">
            function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>toObservable
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Observable">module rx.Observable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.Observable">
            function <span class="apidocSignatureSpan">rx.</span>Observable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.amb">
            function <span class="apidocSignatureSpan">rx.Observable.</span>amb
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.case">
            function <span class="apidocSignatureSpan">rx.Observable.</span>case
            <span class="apidocSignatureSpan">(selector, sources, defaultSourceOrScheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.catch">
            function <span class="apidocSignatureSpan">rx.Observable.</span>catch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.combineLatest">
            function <span class="apidocSignatureSpan">rx.Observable.</span>combineLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.concat">
            function <span class="apidocSignatureSpan">rx.Observable.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.create">
            function <span class="apidocSignatureSpan">rx.Observable.</span>create
            <span class="apidocSignatureSpan">(subscribe, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.defer">
            function <span class="apidocSignatureSpan">rx.Observable.</span>defer
            <span class="apidocSignatureSpan">(observableFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.empty">
            function <span class="apidocSignatureSpan">rx.Observable.</span>empty
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.for">
            function <span class="apidocSignatureSpan">rx.Observable.</span>for
            <span class="apidocSignatureSpan">(sources, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.forIn">
            function <span class="apidocSignatureSpan">rx.Observable.</span>forIn
            <span class="apidocSignatureSpan">(sources, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.forkJoin">
            function <span class="apidocSignatureSpan">rx.Observable.</span>forkJoin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.from">
            function <span class="apidocSignatureSpan">rx.Observable.</span>from
            <span class="apidocSignatureSpan">(iterable, mapFn, thisArg, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.fromArray">
            function <span class="apidocSignatureSpan">rx.Observable.</span>fromArray
            <span class="apidocSignatureSpan">(array, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.fromCallback">
            function <span class="apidocSignatureSpan">rx.Observable.</span>fromCallback
            <span class="apidocSignatureSpan">(fn, ctx, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.fromEvent">
            function <span class="apidocSignatureSpan">rx.Observable.</span>fromEvent
            <span class="apidocSignatureSpan">(element, eventName, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.fromEventPattern">
            function <span class="apidocSignatureSpan">rx.Observable.</span>fromEventPattern
            <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.fromNodeCallback">
            function <span class="apidocSignatureSpan">rx.Observable.</span>fromNodeCallback
            <span class="apidocSignatureSpan">(fn, ctx, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.fromPromise">
            function <span class="apidocSignatureSpan">rx.Observable.</span>fromPromise
            <span class="apidocSignatureSpan">(promise, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.generate">
            function <span class="apidocSignatureSpan">rx.Observable.</span>generate
            <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.generateWithAbsoluteTime">
            function <span class="apidocSignatureSpan">rx.Observable.</span>generateWithAbsoluteTime
            <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, timeSelector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.generateWithRelativeTime">
            function <span class="apidocSignatureSpan">rx.Observable.</span>generateWithRelativeTime
            <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, timeSelector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.if">
            function <span class="apidocSignatureSpan">rx.Observable.</span>if
            <span class="apidocSignatureSpan">(condition, thenSource, elseSourceOrScheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.interval">
            function <span class="apidocSignatureSpan">rx.Observable.</span>interval
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.isObservable">
            function <span class="apidocSignatureSpan">rx.Observable.</span>isObservable
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.just">
            function <span class="apidocSignatureSpan">rx.Observable.</span>just
            <span class="apidocSignatureSpan">(value, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.merge">
            function <span class="apidocSignatureSpan">rx.Observable.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.mergeDelayError">
            function <span class="apidocSignatureSpan">rx.Observable.</span>mergeDelayError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.never">
            function <span class="apidocSignatureSpan">rx.Observable.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.of">
            function <span class="apidocSignatureSpan">rx.Observable.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.ofWithScheduler">
            function <span class="apidocSignatureSpan">rx.Observable.</span>ofWithScheduler
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.onErrorResumeNext">
            function <span class="apidocSignatureSpan">rx.Observable.</span>onErrorResumeNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.pairs">
            function <span class="apidocSignatureSpan">rx.Observable.</span>pairs
            <span class="apidocSignatureSpan">(obj, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.range">
            function <span class="apidocSignatureSpan">rx.Observable.</span>range
            <span class="apidocSignatureSpan">(start, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.repeat">
            function <span class="apidocSignatureSpan">rx.Observable.</span>repeat
            <span class="apidocSignatureSpan">(value, repeatCount, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.return">
            function <span class="apidocSignatureSpan">rx.Observable.</span>return
            <span class="apidocSignatureSpan">(value, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.spawn">
            function <span class="apidocSignatureSpan">rx.Observable.</span>spawn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.start">
            function <span class="apidocSignatureSpan">rx.Observable.</span>start
            <span class="apidocSignatureSpan">(func, context, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.startAsync">
            function <span class="apidocSignatureSpan">rx.Observable.</span>startAsync
            <span class="apidocSignatureSpan">(functionAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.throw">
            function <span class="apidocSignatureSpan">rx.Observable.</span>throw
            <span class="apidocSignatureSpan">(error, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.timer">
            function <span class="apidocSignatureSpan">rx.Observable.</span>timer
            <span class="apidocSignatureSpan">(dueTime, periodOrScheduler, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.toAsync">
            function <span class="apidocSignatureSpan">rx.Observable.</span>toAsync
            <span class="apidocSignatureSpan">(func, context, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.using">
            function <span class="apidocSignatureSpan">rx.Observable.</span>using
            <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.when">
            function <span class="apidocSignatureSpan">rx.Observable.</span>when
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.while">
            function <span class="apidocSignatureSpan">rx.Observable.</span>while
            <span class="apidocSignatureSpan">(condition, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.whileDo">
            function <span class="apidocSignatureSpan">rx.Observable.</span>whileDo
            <span class="apidocSignatureSpan">(condition, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.wrap">
            function <span class="apidocSignatureSpan">rx.Observable.</span>wrap
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.zip">
            function <span class="apidocSignatureSpan">rx.Observable.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Observable.prototype">module rx.Observable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.amb">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>amb
            <span class="apidocSignatureSpan">(rightSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.and">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>and
            <span class="apidocSignatureSpan">(right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.asObservable">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>asObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.average">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>average
            <span class="apidocSignatureSpan">(keySelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.buffer">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>buffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.bufferCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferCount
            <span class="apidocSignatureSpan">(count, skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.bufferTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferTime
            <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.bufferTimeOrCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferTimeOrCount
            <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.bufferWithCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferWithCount
            <span class="apidocSignatureSpan">(count, skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.bufferWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferWithTime
            <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.bufferWithTimeOrCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferWithTimeOrCount
            <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.catch">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>catch
            <span class="apidocSignatureSpan">(handlerOrSecond)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.combineLatest">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>combineLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.concat">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.concatAll">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concatAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.concatMap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concatMap
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.concatMapObserver">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concatMapObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.controlled">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>controlled
            <span class="apidocSignatureSpan">(enableQueue, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.count">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>count
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.debounce">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>debounce
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.defaultIfEmpty">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>defaultIfEmpty
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.delay">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>delay
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.delaySubscription">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>delaySubscription
            <span class="apidocSignatureSpan">(dueTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.dematerialize">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>dematerialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.distinct">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>distinct
            <span class="apidocSignatureSpan">(keySelector, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.distinctUntilChanged">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>distinctUntilChanged
            <span class="apidocSignatureSpan">(keyFn, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.do">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>do
            <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.doAction">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doAction
            <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.doOnCompleted">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doOnCompleted
            <span class="apidocSignatureSpan">(onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.doOnError">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doOnError
            <span class="apidocSignatureSpan">(onError, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.doOnNext">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doOnNext
            <span class="apidocSignatureSpan">(onNext, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.doWhile">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doWhile
            <span class="apidocSignatureSpan">(condition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.elementAt">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>elementAt
            <span class="apidocSignatureSpan">(index, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.every">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>every
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.exhaustMap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>exhaustMap
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.expand">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>expand
            <span class="apidocSignatureSpan">(selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.extend">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>extend
            <span class="apidocSignatureSpan">(selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.filter">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>filter
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.finally">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>finally
            <span class="apidocSignatureSpan">(action, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.find">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>find
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.findIndex">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>findIndex
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.first">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMap
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMapConcat">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapConcat
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMapFirst">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapFirst
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMapLatest">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapLatest
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMapMaxConcurrent">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapMaxConcurrent
            <span class="apidocSignatureSpan">(limit, selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMapObserver">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.flatMapWithMaxConcurrent">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapWithMaxConcurrent
            <span class="apidocSignatureSpan">(limit, selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.forEach">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>forEach
            <span class="apidocSignatureSpan">(oOrOnNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.forkJoin">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>forkJoin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.groupBy">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>groupBy
            <span class="apidocSignatureSpan">(keySelector, elementSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.groupByUntil">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>groupByUntil
            <span class="apidocSignatureSpan">(keySelector, elementSelector, durationSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.groupJoin">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>groupJoin
            <span class="apidocSignatureSpan">(right, leftDurationSelector, rightDurationSelector, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.ignoreElements">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>ignoreElements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.includes">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>includes
            <span class="apidocSignatureSpan">(searchElement, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.indexOf">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(searchElement, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.isEmpty">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.join">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>join
            <span class="apidocSignatureSpan">(right, leftDurationSelector, rightDurationSelector, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.jortSort">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>jortSort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.jortSortUntil">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>jortSortUntil
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.last">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(searchElement, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.let">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>let
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.letBind">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>letBind
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.manySelect">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>manySelect
            <span class="apidocSignatureSpan">(selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.map">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>map
            <span class="apidocSignatureSpan">(selector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.materialize">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>materialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.max">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>max
            <span class="apidocSignatureSpan">(comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.maxBy">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>maxBy
            <span class="apidocSignatureSpan">(keySelector, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.merge">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>merge
            <span class="apidocSignatureSpan">(maxConcurrentOrOther)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.mergeAll">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>mergeAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.mergeMap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>mergeMap
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.min">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>min
            <span class="apidocSignatureSpan">(comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.minBy">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>minBy
            <span class="apidocSignatureSpan">(keySelector, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.multicast">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>multicast
            <span class="apidocSignatureSpan">(subjectOrSubjectSelector, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.observeOn">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>observeOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.onErrorResumeNext">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>onErrorResumeNext
            <span class="apidocSignatureSpan">(second)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.pairwise">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pairwise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.partition">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>partition
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.pausable">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pausable
            <span class="apidocSignatureSpan">(pauser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.pausableBuffered">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pausableBuffered
            <span class="apidocSignatureSpan">(pauser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.pipe">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pipe
            <span class="apidocSignatureSpan">(dest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.pluck">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pluck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.publish">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>publish
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.publishLast">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>publishLast
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.publishValue">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>publishValue
            <span class="apidocSignatureSpan">(initialValueOrSelector, initialValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.reduce">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>reduce
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.repeat">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>repeat
            <span class="apidocSignatureSpan">(repeatCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.repeatWhen">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>repeatWhen
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.replay">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>replay
            <span class="apidocSignatureSpan">(selector, bufferSize, windowSize, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.retry">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>retry
            <span class="apidocSignatureSpan">(retryCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.retryWhen">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>retryWhen
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.sample">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>sample
            <span class="apidocSignatureSpan">(intervalOrSampler, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.scan">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>scan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.select">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>select
            <span class="apidocSignatureSpan">(selector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.selectConcatObserver">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>selectConcatObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.selectMany">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>selectMany
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.selectManyObserver">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>selectManyObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.sequenceEqual">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>sequenceEqual
            <span class="apidocSignatureSpan">(second, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.share">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>share
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.shareReplay">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>shareReplay
            <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.shareValue">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>shareValue
            <span class="apidocSignatureSpan">(initialValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.single">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>single
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.singleInstance">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>singleInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skip">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skip
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skipLast">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipLast
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skipLastWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipLastWithTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skipUntil">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipUntil
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skipUntilWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipUntilWithTime
            <span class="apidocSignatureSpan">(startTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skipWhile">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.skipWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipWithTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.slice">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.some">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>some
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.startWith">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>startWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.subscribe">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(oOrOnNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.subscribeOn">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.subscribeOnCompleted">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOnCompleted
            <span class="apidocSignatureSpan">(onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.subscribeOnError">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOnError
            <span class="apidocSignatureSpan">(onError, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.subscribeOnNext">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOnNext
            <span class="apidocSignatureSpan">(onNext, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.sum">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>sum
            <span class="apidocSignatureSpan">(keySelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.switch">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.switchFirst">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switchFirst
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.switchLatest">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switchLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.switchMap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switchMap
            <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.take">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>take
            <span class="apidocSignatureSpan">(count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeLast">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLast
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeLastBuffer">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLastBuffer
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeLastBufferWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLastBufferWithTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeLastWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLastWithTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeUntil">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeUntil
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeUntilWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeUntilWithTime
            <span class="apidocSignatureSpan">(endTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeWhile">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeWhile
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.takeWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeWithTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.tap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tap
            <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.tapOnCompleted">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tapOnCompleted
            <span class="apidocSignatureSpan">(onCompleted, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.tapOnError">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tapOnError
            <span class="apidocSignatureSpan">(onError, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.tapOnNext">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tapOnNext
            <span class="apidocSignatureSpan">(onNext, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.thenDo">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>thenDo
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.throttle">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>throttle
            <span class="apidocSignatureSpan">(windowDuration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.timeInterval">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>timeInterval
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.timeout">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>timeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.timestamp">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>timestamp
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.toArray">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.toMap">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toMap
            <span class="apidocSignatureSpan">(keySelector, elementSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.toPromise">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toPromise
            <span class="apidocSignatureSpan">(promiseCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.toSet">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toSet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.transduce">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>transduce
            <span class="apidocSignatureSpan">(transducer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.where">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>where
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.window">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>window
            <span class="apidocSignatureSpan">(windowOpeningsOrClosingSelector, windowClosingSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.windowCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowCount
            <span class="apidocSignatureSpan">(count, skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.windowTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowTime
            <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.windowTimeOrCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowTimeOrCount
            <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.windowWithCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowWithCount
            <span class="apidocSignatureSpan">(count, skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.windowWithTime">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowWithTime
            <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.windowWithTimeOrCount">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowWithTimeOrCount
            <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.withLatestFrom">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>withLatestFrom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.zip">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observable.prototype.zipIterable">
            function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>zipIterable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ObservableBase">module rx.ObservableBase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ObservableBase.ObservableBase">
            function <span class="apidocSignatureSpan">rx.</span>ObservableBase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ObservableBase.prototype">module rx.ObservableBase.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ObservableBase.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.ObservableBase.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ObservableBase.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.ObservableBase.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ObservableBase.prototype.subscribeCore">
            function <span class="apidocSignatureSpan">rx.ObservableBase.prototype.</span>subscribeCore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Observer">module rx.Observer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.Observer">
            function <span class="apidocSignatureSpan">rx.</span>Observer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.create">
            function <span class="apidocSignatureSpan">rx.Observer.</span>create
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.fromNotifier">
            function <span class="apidocSignatureSpan">rx.Observer.</span>fromNotifier
            <span class="apidocSignatureSpan">(handler, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Observer.prototype">module rx.Observer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.prototype.asObserver">
            function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>asObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.prototype.checked">
            function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>checked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.prototype.makeSafe">
            function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>makeSafe
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.prototype.notifyOn">
            function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>notifyOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Observer.prototype.toNotifier">
            function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>toNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Pauser">module rx.Pauser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Pauser.Pauser">
            function <span class="apidocSignatureSpan">rx.</span>Pauser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Pauser.prototype">module rx.Pauser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Pauser.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.Pauser.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Pauser.prototype.pause">
            function <span class="apidocSignatureSpan">rx.Pauser.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Pauser.prototype.resume">
            function <span class="apidocSignatureSpan">rx.Pauser.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ReactiveTest">module rx.ReactiveTest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReactiveTest.onCompleted">
            function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>onCompleted
            <span class="apidocSignatureSpan">(ticks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReactiveTest.onError">
            function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>onError
            <span class="apidocSignatureSpan">(ticks, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReactiveTest.onNext">
            function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>onNext
            <span class="apidocSignatureSpan">(ticks, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReactiveTest.subscribe">
            function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>subscribe
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rx.ReactiveTest.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rx.ReactiveTest.</span>disposed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rx.ReactiveTest.</span>subscribed</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Recorded">module rx.Recorded</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Recorded.Recorded">
            function <span class="apidocSignatureSpan">rx.</span>Recorded
            <span class="apidocSignatureSpan">(time, value, comparer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Recorded.prototype">module rx.Recorded.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Recorded.prototype.equals">
            function <span class="apidocSignatureSpan">rx.Recorded.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Recorded.prototype.toString">
            function <span class="apidocSignatureSpan">rx.Recorded.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.RefCountDisposable">module rx.RefCountDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.RefCountDisposable.RefCountDisposable">
            function <span class="apidocSignatureSpan">rx.</span>RefCountDisposable
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.RefCountDisposable.prototype">module rx.RefCountDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.RefCountDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.RefCountDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.RefCountDisposable.prototype.getDisposable">
            function <span class="apidocSignatureSpan">rx.RefCountDisposable.prototype.</span>getDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ReplaySubject">module rx.ReplaySubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.ReplaySubject">
            function <span class="apidocSignatureSpan">rx.</span>ReplaySubject
            <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.ReplaySubject.prototype">module rx.ReplaySubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype._trim">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>_trim
            <span class="apidocSignatureSpan">(now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.asObserver">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>asObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.checked">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>checked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.hasObservers">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>hasObservers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.makeSafe">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>makeSafe
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.notifyOn">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>notifyOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.onCompleted">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>onCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.onError">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.onNext">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>onNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.ReplaySubject.prototype.toNotifier">
            function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>toNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Rx">module rx.Rx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.AnonymousObservable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>AnonymousObservable
            <span class="apidocSignatureSpan">(subscribe, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.AnonymousObserver">
            function <span class="apidocSignatureSpan">rx.Rx.</span>AnonymousObserver
            <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.AnonymousSubject">
            function <span class="apidocSignatureSpan">rx.Rx.</span>AnonymousSubject
            <span class="apidocSignatureSpan">(observer, observable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.ArgumentOutOfRangeError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>ArgumentOutOfRangeError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.AsyncSubject">
            function <span class="apidocSignatureSpan">rx.Rx.</span>AsyncSubject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.BehaviorSubject">
            function <span class="apidocSignatureSpan">rx.Rx.</span>BehaviorSubject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.BinaryDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>BinaryDisposable
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.CompositeDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>CompositeDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.CompositeError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>CompositeError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.ConnectableObservable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>ConnectableObservable
            <span class="apidocSignatureSpan">(source, subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Disposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Disposable
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.EmptyError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>EmptyError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.FlatMapObservable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>FlatMapObservable
            <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.HistoricalScheduler">
            function <span class="apidocSignatureSpan">rx.Rx.</span>HistoricalScheduler
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.MockDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>MockDisposable
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.NAryDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>NAryDisposable
            <span class="apidocSignatureSpan">(disposables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.NotImplementedError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>NotImplementedError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.NotSupportedError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>NotSupportedError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Notification">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Notification
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.ObjectDisposedError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>ObjectDisposedError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Observable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Observable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.ObservableBase">
            function <span class="apidocSignatureSpan">rx.Rx.</span>ObservableBase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Observer">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Observer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Pauser">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Pauser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Recorded">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Recorded
            <span class="apidocSignatureSpan">(time, value, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.RefCountDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>RefCountDisposable
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.ReplaySubject">
            function <span class="apidocSignatureSpan">rx.Rx.</span>ReplaySubject
            <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Scheduler">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Scheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.SerialDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>SerialDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.SingleAssignmentDisposable">
            function <span class="apidocSignatureSpan">rx.Rx.</span>SingleAssignmentDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Subject">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Subject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.Subscription">
            function <span class="apidocSignatureSpan">rx.Rx.</span>Subscription
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.TestScheduler">
            function <span class="apidocSignatureSpan">rx.Rx.</span>TestScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.TimeoutError">
            function <span class="apidocSignatureSpan">rx.Rx.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Rx.VirtualTimeScheduler">
            function <span class="apidocSignatureSpan">rx.Rx.</span>VirtualTimeScheduler
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.</span>Rx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Rx.</span>ReactiveTest</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Rx.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Rx.</span>doneEnumerator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Rx.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Rx.</span>internals</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Scheduler">module rx.Scheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.Scheduler">
            function <span class="apidocSignatureSpan">rx.</span>Scheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.isScheduler">
            function <span class="apidocSignatureSpan">rx.Scheduler.</span>isScheduler
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.normalize">
            function <span class="apidocSignatureSpan">rx.Scheduler.</span>normalize
            <span class="apidocSignatureSpan">(timeSpan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.now">
            function <span class="apidocSignatureSpan">rx.Scheduler.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Scheduler.</span>async</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Scheduler.</span>currentThread</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Scheduler.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rx.Scheduler.</span>immediate</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Scheduler.prototype">module rx.Scheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype._scheduleFuture">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>_scheduleFuture
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.catch">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>catch
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.catchError">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>catchError
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.now">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.schedule">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>schedule
            <span class="apidocSignatureSpan">(state, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.scheduleFuture">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>scheduleFuture
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.schedulePeriodic">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>schedulePeriodic
            <span class="apidocSignatureSpan">(state, period, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.scheduleRecursive">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>scheduleRecursive
            <span class="apidocSignatureSpan">(state, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Scheduler.prototype.scheduleRecursiveFuture">
            function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>scheduleRecursiveFuture
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.SerialDisposable">module rx.SerialDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SerialDisposable.SerialDisposable">
            function <span class="apidocSignatureSpan">rx.</span>SerialDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.SerialDisposable.prototype">module rx.SerialDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SerialDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.SerialDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SerialDisposable.prototype.getDisposable">
            function <span class="apidocSignatureSpan">rx.SerialDisposable.prototype.</span>getDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SerialDisposable.prototype.setDisposable">
            function <span class="apidocSignatureSpan">rx.SerialDisposable.prototype.</span>setDisposable
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.SingleAssignmentDisposable">module rx.SingleAssignmentDisposable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SingleAssignmentDisposable.SingleAssignmentDisposable">
            function <span class="apidocSignatureSpan">rx.</span>SingleAssignmentDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.SingleAssignmentDisposable.prototype">module rx.SingleAssignmentDisposable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SingleAssignmentDisposable.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.SingleAssignmentDisposable.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SingleAssignmentDisposable.prototype.getDisposable">
            function <span class="apidocSignatureSpan">rx.SingleAssignmentDisposable.prototype.</span>getDisposable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.SingleAssignmentDisposable.prototype.setDisposable">
            function <span class="apidocSignatureSpan">rx.SingleAssignmentDisposable.prototype.</span>setDisposable
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Subject">module rx.Subject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.Subject">
            function <span class="apidocSignatureSpan">rx.</span>Subject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.create">
            function <span class="apidocSignatureSpan">rx.Subject.</span>create
            <span class="apidocSignatureSpan">(observer, observable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Subject.prototype">module rx.Subject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.asObserver">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>asObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.checked">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>checked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.hasObservers">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>hasObservers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.makeSafe">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>makeSafe
            <span class="apidocSignatureSpan">(disposable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.notifyOn">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>notifyOn
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.onCompleted">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>onCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.onError">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.onNext">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>onNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subject.prototype.toNotifier">
            function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>toNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Subscription">module rx.Subscription</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subscription.Subscription">
            function <span class="apidocSignatureSpan">rx.</span>Subscription
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.Subscription.prototype">module rx.Subscription.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subscription.prototype.equals">
            function <span class="apidocSignatureSpan">rx.Subscription.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.Subscription.prototype.toString">
            function <span class="apidocSignatureSpan">rx.Subscription.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.TestScheduler">module rx.TestScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.TestScheduler">
            function <span class="apidocSignatureSpan">rx.</span>TestScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.TestScheduler.prototype">module rx.TestScheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.add">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>add
            <span class="apidocSignatureSpan">(absolute, relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.createColdObservable">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createColdObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.createHotObservable">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createHotObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.createObserver">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.createRejectedPromise">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createRejectedPromise
            <span class="apidocSignatureSpan">(ticks, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.createResolvedPromise">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createResolvedPromise
            <span class="apidocSignatureSpan">(ticks, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.scheduleAbsolute">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>scheduleAbsolute
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.startScheduler">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>startScheduler
            <span class="apidocSignatureSpan">(createFn, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.toAbsoluteTime">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>toAbsoluteTime
            <span class="apidocSignatureSpan">(absolute)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.TestScheduler.prototype.toRelativeTime">
            function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>toRelativeTime
            <span class="apidocSignatureSpan">(timeSpan)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.VirtualTimeScheduler">module rx.VirtualTimeScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.VirtualTimeScheduler">
            function <span class="apidocSignatureSpan">rx.</span>VirtualTimeScheduler
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.VirtualTimeScheduler.prototype">module rx.VirtualTimeScheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.add">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.advanceBy">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>advanceBy
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.advanceTo">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>advanceTo
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>constructor
            <span class="apidocSignatureSpan">(initialClock, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.getNext">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>getNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.now">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.schedule">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>schedule
            <span class="apidocSignatureSpan">(state, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleAbsolute">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>scheduleAbsolute
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleFuture">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>scheduleFuture
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.schedulePeriodic">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>schedulePeriodic
            <span class="apidocSignatureSpan">(state, period, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleRelative">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>scheduleRelative
            <span class="apidocSignatureSpan">(state, dueTime, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.sleep">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>sleep
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.start">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.stop">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.toAbsoluteTime">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>toAbsoluteTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.VirtualTimeScheduler.prototype.toRelativeTime">
            function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>toRelativeTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.config">module rx.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">rx.config.</span>longStackSupport</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">rx.config.</span>useNativeEvents</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.config.Promise">
            function <span class="apidocSignatureSpan">rx.config.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.helpers">module rx.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.defaultComparer">
            function <span class="apidocSignatureSpan">rx.helpers.</span>defaultComparer
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.defaultError">
            function <span class="apidocSignatureSpan">rx.helpers.</span>defaultError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.defaultKeySerializer">
            function <span class="apidocSignatureSpan">rx.helpers.</span>defaultKeySerializer
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.defaultNow">
            function <span class="apidocSignatureSpan">rx.helpers.</span>defaultNow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.defaultSubComparer">
            function <span class="apidocSignatureSpan">rx.helpers.</span>defaultSubComparer
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.identity">
            function <span class="apidocSignatureSpan">rx.helpers.</span>identity
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.isArrayLike">
            function <span class="apidocSignatureSpan">rx.helpers.</span>isArrayLike
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.isFunction">
            function <span class="apidocSignatureSpan">rx.helpers.</span>isFunction
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.isIterable">
            function <span class="apidocSignatureSpan">rx.helpers.</span>isIterable
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.isPromise">
            function <span class="apidocSignatureSpan">rx.helpers.</span>isPromise
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.noop">
            function <span class="apidocSignatureSpan">rx.helpers.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.notImplemented">
            function <span class="apidocSignatureSpan">rx.helpers.</span>notImplemented
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.helpers.notSupported">
            function <span class="apidocSignatureSpan">rx.helpers.</span>notSupported
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">symbol <span class="apidocSignatureSpan">rx.helpers.</span>iterator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals">module rx.internals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver">
            function <span class="apidocSignatureSpan">rx.internals.</span>AbstractObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable">
            function <span class="apidocSignatureSpan">rx.internals.</span>Enumerable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue">
            function <span class="apidocSignatureSpan">rx.internals.</span>PriorityQueue
            <span class="apidocSignatureSpan">(capacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.SchedulePeriodicRecursive">
            function <span class="apidocSignatureSpan">rx.internals.</span>SchedulePeriodicRecursive
            <span class="apidocSignatureSpan">(scheduler, state, period, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem">
            function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledItem
            <span class="apidocSignatureSpan">(scheduler, state, action, dueTime, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver">
            function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledObserver
            <span class="apidocSignatureSpan">(scheduler, observer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.addProperties">
            function <span class="apidocSignatureSpan">rx.internals.</span>addProperties
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.addRef">
            function <span class="apidocSignatureSpan">rx.internals.</span>addRef
            <span class="apidocSignatureSpan">(xs, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.bindCallback">
            function <span class="apidocSignatureSpan">rx.internals.</span>bindCallback
            <span class="apidocSignatureSpan">(func, thisArg, argCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.inherits">
            function <span class="apidocSignatureSpan">rx.internals.</span>inherits
            <span class="apidocSignatureSpan">(child, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.isEqual">
            function <span class="apidocSignatureSpan">rx.internals.</span>isEqual
            <span class="apidocSignatureSpan">(value, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.isObject">
            function <span class="apidocSignatureSpan">rx.internals.</span>isObject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.tryCatch">
            function <span class="apidocSignatureSpan">rx.internals.</span>tryCatch
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.AbstractObserver">module rx.internals.AbstractObserver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.AbstractObserver">
            function <span class="apidocSignatureSpan">rx.internals.</span>AbstractObserver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.AbstractObserver.prototype">module rx.internals.AbstractObserver.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.completed">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>completed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.error">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.fail">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>fail
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.next">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.onCompleted">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>onCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.onError">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.AbstractObserver.prototype.onNext">
            function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>onNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.Enumerable">module rx.internals.Enumerable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable.Enumerable">
            function <span class="apidocSignatureSpan">rx.internals.</span>Enumerable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable.of">
            function <span class="apidocSignatureSpan">rx.internals.Enumerable.</span>of
            <span class="apidocSignatureSpan">(source, selector, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable.repeat">
            function <span class="apidocSignatureSpan">rx.internals.Enumerable.</span>repeat
            <span class="apidocSignatureSpan">(value, repeatCount)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.Enumerable.prototype">module rx.internals.Enumerable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable.prototype.catchError">
            function <span class="apidocSignatureSpan">rx.internals.Enumerable.prototype.</span>catchError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.Enumerable.prototype.concat">
            function <span class="apidocSignatureSpan">rx.internals.Enumerable.prototype.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.PriorityQueue">module rx.internals.PriorityQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.PriorityQueue">
            function <span class="apidocSignatureSpan">rx.internals.</span>PriorityQueue
            <span class="apidocSignatureSpan">(capacity)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rx.internals.PriorityQueue.</span>count</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.PriorityQueue.prototype">module rx.internals.PriorityQueue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.dequeue">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>dequeue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.enqueue">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.heapify">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>heapify
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.isHigherPriority">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>isHigherPriority
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.peek">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.percolate">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>percolate
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.remove">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>remove
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.PriorityQueue.prototype.removeAt">
            function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>removeAt
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.SchedulePeriodicRecursive">module rx.internals.SchedulePeriodicRecursive</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.SchedulePeriodicRecursive.SchedulePeriodicRecursive">
            function <span class="apidocSignatureSpan">rx.internals.</span>SchedulePeriodicRecursive
            <span class="apidocSignatureSpan">(scheduler, state, period, action)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.SchedulePeriodicRecursive.prototype">module rx.internals.SchedulePeriodicRecursive.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.SchedulePeriodicRecursive.prototype.start">
            function <span class="apidocSignatureSpan">rx.internals.SchedulePeriodicRecursive.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.ScheduledItem">module rx.internals.ScheduledItem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem.ScheduledItem">
            function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledItem
            <span class="apidocSignatureSpan">(scheduler, state, action, dueTime, comparer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.ScheduledItem.prototype">module rx.internals.ScheduledItem.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem.prototype.compareTo">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>compareTo
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem.prototype.invoke">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>invoke
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem.prototype.invokeCore">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>invokeCore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledItem.prototype.isCancelled">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>isCancelled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.ScheduledObserver">module rx.internals.ScheduledObserver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.ScheduledObserver">
            function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledObserver
            <span class="apidocSignatureSpan">(scheduler, observer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rx.internals.ScheduledObserver.prototype">module rx.internals.ScheduledObserver.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.prototype.completed">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>completed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.prototype.constructor">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>constructor
            <span class="apidocSignatureSpan">(scheduler, observer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.prototype.dispose">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.prototype.ensureActive">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>ensureActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.prototype.error">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>error
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rx.internals.ScheduledObserver.prototype.next">
            function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>next
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx" id="apidoc.module.rx">module rx</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousObservable" id="apidoc.element.rx.AnonymousObservable">
        function <span class="apidocSignatureSpan">rx.</span>AnonymousObservable
        <span class="apidocSignatureSpan">(subscribe, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObservable(subscribe, parent) {
  this.source = parent;
  this.__subscribe = subscribe;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} [callback] The function called per iteration.
 * @param {Any} [thisArg] The this binding of callback.
 * @returns {Observable} An Observable sequence which contains items that the callback does not return truthy for.
 */
Rx.Observable.prototype.reject = function (callback, thisArg) {
callback || (callback = Rx.helpers.identity);
var source = this;
return new Rx.<span class="apidocCodeKeywordSpan">AnonymousObservable</span>(function (observer) {
  var i = 0;
  return source.subscribe(
    function (x) {
      var noYield = true;
      try {
        noYield = callback.call(thisArg, x, i++, source);
      } catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousObserver" id="apidoc.element.rx.AnonymousObserver">
        function <span class="apidocSignatureSpan">rx.</span>AnonymousObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObserver(onNext, onError, onCompleted) {
  __super__.call(this);
  this._onNext = onNext;
  this._onError = onError;
  this._onCompleted = onCompleted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject" id="apidoc.element.rx.AnonymousSubject">
        function <span class="apidocSignatureSpan">rx.</span>AnonymousSubject
        <span class="apidocSignatureSpan">(observer, observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(observer, observable) {
  this.observer = observer;
  this.observable = observable;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ArgumentOutOfRangeError" id="apidoc.element.rx.ArgumentOutOfRangeError">
        function <span class="apidocSignatureSpan">rx.</span>ArgumentOutOfRangeError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ArgumentOutOfRangeError = function () {
  this.message = 'Argument out of range';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.
* @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.
* If omitted, this will emit the rest of the Observable object.
* @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.
*/
observableProto.slice = function (begin, end) {
  var start = begin || 0;
  if (start &lt; 0) { throw new Rx.<span class="apidocCodeKeywordSpan">ArgumentOutOfRangeError</span>(); }
  if (typeof end === 'number' &amp;&amp; end &lt; start) {
    throw new Rx.ArgumentOutOfRangeError();
  }
  return new SliceObservable(this, start, end);
};

var LastIndexOfObservable = (function (__super__) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject" id="apidoc.element.rx.AsyncSubject">
        function <span class="apidocSignatureSpan">rx.</span>AsyncSubject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.hasValue = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject" id="apidoc.element.rx.BehaviorSubject">
        function <span class="apidocSignatureSpan">rx.</span>BehaviorSubject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(value) {
  __super__.call(this);
  this.value = value;
  this.observers = [];
  this.isDisposed = false;
  this.isStopped = false;
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BinaryDisposable" id="apidoc.element.rx.BinaryDisposable">
        function <span class="apidocSignatureSpan">rx.</span>BinaryDisposable
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BinaryDisposable = function (first, second) {
  this._first = first;
  this._second = second;
  this.isDisposed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.CompositeDisposable" id="apidoc.element.rx.CompositeDisposable">
        function <span class="apidocSignatureSpan">rx.</span>CompositeDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompositeDisposable = function () {
  var args = [], i, len;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    len = arguments.length;
    args = new Array(len);
    for(i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  this.disposables = args;
  this.isDisposed = false;
  this.length = args.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.CompositeError" id="apidoc.element.rx.CompositeError">
        function <span class="apidocSignatureSpan">rx.</span>CompositeError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompositeError = function (errors) {
  this.innerErrors = errors;
  this.message = 'This contains multiple errors. Check the innerErrors';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ConnectableObservable" id="apidoc.element.rx.ConnectableObservable">
        function <span class="apidocSignatureSpan">rx.</span>ConnectableObservable
        <span class="apidocSignatureSpan">(source, subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subject) {
  this.source = source;
  this._connection = null;
  this._source = source.asObservable();
  this._subject = subject;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Disposable" id="apidoc.element.rx.Disposable">
        function <span class="apidocSignatureSpan">rx.</span>Disposable
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Disposable = function (action) {
  this.isDisposed = false;
  this.action = action || noop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.EmptyError" id="apidoc.element.rx.EmptyError">
        function <span class="apidocSignatureSpan">rx.</span>EmptyError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EmptyError = function () {
  this.message = 'Sequence contains no elements.';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.FlatMapObservable" id="apidoc.element.rx.FlatMapObservable">
        function <span class="apidocSignatureSpan">rx.</span>FlatMapObservable
        <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FlatMapObservable(source, selector, resultSelector, thisArg) {
  this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
  this.selector = bindCallback(isFunction(selector) ? selector : function() { return selector; }, thisArg, 3);
  this.source = source;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.HistoricalScheduler" id="apidoc.element.rx.HistoricalScheduler">
        function <span class="apidocSignatureSpan">rx.</span>HistoricalScheduler
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HistoricalScheduler(initialClock, comparer) {
  var clock = initialClock == null ? 0 : initialClock;
  var cmp = comparer || defaultSubComparer;
  __super__.call(this, clock, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * @param {Function} comparer Comparer to determine causality of events based on absolute time.
         */
        new (initialClock: number, comparer: _Comparer&lt;number, number&gt;): HistoricalScheduler;
    };
}

(function() {
    var a: Rx.HistoricalScheduler = new Rx.<span class="apidocCodeKeywordSpan">HistoricalScheduler</span>(1, (a, b) =&gt; 1);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.MockDisposable" id="apidoc.element.rx.MockDisposable">
        function <span class="apidocSignatureSpan">rx.</span>MockDisposable
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MockDisposable = function (scheduler) {
  this.scheduler = scheduler;
  this.disposes = [];
  this.disposes.push(this.scheduler.clock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.NAryDisposable" id="apidoc.element.rx.NAryDisposable">
        function <span class="apidocSignatureSpan">rx.</span>NAryDisposable
        <span class="apidocSignatureSpan">(disposables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NAryDisposable = function (disposables) {
  this._disposables = disposables;
  this.isDisposed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.NotImplementedError" id="apidoc.element.rx.NotImplementedError">
        function <span class="apidocSignatureSpan">rx.</span>NotImplementedError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotImplementedError = function (message) {
  this.message = message || 'This operation is not implemented';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.NotSupportedError" id="apidoc.element.rx.NotSupportedError">
        function <span class="apidocSignatureSpan">rx.</span>NotSupportedError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotSupportedError = function (message) {
  this.message = message || 'This operation is not supported';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification" id="apidoc.element.rx.Notification">
        function <span class="apidocSignatureSpan">rx.</span>Notification
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Notification() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ObjectDisposedError" id="apidoc.element.rx.ObjectDisposedError">
        function <span class="apidocSignatureSpan">rx.</span>ObjectDisposedError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ObjectDisposedError = function () {
  this.message = 'Object has been disposed';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable" id="apidoc.element.rx.Observable">
        function <span class="apidocSignatureSpan">rx.</span>Observable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable() {
  if (Rx.config.longStackSupport &amp;&amp; hasStacks) {
    var oldSubscribe = this._subscribe;
    var e = tryCatch(thrower)(new Error()).e;
    this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
    this._subscribe = makeSubscribe(this, oldSubscribe);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ObservableBase" id="apidoc.element.rx.ObservableBase">
        function <span class="apidocSignatureSpan">rx.</span>ObservableBase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableBase() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer" id="apidoc.element.rx.Observer">
        function <span class="apidocSignatureSpan">rx.</span>Observer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Observer = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Pauser" id="apidoc.element.rx.Pauser">
        function <span class="apidocSignatureSpan">rx.</span>Pauser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pauser() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Recorded" id="apidoc.element.rx.Recorded">
        function <span class="apidocSignatureSpan">rx.</span>Recorded
        <span class="apidocSignatureSpan">(time, value, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Recorded = function (time, value, comparer) {
  this.time = time;
  this.value = value;
  this.comparer = comparer || defaultComparer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.RefCountDisposable" id="apidoc.element.rx.RefCountDisposable">
        function <span class="apidocSignatureSpan">rx.</span>RefCountDisposable
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RefCountDisposable(disposable) {
  this.underlyingDisposable = disposable;
  this.isDisposed = false;
  this.isPrimaryDisposed = false;
  this.count = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject" id="apidoc.element.rx.ReplaySubject">
        function <span class="apidocSignatureSpan">rx.</span>ReplaySubject
        <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowSize, scheduler) {
  this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
  this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
  this.scheduler = scheduler || currentThreadScheduler;
  this.q = [];
  this.observers = [];
  this.isStopped = false;
  this.isDisposed = false;
  this.hasError = false;
  this.error = null;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler" id="apidoc.element.rx.Scheduler">
        function <span class="apidocSignatureSpan">rx.</span>Scheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scheduler() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.SerialDisposable" id="apidoc.element.rx.SerialDisposable">
        function <span class="apidocSignatureSpan">rx.</span>SerialDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialDisposable = function () {
  this.isDisposed = false;
  this.current = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.SingleAssignmentDisposable" id="apidoc.element.rx.SingleAssignmentDisposable">
        function <span class="apidocSignatureSpan">rx.</span>SingleAssignmentDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SingleAssignmentDisposable = function () {
  this.isDisposed = false;
  this.current = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject" id="apidoc.element.rx.Subject">
        function <span class="apidocSignatureSpan">rx.</span>Subject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return PausableObservable;

}(Observable));

/**
 * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
 * @example
 * var pauser = new Rx.<span class="apidocCodeKeywordSpan">Subject</span>();
 * var source = Rx.Observable.interval(100).pausable(pauser);
 * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
 * @returns {Observable} The observable sequence which is paused based upon the pauser.
 */
observableProto.pausable = function (pauser) {
  return new PausableObservable(this, pauser);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subscription" id="apidoc.element.rx.Subscription">
        function <span class="apidocSignatureSpan">rx.</span>Subscription
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (start, end) {
  this.subscribe = start;
  this.unsubscribe = end || Number.MAX_VALUE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler" id="apidoc.element.rx.TestScheduler">
        function <span class="apidocSignatureSpan">rx.</span>TestScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler() {
  __super__.call(this, 0, baseComparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TimeoutError" id="apidoc.element.rx.TimeoutError">
        function <span class="apidocSignatureSpan">rx.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimeoutError = function (message) {
  this.message = message || 'Timeout has occurred';
  this.name = 'TimeoutError';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler" id="apidoc.element.rx.VirtualTimeScheduler">
        function <span class="apidocSignatureSpan">rx.</span>VirtualTimeScheduler
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(initialClock, comparer) {
  this.clock = initialClock;
  this.comparer = comparer;
  this.isEnabled = false;
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver" id="apidoc.element.rx.internals.AbstractObserver">
        function <span class="apidocSignatureSpan">rx.</span>internals.AbstractObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractObserver() {
  this.isStopped = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable" id="apidoc.element.rx.internals.Enumerable">
        function <span class="apidocSignatureSpan">rx.</span>internals.Enumerable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">internals.Enumerable = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue" id="apidoc.element.rx.internals.PriorityQueue">
        function <span class="apidocSignatureSpan">rx.</span>internals.PriorityQueue
        <span class="apidocSignatureSpan">(capacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">internals.PriorityQueue = function (capacity) {
  this.items = new Array(capacity);
  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.SchedulePeriodicRecursive" id="apidoc.element.rx.internals.SchedulePeriodicRecursive">
        function <span class="apidocSignatureSpan">rx.</span>internals.SchedulePeriodicRecursive
        <span class="apidocSignatureSpan">(scheduler, state, period, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SchedulePeriodicRecursive(scheduler, state, period, action) {
  this._scheduler = scheduler;
  this._state = state;
  this._period = period;
  this._action = action;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        export var SchedulePeriodicRecursive: SchedulePeriodicRecursiveStatic;
    }
}

(function() {
    var item = new Rx.<span class="apidocCodeKeywordSpan">internals.SchedulePeriodicRecursive</span>(undefined, undefined, undefined
, undefined);

    var d : Rx.IDisposable = item.start();
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem" id="apidoc.element.rx.internals.ScheduledItem">
        function <span class="apidocSignatureSpan">rx.</span>internals.ScheduledItem
        <span class="apidocSignatureSpan">(scheduler, state, action, dueTime, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
  this.scheduler = scheduler;
  this.state = state;
  this.action = action;
  this.dueTime = dueTime;
  this.comparer = comparer || defaultSubComparer;
  this.disposable = new SingleAssignmentDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    export var ScheduledItem: ScheduledItemStatic
}
}

(function() {
var item = new Rx.<span class="apidocCodeKeywordSpan">internals.ScheduledItem</span>(Rx.Scheduler.default, {}, (sc, s) =&gt; Rx
.Disposable.create(() =&gt; {}), 100);
var item = new Rx.internals.ScheduledItem(Rx.Scheduler.default, {}, (sc, s) =&gt; Rx.Disposable.create(() =&gt; {}), 100, (x
, y) =&gt; 500);

item.scheduler
item.state;
item.action;
item.dueTime;
item.comparer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver" id="apidoc.element.rx.internals.ScheduledObserver">
        function <span class="apidocSignatureSpan">rx.</span>internals.ScheduledObserver
        <span class="apidocSignatureSpan">(scheduler, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScheduledObserver(scheduler, observer) {
  __super__.call(this);
  this.scheduler = scheduler;
  this.observer = observer;
  this.isAcquired = false;
  this.hasFaulted = false;
  this.queue = [];
  this.disposable = new SerialDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AnonymousObservable" id="apidoc.module.rx.AnonymousObservable">module rx.AnonymousObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousObservable.AnonymousObservable" id="apidoc.element.rx.AnonymousObservable.AnonymousObservable">
        function <span class="apidocSignatureSpan">rx.</span>AnonymousObservable
        <span class="apidocSignatureSpan">(subscribe, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObservable(subscribe, parent) {
  this.source = parent;
  this.__subscribe = subscribe;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} [callback] The function called per iteration.
 * @param {Any} [thisArg] The this binding of callback.
 * @returns {Observable} An Observable sequence which contains items that the callback does not return truthy for.
 */
Rx.Observable.prototype.reject = function (callback, thisArg) {
callback || (callback = Rx.helpers.identity);
var source = this;
return new Rx.<span class="apidocCodeKeywordSpan">AnonymousObservable</span>(function (observer) {
  var i = 0;
  return source.subscribe(
    function (x) {
      var noYield = true;
      try {
        noYield = callback.call(thisArg, x, i++, source);
      } catch (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AnonymousObservable.prototype" id="apidoc.module.rx.AnonymousObservable.prototype">module rx.AnonymousObservable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousObservable.prototype._subscribe" id="apidoc.element.rx.AnonymousObservable.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.AnonymousObservable.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  var ado = new AutoDetachObserver(o), state = [ado, this];

  if (currentThreadScheduler.scheduleRequired()) {
    currentThreadScheduler.schedule(state, setDisposable);
  } else {
    setDisposable(null, state);
  }
  return ado;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousObservable.prototype.constructor" id="apidoc.element.rx.AnonymousObservable.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.AnonymousObservable.prototype.</span>constructor
        <span class="apidocSignatureSpan">(subscribe, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObservable(subscribe, parent) {
  this.source = parent;
  this.__subscribe = subscribe;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AnonymousObserver" id="apidoc.module.rx.AnonymousObserver">module rx.AnonymousObserver</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousObserver.AnonymousObserver" id="apidoc.element.rx.AnonymousObserver.AnonymousObserver">
        function <span class="apidocSignatureSpan">rx.</span>AnonymousObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObserver(onNext, onError, onCompleted) {
  __super__.call(this);
  this._onNext = onNext;
  this._onError = onError;
  this._onCompleted = onCompleted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AnonymousObserver.prototype" id="apidoc.module.rx.AnonymousObserver.prototype">module rx.AnonymousObserver.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousObserver.prototype.completed" id="apidoc.element.rx.AnonymousObserver.prototype.completed">
        function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>completed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completed = function () {
  this._onCompleted();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Notifies the observer of the end of the sequence.
 */
AbstractObserver.prototype.onCompleted = function () {
  if (!this.isStopped) {
    this.isStopped = true;
    this.<span class="apidocCodeKeywordSpan">completed</span>();
  }
};

/**
 * Disposes the observer, causing it to transition to the stopped state.
 */
AbstractObserver.prototype.dispose = function () { this.isStopped = true; };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousObserver.prototype.constructor" id="apidoc.element.rx.AnonymousObserver.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>constructor
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObserver(onNext, onError, onCompleted) {
  __super__.call(this);
  this._onNext = onNext;
  this._onError = onError;
  this._onCompleted = onCompleted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousObserver.prototype.error" id="apidoc.element.rx.AnonymousObserver.prototype.error">
        function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>error
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (error) {
  this._onError(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Notifies the observer that an exception has occurred.
 * @param {Any} error The error that has occurred.
 */
AbstractObserver.prototype.onError = function (error) {
  if (!this.isStopped) {
    this.isStopped = true;
    this.<span class="apidocCodeKeywordSpan">error</span>(error);
  }
};

/**
 * Notifies the observer of the end of the sequence.
 */
AbstractObserver.prototype.onCompleted = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousObserver.prototype.next" id="apidoc.element.rx.AnonymousObserver.prototype.next">
        function <span class="apidocSignatureSpan">rx.AnonymousObserver.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
  this._onNext(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AbstractObserver.prototype.completed = notImplemented;

/**
 * Notifies the observer of a new element in the sequence.
 * @param {Any} value Next element in the sequence.
 */
AbstractObserver.prototype.onNext = function (value) {
  !this.isStopped &amp;&amp; this.<span class="apidocCodeKeywordSpan">next</span>(value);
};

/**
 * Notifies the observer that an exception has occurred.
 * @param {Any} error The error that has occurred.
 */
AbstractObserver.prototype.onError = function (error) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AnonymousSubject" id="apidoc.module.rx.AnonymousSubject">module rx.AnonymousSubject</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.AnonymousSubject" id="apidoc.element.rx.AnonymousSubject.AnonymousSubject">
        function <span class="apidocSignatureSpan">rx.</span>AnonymousSubject
        <span class="apidocSignatureSpan">(observer, observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(observer, observable) {
  this.observer = observer;
  this.observable = observable;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AnonymousSubject.prototype" id="apidoc.module.rx.AnonymousSubject.prototype">module rx.AnonymousSubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype._subscribe" id="apidoc.element.rx.AnonymousSubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  return this.observable.subscribe(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.asObserver" id="apidoc.element.rx.AnonymousSubject.prototype.asObserver">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>asObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObserver = function () {
  var self = this;
  return new AnonymousObserver(
    function (x) { self.onNext(x); },
    function (err) { self.onError(err); },
    function () { self.onCompleted(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">asObserver</span>();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.checked" id="apidoc.element.rx.AnonymousSubject.prototype.checked">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>checked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checked = function () { return new CheckedObserver(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">checked</span>();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.constructor" id="apidoc.element.rx.AnonymousSubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">(observer, observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(observer, observable) {
  this.observer = observer;
  this.observable = observable;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.makeSafe" id="apidoc.element.rx.AnonymousSubject.prototype.makeSafe">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>makeSafe
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSafe = function (disposable) {
  return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	export interface Observer&lt;T&gt; {
        makeSafe(disposable: IDisposable): Observer&lt;T&gt;;
	}
}

(function() {
    var observer: Rx.Observer&lt;boolean&gt;;
	observer = observer.<span class="apidocCodeKeywordSpan">makeSafe</span>(Rx.Disposable.create(() =&gt; {}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.notifyOn" id="apidoc.element.rx.AnonymousSubject.prototype.notifyOn">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>notifyOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyOn = function (scheduler) {
  return new ObserveOnObserver(scheduler, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.<span class="apidocCodeKeywordSpan">notifyOn</span>(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.onCompleted" id="apidoc.element.rx.AnonymousSubject.prototype.onCompleted">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>onCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function () {
  this.observer.onCompleted();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.onError" id="apidoc.element.rx.AnonymousSubject.prototype.onError">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
  this.observer.onError(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.onNext" id="apidoc.element.rx.AnonymousSubject.prototype.onNext">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>onNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (value) {
  this.observer.onNext(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AnonymousSubject.prototype.toNotifier" id="apidoc.element.rx.AnonymousSubject.prototype.toNotifier">
        function <span class="apidocSignatureSpan">rx.AnonymousSubject.prototype.</span>toNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNotifier = function () {
  var observer = this;
  return function (n) { return n.accept(observer); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		fromNotifier&lt;T&gt;(handler: (notification: Notification&lt;T&gt;, thisArg?: any) =&gt; void): Observer&lt;T&gt;
;;
	}
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.<span class="apidocCodeKeywordSpan">toNotifier
</span>();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AsyncSubject" id="apidoc.module.rx.AsyncSubject">module rx.AsyncSubject</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.AsyncSubject" id="apidoc.element.rx.AsyncSubject.AsyncSubject">
        function <span class="apidocSignatureSpan">rx.</span>AsyncSubject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.hasValue = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.AsyncSubject.prototype" id="apidoc.module.rx.AsyncSubject.prototype">module rx.AsyncSubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype._subscribe" id="apidoc.element.rx.AsyncSubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  checkDisposed(this);

  if (!this.isStopped) {
    this.observers.push(o);
    return new InnerSubscription(this, o);
  }

  if (this.hasError) {
    o.onError(this.error);
  } else if (this.hasValue) {
    o.onNext(this.value);
    o.onCompleted();
  } else {
    o.onCompleted();
  }

  return disposableEmpty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.asObserver" id="apidoc.element.rx.AsyncSubject.prototype.asObserver">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>asObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObserver = function () {
  var self = this;
  return new AnonymousObserver(
    function (x) { self.onNext(x); },
    function (err) { self.onError(err); },
    function () { self.onCompleted(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">asObserver</span>();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.checked" id="apidoc.element.rx.AsyncSubject.prototype.checked">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>checked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checked = function () { return new CheckedObserver(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">checked</span>();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.constructor" id="apidoc.element.rx.AsyncSubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.hasValue = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.dispose" id="apidoc.element.rx.AsyncSubject.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  this.isDisposed = true;
  this.observers = null;
  this.error = null;
  this.value = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.hasObservers" id="apidoc.element.rx.AsyncSubject.prototype.hasObservers">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>hasObservers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasObservers = function () { checkDisposed(this); return this.observers.length &gt; 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.makeSafe" id="apidoc.element.rx.AsyncSubject.prototype.makeSafe">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>makeSafe
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSafe = function (disposable) {
  return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	export interface Observer&lt;T&gt; {
        makeSafe(disposable: IDisposable): Observer&lt;T&gt;;
	}
}

(function() {
    var observer: Rx.Observer&lt;boolean&gt;;
	observer = observer.<span class="apidocCodeKeywordSpan">makeSafe</span>(Rx.Disposable.create(() =&gt; {}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.notifyOn" id="apidoc.element.rx.AsyncSubject.prototype.notifyOn">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>notifyOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyOn = function (scheduler) {
  return new ObserveOnObserver(scheduler, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.<span class="apidocCodeKeywordSpan">notifyOn</span>(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.onCompleted" id="apidoc.element.rx.AsyncSubject.prototype.onCompleted">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>onCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function () {
  var i, len;
  checkDisposed(this);
  if (!this.isStopped) {
    this.isStopped = true;
    var os = cloneArray(this.observers), len = os.length;

    if (this.hasValue) {
      for (i = 0; i &lt; len; i++) {
        var o = os[i];
        o.onNext(this.value);
        o.onCompleted();
      }
    } else {
      for (i = 0; i &lt; len; i++) {
        os[i].onCompleted();
      }
    }

    this.observers.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.onError" id="apidoc.element.rx.AsyncSubject.prototype.onError">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
  checkDisposed(this);
  if (!this.isStopped) {
    this.isStopped = true;
    this.hasError = true;
    this.error = error;

    for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
      os[i].onError(error);
    }

    this.observers.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.onNext" id="apidoc.element.rx.AsyncSubject.prototype.onNext">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>onNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (value) {
  checkDisposed(this);
  if (this.isStopped) { return; }
  this.value = value;
  this.hasValue = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.AsyncSubject.prototype.toNotifier" id="apidoc.element.rx.AsyncSubject.prototype.toNotifier">
        function <span class="apidocSignatureSpan">rx.AsyncSubject.prototype.</span>toNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNotifier = function () {
  var observer = this;
  return function (n) { return n.accept(observer); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		fromNotifier&lt;T&gt;(handler: (notification: Notification&lt;T&gt;, thisArg?: any) =&gt; void): Observer&lt;T&gt;
;;
	}
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.<span class="apidocCodeKeywordSpan">toNotifier
</span>();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.BehaviorSubject" id="apidoc.module.rx.BehaviorSubject">module rx.BehaviorSubject</a></h1>


    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.BehaviorSubject" id="apidoc.element.rx.BehaviorSubject.BehaviorSubject">
        function <span class="apidocSignatureSpan">rx.</span>BehaviorSubject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(value) {
  __super__.call(this);
  this.value = value;
  this.observers = [];
  this.isDisposed = false;
  this.isStopped = false;
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.BehaviorSubject.prototype" id="apidoc.module.rx.BehaviorSubject.prototype">module rx.BehaviorSubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype._subscribe" id="apidoc.element.rx.BehaviorSubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  checkDisposed(this);
  if (!this.isStopped) {
    this.observers.push(o);
    o.onNext(this.value);
    return new InnerSubscription(this, o);
  }
  if (this.hasError) {
    o.onError(this.error);
  } else {
    o.onCompleted();
  }
  return disposableEmpty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.asObserver" id="apidoc.element.rx.BehaviorSubject.prototype.asObserver">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>asObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObserver = function () {
  var self = this;
  return new AnonymousObserver(
    function (x) { self.onNext(x); },
    function (err) { self.onError(err); },
    function () { self.onCompleted(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">asObserver</span>();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.checked" id="apidoc.element.rx.BehaviorSubject.prototype.checked">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>checked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checked = function () { return new CheckedObserver(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">checked</span>();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.constructor" id="apidoc.element.rx.BehaviorSubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(value) {
  __super__.call(this);
  this.value = value;
  this.observers = [];
  this.isDisposed = false;
  this.isStopped = false;
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.dispose" id="apidoc.element.rx.BehaviorSubject.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  this.isDisposed = true;
  this.observers = null;
  this.value = null;
  this.error = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.getValue" id="apidoc.element.rx.BehaviorSubject.prototype.getValue">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>getValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValue = function () {
  checkDisposed(this);
  if (this.hasError) { thrower(this.error); }
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.hasObservers" id="apidoc.element.rx.BehaviorSubject.prototype.hasObservers">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>hasObservers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasObservers = function () { checkDisposed(this); return this.observers.length &gt; 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.makeSafe" id="apidoc.element.rx.BehaviorSubject.prototype.makeSafe">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>makeSafe
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSafe = function (disposable) {
  return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	export interface Observer&lt;T&gt; {
        makeSafe(disposable: IDisposable): Observer&lt;T&gt;;
	}
}

(function() {
    var observer: Rx.Observer&lt;boolean&gt;;
	observer = observer.<span class="apidocCodeKeywordSpan">makeSafe</span>(Rx.Disposable.create(() =&gt; {}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.notifyOn" id="apidoc.element.rx.BehaviorSubject.prototype.notifyOn">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>notifyOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyOn = function (scheduler) {
  return new ObserveOnObserver(scheduler, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.<span class="apidocCodeKeywordSpan">notifyOn</span>(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.onCompleted" id="apidoc.element.rx.BehaviorSubject.prototype.onCompleted">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>onCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function () {
  checkDisposed(this);
  if (this.isStopped) { return; }
  this.isStopped = true;
  for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
    os[i].onCompleted();
  }

  this.observers.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.onError" id="apidoc.element.rx.BehaviorSubject.prototype.onError">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
  checkDisposed(this);
  if (this.isStopped) { return; }
  this.isStopped = true;
  this.hasError = true;
  this.error = error;

  for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
    os[i].onError(error);
  }

  this.observers.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.onNext" id="apidoc.element.rx.BehaviorSubject.prototype.onNext">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>onNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (value) {
  checkDisposed(this);
  if (this.isStopped) { return; }
  this.value = value;
  for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
    os[i].onNext(value);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.BehaviorSubject.prototype.toNotifier" id="apidoc.element.rx.BehaviorSubject.prototype.toNotifier">
        function <span class="apidocSignatureSpan">rx.BehaviorSubject.prototype.</span>toNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNotifier = function () {
  var observer = this;
  return function (n) { return n.accept(observer); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		fromNotifier&lt;T&gt;(handler: (notification: Notification&lt;T&gt;, thisArg?: any) =&gt; void): Observer&lt;T&gt;
;;
	}
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.<span class="apidocCodeKeywordSpan">toNotifier
</span>();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.BinaryDisposable" id="apidoc.module.rx.BinaryDisposable">module rx.BinaryDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.BinaryDisposable.BinaryDisposable" id="apidoc.element.rx.BinaryDisposable.BinaryDisposable">
        function <span class="apidocSignatureSpan">rx.</span>BinaryDisposable
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BinaryDisposable = function (first, second) {
  this._first = first;
  this._second = second;
  this.isDisposed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.BinaryDisposable.prototype" id="apidoc.module.rx.BinaryDisposable.prototype">module rx.BinaryDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.BinaryDisposable.prototype.dispose" id="apidoc.element.rx.BinaryDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.BinaryDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed) {
    this.isDisposed = true;
    var old1 = this._first;
    this._first = null;
    old1 &amp;&amp; old1.dispose();
    var old2 = this._second;
    this._second = null;
    old2 &amp;&amp; old2.dispose();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.CompositeDisposable" id="apidoc.module.rx.CompositeDisposable">module rx.CompositeDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.CompositeDisposable.CompositeDisposable" id="apidoc.element.rx.CompositeDisposable.CompositeDisposable">
        function <span class="apidocSignatureSpan">rx.</span>CompositeDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompositeDisposable = function () {
  var args = [], i, len;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    len = arguments.length;
    args = new Array(len);
    for(i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  this.disposables = args;
  this.isDisposed = false;
  this.length = args.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.CompositeDisposable.prototype" id="apidoc.module.rx.CompositeDisposable.prototype">module rx.CompositeDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.CompositeDisposable.prototype.add" id="apidoc.element.rx.CompositeDisposable.prototype.add">
        function <span class="apidocSignatureSpan">rx.CompositeDisposable.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (item) {
  if (this.isDisposed) {
    item.dispose();
  } else {
    this.disposables.push(item);
    this.length++;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ToSetObserver(o) {
  this._o = o;
  this._s = new root.Set();
  __super__.call(this);
}

ToSetObserver.prototype.next = function (x) {
  this._s.<span class="apidocCodeKeywordSpan">add</span>(x);
};

ToSetObserver.prototype.error = function (e) {
  this._o.onError(e);
};

ToSetObserver.prototype.completed = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.CompositeDisposable.prototype.dispose" id="apidoc.element.rx.CompositeDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.CompositeDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed) {
    this.isDisposed = true;
    var len = this.disposables.length, currentDisposables = new Array(len);
    for(var i = 0; i &lt; len; i++) { currentDisposables[i] = this.disposables[i]; }
    this.disposables = [];
    this.length = 0;

    for (i = 0; i &lt; len; i++) {
      currentDisposables[i].dispose();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.CompositeDisposable.prototype.remove" id="apidoc.element.rx.CompositeDisposable.prototype.remove">
        function <span class="apidocSignatureSpan">rx.CompositeDisposable.prototype.</span>remove
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (item) {
  var shouldDispose = false;
  if (!this.isDisposed) {
    var idx = this.disposables.indexOf(item);
    if (idx !== -1) {
      shouldDispose = true;
      this.disposables.splice(idx, 1);
      this.length--;
      item.dispose();
    }
  }
  return shouldDispose;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!isDone) {
    group.add(d);
    isAdded = true;
  }

  function scheduleWork(_, state3) {
    if (isAdded) {
      group.<span class="apidocCodeKeywordSpan">remove</span>(d);
    } else {
      isDone = true;
    }
    action(state3, innerAction);
    return disposableEmpty;
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ConnectableObservable" id="apidoc.module.rx.ConnectableObservable">module rx.ConnectableObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ConnectableObservable.ConnectableObservable" id="apidoc.element.rx.ConnectableObservable.ConnectableObservable">
        function <span class="apidocSignatureSpan">rx.</span>ConnectableObservable
        <span class="apidocSignatureSpan">(source, subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subject) {
  this.source = source;
  this._connection = null;
  this._source = source.asObservable();
  this._subject = subject;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ConnectableObservable.prototype" id="apidoc.module.rx.ConnectableObservable.prototype">module rx.ConnectableObservable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ConnectableObservable.prototype._subscribe" id="apidoc.element.rx.ConnectableObservable.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  return this._subject.subscribe(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ConnectableObservable.prototype.connect" id="apidoc.element.rx.ConnectableObservable.prototype.connect">
        function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  if (!this._connection) {
    if (this._subject.isStopped) {
      return disposableEmpty;
    }
    var subscription = this._source.subscribe(this._subject);
    this._connection = new ConnectDisposable(this, subscription);
  }
  return this._connection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PausableObservable.prototype._subscribe = function (o) {
var conn = this.source.publish(),
  subscription = conn.subscribe(o),
  connection = disposableEmpty;

var pausable = this.pauser.startWith(!this.paused).distinctUntilChanged().subscribe(function (b) {
  if (b) {
    connection = conn.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    connection.dispose();
    connection = disposableEmpty;
  }
});

return new NAryDisposable([subscription, connection, pausable]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ConnectableObservable.prototype.constructor" id="apidoc.element.rx.ConnectableObservable.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>constructor
        <span class="apidocSignatureSpan">(source, subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subject) {
  this.source = source;
  this._connection = null;
  this._source = source.asObservable();
  this._subject = subject;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ConnectableObservable.prototype.refCount" id="apidoc.element.rx.ConnectableObservable.prototype.refCount">
        function <span class="apidocSignatureSpan">rx.ConnectableObservable.prototype.</span>refCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refCount = function () {
  return new RefCountObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return fromEventPattern(
        function (h) { element.on(eventName, h); },
        function (h) { element.off(eventName, h); },
        selector);
    }
  }

  return new EventObservable(element, eventName, selector).publish().<span class="apidocCodeKeywordSpan">refCount</span>();
};

var EventPatternObservable = (function(__super__) {
  inherits(EventPatternObservable, __super__);
  function EventPatternObservable(add, del, fn) {
    this._add = add;
    this._del = del;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Disposable" id="apidoc.module.rx.Disposable">module rx.Disposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Disposable.Disposable" id="apidoc.element.rx.Disposable.Disposable">
        function <span class="apidocSignatureSpan">rx.</span>Disposable
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Disposable = function (action) {
  this.isDisposed = false;
  this.action = action || noop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Disposable._fixup" id="apidoc.element.rx.Disposable._fixup">
        function <span class="apidocSignatureSpan">rx.Disposable.</span>_fixup
        <span class="apidocSignatureSpan">(result)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixup = function (result) {
  return isDisposable(result) ? result : disposableEmpty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
inherits(DefaultScheduler, __super__);
function DefaultScheduler() {
  __super__.call(this);
}

function scheduleAction(disposable, action, scheduler, state) {
  return function schedule() {
    disposable.setDisposable(Disposable.<span class="apidocCodeKeywordSpan">_fixup</span>(action(scheduler, state)));
  };
}

function ClearDisposable(id) {
  this._id = id;
  this.isDisposed = false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Disposable.checkDisposed" id="apidoc.element.rx.Disposable.checkDisposed">
        function <span class="apidocSignatureSpan">rx.Disposable.</span>checkDisposed
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkDisposed = function (disposable) {
  if (disposable.isDisposed) { throw new ObjectDisposedError(); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Disposable.create" id="apidoc.element.rx.Disposable.create">
        function <span class="apidocSignatureSpan">rx.Disposable.</span>create
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (action) { return new Disposable(action); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  root.CustomEvent = CustomEvent;
}());

var EmptyError = Rx.EmptyError = function() {
  this.message = 'Sequence contains no elements.';
  Error.call(this);
};
EmptyError.prototype = Object.<span class="apidocCodeKeywordSpan">create</span>(Error.prototype);
EmptyError.prototype.name = 'EmptyError';

var ObjectDisposedError = Rx.ObjectDisposedError = function() {
  this.message = 'Object has been disposed';
  Error.call(this);
};
ObjectDisposedError.prototype = Object.create(Error.prototype);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Disposable.isDisposable" id="apidoc.element.rx.Disposable.isDisposable">
        function <span class="apidocSignatureSpan">rx.Disposable.</span>isDisposable
        <span class="apidocSignatureSpan">(d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDisposable = function (d) {
  return d &amp;&amp; isFunction(d.dispose);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Disposable.empty" id="apidoc.module.rx.Disposable.empty">module rx.Disposable.empty</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Disposable.empty.dispose" id="apidoc.element.rx.Disposable.empty.dispose">
        function <span class="apidocSignatureSpan">rx.Disposable.empty.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Disposable.prototype" id="apidoc.module.rx.Disposable.prototype">module rx.Disposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Disposable.prototype.dispose" id="apidoc.element.rx.Disposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.Disposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed) {
    this.action();
    this.isDisposed = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.FlatMapObservable" id="apidoc.module.rx.FlatMapObservable">module rx.FlatMapObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.FlatMapObservable.FlatMapObservable" id="apidoc.element.rx.FlatMapObservable.FlatMapObservable">
        function <span class="apidocSignatureSpan">rx.</span>FlatMapObservable
        <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FlatMapObservable(source, selector, resultSelector, thisArg) {
  this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
  this.selector = bindCallback(isFunction(selector) ? selector : function() { return selector; }, thisArg, 3);
  this.source = source;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.FlatMapObservable.prototype" id="apidoc.module.rx.FlatMapObservable.prototype">module rx.FlatMapObservable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.FlatMapObservable.prototype.constructor" id="apidoc.element.rx.FlatMapObservable.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.FlatMapObservable.prototype.</span>constructor
        <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FlatMapObservable(source, selector, resultSelector, thisArg) {
  this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
  this.selector = bindCallback(isFunction(selector) ? selector : function() { return selector; }, thisArg, 3);
  this.source = source;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.FlatMapObservable.prototype.subscribeCore" id="apidoc.element.rx.FlatMapObservable.prototype.subscribeCore">
        function <span class="apidocSignatureSpan">rx.FlatMapObservable.prototype.</span>subscribeCore
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeCore = function (o) {
  return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.HistoricalScheduler" id="apidoc.module.rx.HistoricalScheduler">module rx.HistoricalScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rx.HistoricalScheduler.HistoricalScheduler" id="apidoc.element.rx.HistoricalScheduler.HistoricalScheduler">
        function <span class="apidocSignatureSpan">rx.</span>HistoricalScheduler
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HistoricalScheduler(initialClock, comparer) {
  var clock = initialClock == null ? 0 : initialClock;
  var cmp = comparer || defaultSubComparer;
  __super__.call(this, clock, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * @param {Function} comparer Comparer to determine causality of events based on absolute time.
         */
        new (initialClock: number, comparer: _Comparer&lt;number, number&gt;): HistoricalScheduler;
    };
}

(function() {
    var a: Rx.HistoricalScheduler = new Rx.<span class="apidocCodeKeywordSpan">HistoricalScheduler</span>(1, (a, b) =&gt; 1);
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.HistoricalScheduler.prototype" id="apidoc.module.rx.HistoricalScheduler.prototype">module rx.HistoricalScheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.HistoricalScheduler.prototype.add" id="apidoc.element.rx.HistoricalScheduler.prototype.add">
        function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>add
        <span class="apidocSignatureSpan">(absolute, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (absolute, relative) {
  return absolute + relative;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ToSetObserver(o) {
  this._o = o;
  this._s = new root.Set();
  __super__.call(this);
}

ToSetObserver.prototype.next = function (x) {
  this._s.<span class="apidocCodeKeywordSpan">add</span>(x);
};

ToSetObserver.prototype.error = function (e) {
  this._o.onError(e);
};

ToSetObserver.prototype.completed = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.HistoricalScheduler.prototype.constructor" id="apidoc.element.rx.HistoricalScheduler.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>constructor
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HistoricalScheduler(initialClock, comparer) {
  var clock = initialClock == null ? 0 : initialClock;
  var cmp = comparer || defaultSubComparer;
  __super__.call(this, clock, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.HistoricalScheduler.prototype.toAbsoluteTime" id="apidoc.element.rx.HistoricalScheduler.prototype.toAbsoluteTime">
        function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>toAbsoluteTime
        <span class="apidocSignatureSpan">(absolute)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAbsoluteTime = function (absolute) {
  return new Date(absolute).getTime();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}

var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

VirtualTimeSchedulerPrototype.now = function () {
  return this.<span class="apidocCodeKeywordSpan">toAbsoluteTime</span>(this.clock);
};

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.HistoricalScheduler.prototype.toRelativeTime" id="apidoc.element.rx.HistoricalScheduler.prototype.toRelativeTime">
        function <span class="apidocSignatureSpan">rx.HistoricalScheduler.prototype.</span>toRelativeTime
        <span class="apidocSignatureSpan">(timeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toRelativeTime = function (timeSpan) {
  return timeSpan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.<span class="apidocCodeKeywordSpan">toRelativeTime</span>(dueTime - this.now()) :
    this.toRelativeTime(dueTime);

  return this.scheduleRelative(state, dt, action);
};

/**
 * Adds a relative time value to an absolute time value.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.MockDisposable" id="apidoc.module.rx.MockDisposable">module rx.MockDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.MockDisposable.MockDisposable" id="apidoc.element.rx.MockDisposable.MockDisposable">
        function <span class="apidocSignatureSpan">rx.</span>MockDisposable
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MockDisposable = function (scheduler) {
  this.scheduler = scheduler;
  this.disposes = [];
  this.disposes.push(this.scheduler.clock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.MockDisposable.prototype" id="apidoc.module.rx.MockDisposable.prototype">module rx.MockDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.MockDisposable.prototype.dispose" id="apidoc.element.rx.MockDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.MockDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  this.disposes.push(this.scheduler.clock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.NAryDisposable" id="apidoc.module.rx.NAryDisposable">module rx.NAryDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.NAryDisposable.NAryDisposable" id="apidoc.element.rx.NAryDisposable.NAryDisposable">
        function <span class="apidocSignatureSpan">rx.</span>NAryDisposable
        <span class="apidocSignatureSpan">(disposables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NAryDisposable = function (disposables) {
  this._disposables = disposables;
  this.isDisposed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.NAryDisposable.prototype" id="apidoc.module.rx.NAryDisposable.prototype">module rx.NAryDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.NAryDisposable.prototype.dispose" id="apidoc.element.rx.NAryDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.NAryDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed) {
    this.isDisposed = true;
    for (var i = 0, len = this._disposables.length; i &lt; len; i++) {
      this._disposables[i].dispose();
    }
    this._disposables.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Notification" id="apidoc.module.rx.Notification">module rx.Notification</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Notification.Notification" id="apidoc.element.rx.Notification.Notification">
        function <span class="apidocSignatureSpan">rx.</span>Notification
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Notification() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification.createOnCompleted" id="apidoc.element.rx.Notification.createOnCompleted">
        function <span class="apidocSignatureSpan">rx.Notification.</span>createOnCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOnCompleted = function () {
  return new OnCompletedNotification();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
onCompleted: function () {
  this.hasCompleted = true;
  if (!this.enableQueue || this.queue.length === 0) {
    this.subject.onCompleted();
    this.disposeCurrentRequest();
  } else {
    this.queue.push(Notification.<span class="apidocCodeKeywordSpan">createOnCompleted</span>());
  }
},
onError: function (error) {
  this.hasFailed = true;
  this.error = error;
  if (!this.enableQueue || this.queue.length === 0) {
    this.subject.onError(error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification.createOnError" id="apidoc.element.rx.Notification.createOnError">
        function <span class="apidocSignatureSpan">rx.Notification.</span>createOnError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOnError = function (error) {
  return new OnErrorNotification(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
onError: function (error) {
  this.hasFailed = true;
  this.error = error;
  if (!this.enableQueue || this.queue.length === 0) {
    this.subject.onError(error);
    this.disposeCurrentRequest();
  } else {
    this.queue.push(Notification.<span class="apidocCodeKeywordSpan">createOnError</span>(error));
  }
},
onNext: function (value) {
  if (this.requestedCount &lt;= 0) {
    this.enableQueue &amp;&amp; this.queue.push(Notification.createOnNext(value));
  } else {
    (this.requestedCount-- === 0) &amp;&amp; this.disposeCurrentRequest();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification.createOnNext" id="apidoc.element.rx.Notification.createOnNext">
        function <span class="apidocSignatureSpan">rx.Notification.</span>createOnNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOnNext = function (value) {
  return new OnNextNotification(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.disposeCurrentRequest();
  } else {
    this.queue.push(Notification.createOnError(error));
  }
},
onNext: function (value) {
  if (this.requestedCount &lt;= 0) {
    this.enableQueue &amp;&amp; this.queue.push(Notification.<span class="apidocCodeKeywordSpan">createOnNext</span>(value));
  } else {
    (this.requestedCount-- === 0) &amp;&amp; this.disposeCurrentRequest();
    this.subject.onNext(value);
  }
},
_processRequest: function (numberOfItems) {
  if (this.enableQueue) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Notification.prototype" id="apidoc.module.rx.Notification.prototype">module rx.Notification.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Notification.prototype._accept" id="apidoc.element.rx.Notification.prototype._accept">
        function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>_accept
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_accept = function (onNext, onError, onCompleted) {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} onError Function to invoke for an OnError notification.
 * @param {Function} onCompleted Function to invoke for an OnCompleted notification.
 * @returns {Any} Result produced by the observation.
 */
Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
  return observerOrOnNext &amp;&amp; typeof observerOrOnNext === 'object' ?
    this._acceptObserver(observerOrOnNext) :
    this.<span class="apidocCodeKeywordSpan">_accept</span>(observerOrOnNext, onError, onCompleted);
};

/**
 * Returns an observable sequence with a single notification.
 *
 * @memberOf Notifications
 * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification.prototype._acceptObserver" id="apidoc.element.rx.Notification.prototype._acceptObserver">
        function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>_acceptObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_acceptObserver = function (onNext, onError, onCompleted) {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification
 on..
 * @param {Function} onError Function to invoke for an OnError notification.
 * @param {Function} onCompleted Function to invoke for an OnCompleted notification.
 * @returns {Any} Result produced by the observation.
 */
Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
  return observerOrOnNext &amp;&amp; typeof observerOrOnNext === 'object' ?
    this.<span class="apidocCodeKeywordSpan">_acceptObserver</span>(observerOrOnNext) :
    this._accept(observerOrOnNext, onError, onCompleted);
};

/**
 * Returns an observable sequence with a single notification.
 *
 * @memberOf Notifications
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification.prototype.accept" id="apidoc.element.rx.Notification.prototype.accept">
        function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>accept
        <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accept = function (observerOrOnNext, onError, onCompleted) {
  return observerOrOnNext &amp;&amp; typeof observerOrOnNext === 'object' ?
    this._acceptObserver(observerOrOnNext) :
    this._accept(observerOrOnNext, onError, onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 *  Creates a notification callback from an observer.
 * @returns The action that forwards its input notification to the underlying observer.
 */
Observer.prototype.toNotifier = function () {
  var observer = this;
  return function (n) { return n.<span class="apidocCodeKeywordSpan">accept</span>(observer); };
};

/**
 *  Hides the identity of an observer.
 * @returns An observer that hides the identity of the specified observer.
 */
Observer.prototype.asObserver = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Notification.prototype.toObservable" id="apidoc.element.rx.Notification.prototype.toObservable">
        function <span class="apidocSignatureSpan">rx.Notification.prototype.</span>toObservable
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObservable = function (scheduler) {
  var self = this;
  isScheduler(scheduler) || (scheduler = immediateScheduler);
  return new AnonymousObservable(function (o) {
    return scheduler.schedule(self, function (_, notification) {
      notification._acceptObserver(o);
      notification.kind === 'N' &amp;&amp; o.onCompleted();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(function() {
    var notification: Rx.Notification&lt;number&gt; = new Rx.Notification&lt;number&gt;(undefined, undefined, undefined,
undefined, undefined, undefined);

    var observer: Rx.IObserver&lt;number&gt;;
    notification.accept(observer);
    notification.accept((n) =&gt; n.toString(), (e) =&gt; e, () =&gt; false.toString());

    var observable: Rx.Observable&lt;number&gt; = notification.<span class="apidocCodeKeywordSpan">toObservable</span>();
    var observable: Rx.Observable&lt;number&gt; = notification.toObservable(Rx.Scheduler.currentThread);

    Rx.Notification.createOnNext(() =&gt; true);
    Rx.Notification.createOnError(new Error('a'));
    Rx.Notification.createOnCompleted();
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Observable" id="apidoc.module.rx.Observable">module rx.Observable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Observable.Observable" id="apidoc.element.rx.Observable.Observable">
        function <span class="apidocSignatureSpan">rx.</span>Observable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable() {
  if (Rx.config.longStackSupport &amp;&amp; hasStacks) {
    var oldSubscribe = this._subscribe;
    var e = tryCatch(thrower)(new Error()).e;
    this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
    this._subscribe = makeSubscribe(this, oldSubscribe);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.amb" id="apidoc.element.rx.Observable.amb">
        function <span class="apidocSignatureSpan">rx.Observable.</span>amb
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">amb = function () {
  var acc = observableNever(), items;
  if (Array.isArray(arguments[0])) {
    items = arguments[0];
  } else {
    var len = arguments.length;
    items = new Array(items);
    for(var i = 0; i &lt; len; i++) { items[i] = arguments[i]; }
  }
  for (var i = 0, len = items.length; i &lt; len; i++) {
    acc = amb(acc, items[i]);
  }
  return acc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
    rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));

    return new BinaryDisposable(leftSubscription, rightSubscription);
  });
};

function amb(p, c) { return p.<span class="apidocCodeKeywordSpan">amb</span>(c); }

/**
 * Propagates the observable sequence or Promise that reacts first.
 * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
 */
Observable.amb = function () {
  var acc = observableNever(), items;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.case" id="apidoc.element.rx.Observable.case">
        function <span class="apidocSignatureSpan">rx.Observable.</span>case
        <span class="apidocSignatureSpan">(selector, sources, defaultSourceOrScheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">case = function (selector, sources, defaultSourceOrScheduler) {
  return observableDefer(function () {
    isPromise(defaultSourceOrScheduler) &amp;&amp; (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
    defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());

    isScheduler(defaultSourceOrScheduler) &amp;&amp; (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));

    var result = sources[selector()];
    isPromise(result) &amp;&amp; (result = observableFromPromise(result));

    return result || defaultSourceOrScheduler;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.catch" id="apidoc.element.rx.Observable.catch">
        function <span class="apidocSignatureSpan">rx.Observable.</span>catch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function () {
  var items;
  if (Array.isArray(arguments[0])) {
    items = arguments[0];
  } else {
    var len = arguments.length;
    items = new Array(len);
    for(var i = 0; i &lt; len; i++) { items[i] = arguments[i]; }
  }
  return enumerableOf(items).catchError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.combineLatest" id="apidoc.element.rx.Observable.combineLatest">
        function <span class="apidocSignatureSpan">rx.Observable.</span>combineLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineLatest = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
  Array.isArray(args[0]) &amp;&amp; (args = args[0]);
  return new CombineLatestObservable(args, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable
 sequences or Promises produces an element.
 * This can be in the form of an argument list of observables or an array.
 *
 * @example
 * 1 - obs = observable.<span class="apidocCodeKeywordSpan">combineLatest</span>(obs1, obs2, obs3, function (o1, o2, o3) { return
 o1 + o2 + o3; });
 * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
 * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result
 selector function.
 */
observableProto.combineLatest = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  if (Array.isArray(args[0])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.concat" id="apidoc.element.rx.Observable.concat">
        function <span class="apidocSignatureSpan">rx.Observable.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  var args;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    args = new Array(arguments.length);
    for(var i = 0, len = arguments.length; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  return new ConcatObservable(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  var copiedEvent = {};
  for (var prop in e) {
    copiedEvent[prop] = e[prop];
  }

  for (var i = 0, typeListenersCache = [].<span class="apidocCodeKeywordSpan">concat</span>(typeListeners), typeListenerCache, immediatePropagation
 = true; immediatePropagation &amp;&amp; (typeListenerCache = typeListenersCache[i]); ++i) {
    for (var ii = 0, typeListener; typeListener = typeListeners[ii]; ++ii) {
      if (typeListener === typeListenerCache) { typeListener.call(target, copiedEvent); break; }
    }
  }
});

typeListeners.push(listener);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.create" id="apidoc.element.rx.Observable.create">
        function <span class="apidocSignatureSpan">rx.Observable.</span>create
        <span class="apidocSignatureSpan">(subscribe, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (subscribe, parent) {
  return new AnonymousObservable(subscribe, parent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  root.CustomEvent = CustomEvent;
}());

var EmptyError = Rx.EmptyError = function() {
  this.message = 'Sequence contains no elements.';
  Error.call(this);
};
EmptyError.prototype = Object.<span class="apidocCodeKeywordSpan">create</span>(Error.prototype);
EmptyError.prototype.name = 'EmptyError';

var ObjectDisposedError = Rx.ObjectDisposedError = function() {
  this.message = 'Object has been disposed';
  Error.call(this);
};
ObjectDisposedError.prototype = Object.create(Error.prototype);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.defer" id="apidoc.element.rx.Observable.defer">
        function <span class="apidocSignatureSpan">rx.Observable.</span>defer
        <span class="apidocSignatureSpan">(observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function (observableFactory) {
  return new Defer(observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Defer;
}(ObservableBase));

/**
 *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
 *
 * @example
 *  var res = Rx.Observable.<span class="apidocCodeKeywordSpan">defer</span>(function () { return Rx.Observable.fromArray([1,2,3
]); });
 * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting
sequence or Promise.
 * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
 */
var observableDefer = Observable.defer = function (observableFactory) {
  return new Defer(observableFactory);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.empty" id="apidoc.element.rx.Observable.empty">
        function <span class="apidocSignatureSpan">rx.Observable.</span>empty
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (scheduler) {
  isScheduler(scheduler) || (scheduler = immediateScheduler);
  return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Finally, we call the `subscribe` method on our observable sequence to start pulling data.

```js
suggestions.subscribe(
data =&gt; {
  $results
    .<span class="apidocCodeKeywordSpan">empty</span>()
    .append($.map(data[1], value =&gt;  $('&lt;li&gt;').text(value)))
},
error=&gt; {
  $results
    .empty()
    .append($('&lt;li&gt;'))
      .text('Error:' + error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.for" id="apidoc.element.rx.Observable.for">
        function <span class="apidocSignatureSpan">rx.Observable.</span>for
        <span class="apidocSignatureSpan">(sources, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">for = function (sources, resultSelector, thisArg) {
  return enumerableOf(sources, resultSelector, thisArg).concat();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.forIn" id="apidoc.element.rx.Observable.forIn">
        function <span class="apidocSignatureSpan">rx.Observable.</span>forIn
        <span class="apidocSignatureSpan">(sources, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forIn = function (sources, resultSelector, thisArg) {
  return enumerableOf(sources, resultSelector, thisArg).concat();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.forkJoin" id="apidoc.element.rx.Observable.forkJoin">
        function <span class="apidocSignatureSpan">rx.Observable.</span>forkJoin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forkJoin = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
  Array.isArray(args[0]) &amp;&amp; (args = args[0]);
  return new ForkJoinObservable(args, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return ForkJoinObserver;
}(AbstractObserver));

 /**
 *  Runs all observable sequences in parallel and collect their last elements.
 *
 * @example
 *  1 - res = Rx.Observable.<span class="apidocCodeKeywordSpan">forkJoin</span>([obs1, obs2]);
 *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
 * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
 */
Observable.forkJoin = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.from" id="apidoc.element.rx.Observable.from">
        function <span class="apidocSignatureSpan">rx.Observable.</span>from
        <span class="apidocSignatureSpan">(iterable, mapFn, thisArg, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, mapFn, thisArg, scheduler) {
  if (iterable == null) {
    throw new Error('iterable cannot be null.')
  }
  if (mapFn &amp;&amp; !isFunction(mapFn)) {
    throw new Error('mapFn when provided must be a function');
  }
  if (mapFn) {
    var mapper = bindCallback(mapFn, thisArg, 2);
  }
  isScheduler(scheduler) || (scheduler = currentThreadScheduler);
  return new FromObservable(iterable, mapper, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

InnerObserver.prototype.next = function(x) {
  var i = this.i++;
  var result = tryCatch(this.selector)(x, i, this.source);
  if (result === errorObj) { return this.o.onError(result.e); }

  isPromise(result) &amp;&amp; (result = observableFromPromise(result));
  (isArrayLike(result) || isIterable(result)) &amp;&amp; (result = Observable.<span class="apidocCodeKeywordSpan">from</span>(
result));
  this.o.onNext(this._wrapResult(result, x, i));
};

InnerObserver.prototype.error = function(e) { this.o.onError(e); };

InnerObserver.prototype.completed = function() { this.o.onCompleted(); };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.fromArray" id="apidoc.element.rx.Observable.fromArray">
        function <span class="apidocSignatureSpan">rx.Observable.</span>fromArray
        <span class="apidocSignatureSpan">(array, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (array, scheduler) {
  isScheduler(scheduler) || (scheduler = currentThreadScheduler);
  return new FromArrayObservable(array, scheduler)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Defer;
}(ObservableBase));

/**
 *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
 *
 * @example
 *  var res = Rx.Observable.defer(function () { return Rx.Observable.<span class="apidocCodeKeywordSpan">fromArray</span>([1,2,3
]); });
 * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting
sequence or Promise.
 * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
 */
var observableDefer = Observable.defer = function (observableFactory) {
  return new Defer(observableFactory);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.fromCallback" id="apidoc.element.rx.Observable.fromCallback">
        function <span class="apidocSignatureSpan">rx.Observable.</span>fromCallback
        <span class="apidocSignatureSpan">(fn, ctx, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromCallback = function (fn, ctx, selector) {
  return function () {
    typeof ctx === 'undefined' &amp;&amp; (ctx = this);

    var len = arguments.length, args = new Array(len)
    for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
    return createCbObservable(fn, ctx, selector, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.fromEvent" id="apidoc.element.rx.Observable.fromEvent">
        function <span class="apidocSignatureSpan">rx.Observable.</span>fromEvent
        <span class="apidocSignatureSpan">(element, eventName, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEvent = function (element, eventName, selector) {
  // Node.js specific
  if (element.addListener) {
    return fromEventPattern(
      function (h) { element.addListener(eventName, h); },
      function (h) { element.removeListener(eventName, h); },
      selector);
  }

  // Use only if non-native events are allowed
  if (!Rx.config.useNativeEvents) {
    // Handles jq, Angular.js, Zepto, Marionette, Ember.js
    if (typeof element.on === 'function' &amp;&amp; typeof element.off === 'function') {
      return fromEventPattern(
        function (h) { element.on(eventName, h); },
        function (h) { element.off(eventName, h); },
        selector);
    }
  }

  return new EventObservable(element, eventName, selector).publish().refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Next, we'll get the user input from an input, listening to the keyup event by using the `Rx.Observable.fromEvent` method.
This will either use the event binding from [jQuery](http://jquery.com), [Zepto](http://zeptojs.com/), [AngularJS](https://angularjs
.org/), [Backbone.js](http://backbonejs.org/) and [Ember.js](http://emberjs.com/) if available, and if not, falls back to the native
 event binding.  This gives you consistent ways of thinking of events depending on your framework, so there are no surprises.

```js
const $input = $('#input');
const $results = $('#results');

/* Only get the value from each key up */
var keyups = Rx.Observable.<span class="apidocCodeKeywordSpan">fromEvent</span>($input, 'keyup')
.pluck('target', 'value')
.filter(text =&gt; text.length &gt; 2 );

/* Now debounce the input for 500ms */
var debounced = keyups
.debounce(500 /* ms */);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.fromEventPattern" id="apidoc.element.rx.Observable.fromEventPattern">
        function <span class="apidocSignatureSpan">rx.Observable.</span>fromEventPattern
        <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEventPattern = function (addHandler, removeHandler, selector) {
  return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.fromNodeCallback" id="apidoc.element.rx.Observable.fromNodeCallback">
        function <span class="apidocSignatureSpan">rx.Observable.</span>fromNodeCallback
        <span class="apidocSignatureSpan">(fn, ctx, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromNodeCallback = function (fn, ctx, selector) {
  return function () {
    typeof ctx === 'undefined' &amp;&amp; (ctx = this);
    var len = arguments.length, args = new Array(len);
    for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
    return createNodeObservable(fn, ctx, selector, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.fromPromise" id="apidoc.element.rx.Observable.fromPromise">
        function <span class="apidocSignatureSpan">rx.Observable.</span>fromPromise
        <span class="apidocSignatureSpan">(promise, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise, scheduler) {
  scheduler || (scheduler = defaultScheduler);
  return new FromPromiseObservable(promise, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return g;
  });
};

function toObservable(obj) {
  if (!obj) { return obj; }
  if (Observable.isObservable(obj)) { return obj; }
  if (isPromise(obj)) { return Observable.<span class="apidocCodeKeywordSpan">fromPromise</span>(obj); }
  if (isGeneratorFunction(obj) || isGenerator(obj)) { return spawn.call(this, obj); }
  if (isFunction(obj)) { return thunkToObservable.call(this, obj); }
  if (isArrayLike(obj) || isIterable(obj)) { return arrayToObservable.call(this, obj); }
  if (isObject(obj)) {return objectToObservable.call(this, obj);}
  return obj;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.generate" id="apidoc.element.rx.Observable.generate">
        function <span class="apidocSignatureSpan">rx.Observable.</span>generate
        <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (initialState, condition, iterate, resultSelector, scheduler) {
  isScheduler(scheduler) || (scheduler = currentThreadScheduler);
  return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return GenerateObservable;
}(ObservableBase));

/**
 *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified
scheduler to send out observer messages.
 *
 * @example
 *  var res = Rx.Observable.<span class="apidocCodeKeywordSpan">generate</span>(0, function (x) { return x &lt; 10; }, function
 (x) { return x + 1; }, function (x) { return x; });
 *  var res = Rx.Observable.generate(0, function (x) { return x &lt; 10; }, function (x) { return x + 1; }, function (x) { return
 x; }, Rx.Scheduler.timeout);
 * @param {Mixed} initialState Initial state.
 * @param {Function} condition Condition to terminate generation (upon returning false).
 * @param {Function} iterate Iteration step function.
 * @param {Function} resultSelector Selector function for results produced in the sequence.
 * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread
.
 * @returns {Observable} The generated sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.generateWithAbsoluteTime" id="apidoc.element.rx.Observable.generateWithAbsoluteTime">
        function <span class="apidocSignatureSpan">rx.Observable.</span>generateWithAbsoluteTime
        <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, timeSelector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return GenerateAbsoluteObservable;
}(ObservableBase));

/**
 *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.
 *
 * @example
 *  res = source.<span class="apidocCodeKeywordSpan">generateWithAbsoluteTime</span>(0,
 *      function (x) { return return true; },
 *      function (x) { return x + 1; },
 *      function (x) { return x; },
 *      function (x) { return new Date(); }
 *  });
 *
 * @param {Mixed} initialState Initial state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.generateWithRelativeTime" id="apidoc.element.rx.Observable.generateWithRelativeTime">
        function <span class="apidocSignatureSpan">rx.Observable.</span>generateWithRelativeTime
        <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, timeSelector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return GenerateRelativeObservable;
}(ObservableBase));

/**
 *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
 *
 * @example
 *  res = source.<span class="apidocCodeKeywordSpan">generateWithRelativeTime</span>(0,
 *      function (x) { return return true; },
 *      function (x) { return x + 1; },
 *      function (x) { return x; },
 *      function (x) { return 500; }
 *  );
 *
 * @param {Mixed} initialState Initial state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.if" id="apidoc.element.rx.Observable.if">
        function <span class="apidocSignatureSpan">rx.Observable.</span>if
        <span class="apidocSignatureSpan">(condition, thenSource, elseSourceOrScheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">if = function (condition, thenSource, elseSourceOrScheduler) {
  return observableDefer(function () {
    elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());

    isPromise(thenSource) &amp;&amp; (thenSource = observableFromPromise(thenSource));
    isPromise(elseSourceOrScheduler) &amp;&amp; (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));

    // Assume a scheduler for empty only
    typeof elseSourceOrScheduler.now === 'function' &amp;&amp; (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
    return condition() ? thenSource : elseSourceOrScheduler;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 return func(this);
  };

/**
*  Determines whether an observable collection contains values.
*
* @example
*  1 - res = Rx.Observable.<span class="apidocCodeKeywordSpan">if</span>(condition, obs1);
*  2 - res = Rx.Observable.if(condition, obs1, obs2);
*  3 - res = Rx.Observable.if(condition, obs1, scheduler);
* @param {Function} condition The condition which determines if the thenSource or elseSource will be run.
* @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.
* @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false.
If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
* @returns {Observable} An observable sequence which is either the thenSource or elseSource.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.interval" id="apidoc.element.rx.Observable.interval">
        function <span class="apidocSignatureSpan">rx.Observable.</span>interval
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (period, scheduler) {
  return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}(Observable));

/**
 * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
 * @example
 * var pauser = new Rx.Subject();
 * var source = Rx.Observable.<span class="apidocCodeKeywordSpan">interval</span>(100).pausable(pauser);
 * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
 * @returns {Observable} The observable sequence which is paused based upon the pauser.
 */
observableProto.pausable = function (pauser) {
  return new PausableObservable(this, pauser);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.isObservable" id="apidoc.element.rx.Observable.isObservable">
        function <span class="apidocSignatureSpan">rx.Observable.</span>isObservable
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObservable = function (o) {
  return o &amp;&amp; isFunction(o.subscribe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  o.onNext(ret.value);
  o.onCompleted();
  return;
}
var obs = toObservable.call(self, ret.value);
var value = null;
var hasValue = false;
if (Observable.<span class="apidocCodeKeywordSpan">isObservable</span>(obs)) {
  g.add(obs.subscribe(function(val) {
    hasValue = true;
    value = val;
  }, onError, function() {
    hasValue &amp;&amp; processGenerator(value);
  }));
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.just" id="apidoc.element.rx.Observable.just">
        function <span class="apidocSignatureSpan">rx.Observable.</span>just
        <span class="apidocSignatureSpan">(value, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">just = function (value, scheduler) {
  isScheduler(scheduler) || (scheduler = immediateScheduler);
  return new JustObservable(value, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function arrayToObservable (obj) {
  return Observable.from(obj).concatMap(function(o) {
    if(Observable.isObservable(o) || isObject(o)) {
      return toObservable.call(null, o);
    } else {
      return Rx.Observable.<span class="apidocCodeKeywordSpan">just</span>(o);
    }
  }).toArray();
}

function objectToObservable (obj) {
  var results = new obj.constructor(), keys = Object.keys(obj), observables = [];
  for (var i = 0, len = keys.length; i &lt; len; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.merge" id="apidoc.element.rx.Observable.merge">
        function <span class="apidocSignatureSpan">rx.Observable.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  var scheduler, sources = [], i, len = arguments.length;
  if (!arguments[0]) {
    scheduler = immediateScheduler;
    for(i = 1; i &lt; len; i++) { sources.push(arguments[i]); }
  } else if (isScheduler(arguments[0])) {
    scheduler = arguments[0];
    for(i = 1; i &lt; len; i++) { sources.push(arguments[i]); }
  } else {
    scheduler = immediateScheduler;
    for(i = 0; i &lt; len; i++) { sources.push(arguments[i]); }
  }
  if (Array.isArray(sources[0])) {
    sources = sources[0];
  }
  return observableOf(scheduler, sources).mergeAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  /**
   * Concatenates an observable sequence of observable sequences.
   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order
.
   */
  observableProto.concatAll = function () {
return this.<span class="apidocCodeKeywordSpan">merge</span>(1);
  };

  var MergeObservable = (function (__super__) {
inherits(MergeObservable, __super__);

function MergeObservable(source, maxConcurrent) {
  this.source = source;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.mergeDelayError" id="apidoc.element.rx.Observable.mergeDelayError">
        function <span class="apidocSignatureSpan">rx.Observable.</span>mergeDelayError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDelayError = function () {
  var args;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    var len = arguments.length;
    args = new Array(len);
    for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  var source = observableOf(null, args);
  return new MergeDelayErrorObservable(source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.never" id="apidoc.element.rx.Observable.never">
        function <span class="apidocSignatureSpan">rx.Observable.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">never = function () {
  return NEVER_OBSERVABLE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    /**
*  Groups the elements of an observable sequence according to a specified key selector function.
*  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification
. When a new element with the same
*  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
*
* @example
*  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.<span class="apidocCodeKeywordSpan
">never</span>(); });
*  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never
(); });
*  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never
(); }, function (x) { return x.toString(); });
* @param {Function} keySelector A function to extract the key for each element.
* @param {Function} durationSelector A function to signal the expiration of a group.
* @returns {Observable}
*  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same
 key value.
*  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value
is encoutered.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.of" id="apidoc.element.rx.Observable.of">
        function <span class="apidocSignatureSpan">rx.Observable.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  return new FromArrayObservable(args, currentThreadScheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
require({
  'paths': {
    'rx': 'path/to/rx-lite.js'
  }
},
['rx'], (Rx) =&gt; {
  const obs = Rx.Observable.<span class="apidocCodeKeywordSpan">of</span>(42);
  obs.forEach(x =&gt; console.log(x));
});
```

## What about my libraries? ##

The Reactive Extensions for JavaScript have no external dependencies on any library, so they'll work well with just about any
 library.  We provide bridges and support for various libraries including:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.ofWithScheduler" id="apidoc.element.rx.Observable.ofWithScheduler">
        function <span class="apidocSignatureSpan">rx.Observable.</span>ofWithScheduler
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ofWithScheduler = function (scheduler) {
  var len = arguments.length, args = new Array(len - 1);
  for(var i = 1; i &lt; len; i++) { args[i - 1] = arguments[i]; }
  return new FromArrayObservable(args, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.onErrorResumeNext" id="apidoc.element.rx.Observable.onErrorResumeNext">
        function <span class="apidocSignatureSpan">rx.Observable.</span>onErrorResumeNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorResumeNext = function () {
  var sources = [];
  if (Array.isArray(arguments[0])) {
    sources = arguments[0];
  } else {
    var len = arguments.length;
    sources = new Array(len);
    for(var i = 0; i &lt; len; i++) { sources[i] = arguments[i]; }
  }
  return new OnErrorResumeNextObservable(sources);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

export interface ObservableStatic {
    /**
    * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
    *
    * @example
    * 1 - res = Rx.Observable.<span class="apidocCodeKeywordSpan">onErrorResumeNext</span>(xs, ys, zs);
    * 1 - res = Rx.Observable.onErrorResumeNext([xs, ys, zs]);
    * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally
.
    */
    onErrorResumeNext&lt;T&gt;(...sources: ObservableOrPromise&lt;T&gt;[]): Observable&lt;T&gt;;
    /**
    * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
    *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.pairs" id="apidoc.element.rx.Observable.pairs">
        function <span class="apidocSignatureSpan">rx.Observable.</span>pairs
        <span class="apidocSignatureSpan">(obj, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pairs = function (obj, scheduler) {
  scheduler || (scheduler = currentThreadScheduler);
  return new PairsObservable(obj, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.range" id="apidoc.element.rx.Observable.range">
        function <span class="apidocSignatureSpan">rx.Observable.</span>range
        <span class="apidocSignatureSpan">(start, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, count, scheduler) {
  isScheduler(scheduler) || (scheduler = currentThreadScheduler);
  return new RangeObservable(start, count, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 *  One of the Following:
 *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into
 one observable sequence.
 *
 * @example
 *  var res = source.concatMap(function (x) { return Rx.Observable.<span class="apidocCodeKeywordSpan">range</span>(0, x); });
 *  Or:
 *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element
 and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
 *
 *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
 *  Or:
 *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable
 sequences into one observable sequence.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.repeat" id="apidoc.element.rx.Observable.repeat">
        function <span class="apidocSignatureSpan">rx.Observable.</span>repeat
        <span class="apidocSignatureSpan">(value, repeatCount, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (value, repeatCount, scheduler) {
  isScheduler(scheduler) || (scheduler = currentThreadScheduler);
  return new RepeatObservable(value, repeatCount, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count
 is not specified, it retries indefinitely.
 *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
 *
 * @example
 *  var res = retried = retry.<span class="apidocCodeKeywordSpan">repeat</span>();
 *  var res = retried = retry.repeat(2);
 * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
 * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully
.
 */
observableProto.retry = function (retryCount) {
  return enumerableRepeat(this, retryCount).catchError();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.return" id="apidoc.element.rx.Observable.return">
        function <span class="apidocSignatureSpan">rx.Observable.</span>return
        <span class="apidocSignatureSpan">(value, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">return = function (value, scheduler) {
  isScheduler(scheduler) || (scheduler = immediateScheduler);
  return new JustObservable(value, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  scheduler || (scheduler = defaultScheduler);
  return new FromPromiseObservable(promise, scheduler);
};

/*
 * Converts an existing observable sequence to an ES6 Compatible Promise
 * @example
 * var promise = Rx.Observable.<span class="apidocCodeKeywordSpan">return</span>(42).toPromise(RSVP.Promise);
 *
 * // With config
 * Rx.config.Promise = RSVP.Promise;
 * var promise = Rx.Observable.return(42).toPromise();
 * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
 * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.spawn" id="apidoc.element.rx.Observable.spawn">
        function <span class="apidocSignatureSpan">rx.Observable.</span>spawn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spawn = function () {
  var gen = arguments[0], self = this, args = [];
  for (var i = 1, len = arguments.length; i &lt; len; i++) { args.push(arguments[i]); }

  return new AnonymousObservable(function (o) {
    var g = new CompositeDisposable();

    if (isFunction(gen)) { gen = gen.apply(self, args); }
    if (!gen || !isFunction(gen.next)) {
      o.onNext(gen);
      return o.onCompleted();
    }

    function processGenerator(res) {
      var ret = tryCatch(gen.next).call(gen, res);
      if (ret === errorObj) { return o.onError(ret.e); }
      next(ret);
    }

    processGenerator();

    function onError(err) {
      var ret = tryCatch(gen.next).call(gen, err);
      if (ret === errorObj) { return o.onError(ret.e); }
      next(ret);
    }

    function next(ret) {
      if (ret.done) {
        o.onNext(ret.value);
        o.onCompleted();
        return;
      }
      var obs = toObservable.call(self, ret.value);
      var value = null;
      var hasValue = false;
      if (Observable.isObservable(obs)) {
        g.add(obs.subscribe(function(val) {
          hasValue = true;
          value = val;
        }, onError, function() {
          hasValue &amp;&amp; processGenerator(value);
        }));
      } else {
        onError(new TypeError('type not supported'));
      }
    }

    return g;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.start" id="apidoc.element.rx.Observable.start">
        function <span class="apidocSignatureSpan">rx.Observable.</span>start
        <span class="apidocSignatureSpan">(func, context, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (func, context, scheduler) {
  return observableToAsync(func, context, scheduler)();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Object == val.constructor;
}

/**
 * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence
.
 *
 * @example
 * var res = Rx.Observable.<span class="apidocCodeKeywordSpan">start</span>(function () { console.log('hello'); });
 * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
 * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
 *
 * @param {Function} func Function to run asynchronously.
 * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
 * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
 * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.startAsync" id="apidoc.element.rx.Observable.startAsync">
        function <span class="apidocSignatureSpan">rx.Observable.</span>startAsync
        <span class="apidocSignatureSpan">(functionAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startAsync = function (functionAsync) {
  var promise = tryCatch(functionAsync)();
  if (promise === errorObj) { return observableThrow(promise.e); }
  return observableFromPromise(promise);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.throw" id="apidoc.element.rx.Observable.throw">
        function <span class="apidocSignatureSpan">rx.Observable.</span>throw
        <span class="apidocSignatureSpan">(error, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throw = function (error, scheduler) {
  isScheduler(scheduler) || (scheduler = immediateScheduler);
  return new ThrowObservable(error, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.timer" id="apidoc.element.rx.Observable.timer">
        function <span class="apidocSignatureSpan">rx.Observable.</span>timer
        <span class="apidocSignatureSpan">(dueTime, periodOrScheduler, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timer = function (dueTime, periodOrScheduler, scheduler) {
  var period;
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  if (periodOrScheduler != null &amp;&amp; typeof periodOrScheduler === 'number') {
    period = periodOrScheduler;
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if ((dueTime instanceof Date || typeof dueTime === 'number') &amp;&amp; period === undefined) {
    return _observableTimer(dueTime, scheduler);
  }
  if (dueTime instanceof Date &amp;&amp; period !== undefined) {
    return observableTimerDateAndPeriod(dueTime, periodOrScheduler, scheduler);
  }
  return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

export interface Observable&lt;T&gt; {
    /**
     *  Repeats the source observable sequence upon error each time the notifier emits or until it successfully terminates.
     *  if the notifier completes, the observable sequence completes.
     *
     * @example
     *  var timer = Observable.<span class="apidocCodeKeywordSpan">timer</span>(500);
     *  var source = observable.retryWhen(timer);
     * @param {Observable} [notifier] An observable that triggers the retries or completes the observable with onNext or onCompleted
 respectively.
     * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates
successfully.
     */
    retryWhen(notifier: (errors: Observable&lt;any&gt;) =&gt; Observable&lt;any&gt;): Observable&lt;T&gt;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.toAsync" id="apidoc.element.rx.Observable.toAsync">
        function <span class="apidocSignatureSpan">rx.Observable.</span>toAsync
        <span class="apidocSignatureSpan">(func, context, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAsync = function (func, context, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return function () {
    var args = arguments,
      subject = new AsyncSubject();

    scheduler.schedule(null, function () {
      var result;
      try {
        result = func.apply(context, args);
      } catch (e) {
        subject.onError(e);
        return;
      }
      subject.onNext(result);
      subject.onCompleted();
    });
    return subject.asObservable();
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.using" id="apidoc.element.rx.Observable.using">
        function <span class="apidocSignatureSpan">rx.Observable.</span>using
        <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">using = function (resourceFactory, observableFactory) {
  return new UsingObservable(resourceFactory, observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.when" id="apidoc.element.rx.Observable.when">
        function <span class="apidocSignatureSpan">rx.Observable.</span>when
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function () {
  var len = arguments.length, plans;
  if (Array.isArray(arguments[0])) {
    plans = arguments[0];
  } else {
    plans = new Array(len);
    for(var i = 0; i &lt; len; i++) { plans[i] = arguments[i]; }
  }
  return new AnonymousObservable(function (o) {
    var activePlans = [],
        externalSubscriptions = new Map();
    var outObserver = observerCreate(
      function (x) { o.onNext(x); },
      function (err) {
        externalSubscriptions.forEach(function (v) { v.onError(err); });
        o.onError(err);
      },
      function (x) { o.onCompleted(); }
    );
    try {
      for (var i = 0, len = plans.length; i &lt; len; i++) {
        activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {
          var idx = activePlans.indexOf(activePlan);
          activePlans.splice(idx, 1);
          activePlans.length === 0 &amp;&amp; o.onCompleted();
        }));
      }
    } catch (e) {
      return observableThrow(e).subscribe(o);
    }
    var group = new CompositeDisposable();
    externalSubscriptions.forEach(function (joinObserver) {
      joinObserver.subscribe();
      group.add(joinObserver);
    });

    return group;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.while" id="apidoc.element.rx.Observable.while">
        function <span class="apidocSignatureSpan">rx.Observable.</span>while
        <span class="apidocSignatureSpan">(condition, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">while = function (condition, source) {
  isPromise(source) &amp;&amp; (source = observableFromPromise(source));
  return enumerableWhile(condition, source).concat();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.whileDo" id="apidoc.element.rx.Observable.whileDo">
        function <span class="apidocSignatureSpan">rx.Observable.</span>whileDo
        <span class="apidocSignatureSpan">(condition, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whileDo = function (condition, source) {
  isPromise(source) &amp;&amp; (source = observableFromPromise(source));
  return enumerableWhile(condition, source).concat();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.wrap" id="apidoc.element.rx.Observable.wrap">
        function <span class="apidocSignatureSpan">rx.Observable.</span>wrap
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (fn) {
  function createObservable() {
    return Observable.spawn.call(this, fn.apply(this, arguments));
  }

  createObservable.__generatorFunction__ = fn;
  return createObservable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.zip" id="apidoc.element.rx.Observable.zip">
        function <span class="apidocSignatureSpan">rx.Observable.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  if (Array.isArray(args[0])) {
    args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];
  }
  var first = args.shift();
  return first.zip.apply(first, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Observable.prototype" id="apidoc.module.rx.Observable.prototype">module rx.Observable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.amb" id="apidoc.element.rx.Observable.prototype.amb">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>amb
        <span class="apidocSignatureSpan">(rightSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">amb = function (rightSource) {
  var leftSource = this;
  return new AnonymousObservable(function (observer) {
    var choice,
      leftChoice = 'L', rightChoice = 'R',
      leftSubscription = new SingleAssignmentDisposable(),
      rightSubscription = new SingleAssignmentDisposable();

    isPromise(rightSource) &amp;&amp; (rightSource = observableFromPromise(rightSource));

    function choiceL() {
      if (!choice) {
        choice = leftChoice;
        rightSubscription.dispose();
      }
    }

    function choiceR() {
      if (!choice) {
        choice = rightChoice;
        leftSubscription.dispose();
      }
    }

    var leftSubscribe = observerCreate(
      function (left) {
        choiceL();
        choice === leftChoice &amp;&amp; observer.onNext(left);
      },
      function (e) {
        choiceL();
        choice === leftChoice &amp;&amp; observer.onError(e);
      },
      function () {
        choiceL();
        choice === leftChoice &amp;&amp; observer.onCompleted();
      }
    );
    var rightSubscribe = observerCreate(
      function (right) {
        choiceR();
        choice === rightChoice &amp;&amp; observer.onNext(right);
      },
      function (e) {
        choiceR();
        choice === rightChoice &amp;&amp; observer.onError(e);
      },
      function () {
        choiceR();
        choice === rightChoice &amp;&amp; observer.onCompleted();
      }
    );

    leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
    rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));

    return new BinaryDisposable(leftSubscription, rightSubscription);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
    rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));

    return new BinaryDisposable(leftSubscription, rightSubscription);
  });
};

function amb(p, c) { return p.<span class="apidocCodeKeywordSpan">amb</span>(c); }

/**
 * Propagates the observable sequence or Promise that reacts first.
 * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
 */
Observable.amb = function () {
  var acc = observableNever(), items;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.and" id="apidoc.element.rx.Observable.prototype.and">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>and
        <span class="apidocSignatureSpan">(right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function (right) {
  return new Pattern([this, right]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.asObservable" id="apidoc.element.rx.Observable.prototype.asObservable">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>asObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObservable = function () {
  return new AnonymousObservable(asObservable(this), this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      } catch (e) {
        subject.onError(e);
        return;
      }
      subject.onNext(result);
      subject.onCompleted();
    });
    return subject.<span class="apidocCodeKeywordSpan">asObservable</span>();
  };
};

function createCbObservable(fn, ctx, selector, args) {
var o = new AsyncSubject();

args.push(createCbHandler(o, ctx, selector));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.average" id="apidoc.element.rx.Observable.prototype.average">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>average
        <span class="apidocSignatureSpan">(keySelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">average = function (keySelector, thisArg) {
  var source = this, fn;
  if (isFunction(keySelector)) {
    fn = bindCallback(keySelector, thisArg, 3);
  }
  return new AverageObservable(source, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.buffer" id="apidoc.element.rx.Observable.prototype.buffer">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>buffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer = function () {
  return this.window.apply(this, arguments)
    .flatMap(toArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.bufferCount" id="apidoc.element.rx.Observable.prototype.bufferCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferCount
        <span class="apidocSignatureSpan">(count, skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferCount = function (count, skip) {
  typeof skip !== 'number' &amp;&amp; (skip = count);
  return this.windowWithCount(count, skip)
    .flatMap(toArray)
    .filter(notEmpty);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.bufferTime" id="apidoc.element.rx.Observable.prototype.bufferTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferTime
        <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
  return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.bufferTimeOrCount" id="apidoc.element.rx.Observable.prototype.bufferTimeOrCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferTimeOrCount
        <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferTimeOrCount = function (timeSpan, count, scheduler) {
  return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.bufferWithCount" id="apidoc.element.rx.Observable.prototype.bufferWithCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferWithCount
        <span class="apidocSignatureSpan">(count, skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferWithCount = function (count, skip) {
  typeof skip !== 'number' &amp;&amp; (skip = count);
  return this.windowWithCount(count, skip)
    .flatMap(toArray)
    .filter(notEmpty);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.bufferWithTime" id="apidoc.element.rx.Observable.prototype.bufferWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferWithTime
        <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
  return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.bufferWithTimeOrCount" id="apidoc.element.rx.Observable.prototype.bufferWithTimeOrCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>bufferWithTimeOrCount
        <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferWithTimeOrCount = function (timeSpan, count, scheduler) {
  return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.catch" id="apidoc.element.rx.Observable.prototype.catch">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>catch
        <span class="apidocSignatureSpan">(handlerOrSecond)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (handlerOrSecond) {
  return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.combineLatest" id="apidoc.element.rx.Observable.prototype.combineLatest">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>combineLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineLatest = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  if (Array.isArray(args[0])) {
    args[0].unshift(this);
  } else {
    args.unshift(this);
  }
  return combineLatest.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable
 sequences or Promises produces an element.
 * This can be in the form of an argument list of observables or an array.
 *
 * @example
 * 1 - obs = observable.<span class="apidocCodeKeywordSpan">combineLatest</span>(obs1, obs2, obs3, function (o1, o2, o3) { return
 o1 + o2 + o3; });
 * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
 * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result
 selector function.
 */
observableProto.combineLatest = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  if (Array.isArray(args[0])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.concat" id="apidoc.element.rx.Observable.prototype.concat">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  for(var args = [], i = 0, len = arguments.length; i &lt; len; i++) { args.push(arguments[i]); }
  args.unshift(this);
  return observableConcat.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  var copiedEvent = {};
  for (var prop in e) {
    copiedEvent[prop] = e[prop];
  }

  for (var i = 0, typeListenersCache = [].<span class="apidocCodeKeywordSpan">concat</span>(typeListeners), typeListenerCache, immediatePropagation
 = true; immediatePropagation &amp;&amp; (typeListenerCache = typeListenersCache[i]); ++i) {
    for (var ii = 0, typeListener; typeListener = typeListeners[ii]; ++ii) {
      if (typeListener === typeListenerCache) { typeListener.call(target, copiedEvent); break; }
    }
  }
});

typeListeners.push(listener);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.concatAll" id="apidoc.element.rx.Observable.prototype.concatAll">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concatAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatAll = function () {
  return this.merge(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
  }, this).<span class="apidocCodeKeywordSpan">concatAll</span>();
};

var DefaultIfEmptyObserver = (function (__super__) {
  inherits(DefaultIfEmptyObserver, __super__);
  function DefaultIfEmptyObserver(o, d) {
    this._o = o;
    this._d = d;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.concatMap" id="apidoc.element.rx.Observable.prototype.concatMap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concatMap
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (isFunction(obj)) { return thunkToObservable.call(this, obj); }
  if (isArrayLike(obj) || isIterable(obj)) { return arrayToObservable.call(this, obj); }
  if (isObject(obj)) {return objectToObservable.call(this, obj);}
  return obj;
}

function arrayToObservable (obj) {
  return Observable.from(obj).<span class="apidocCodeKeywordSpan">concatMap</span>(function(o) {
    if(Observable.isObservable(o) || isObject(o)) {
      return toObservable.call(null, o);
    } else {
      return Rx.Observable.just(o);
    }
  }).toArray();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.concatMapObserver" id="apidoc.element.rx.Observable.prototype.concatMapObserver">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>concatMapObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatMapObserver = function (onNext, onError, onCompleted, thisArg) {
  var source = this,
      onNextFunc = bindCallback(onNext, thisArg, 2),
      onErrorFunc = bindCallback(onError, thisArg, 1),
      onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
  return new AnonymousObservable(function (observer) {
    var index = 0;
    return source.subscribe(
      function (x) {
        var result;
        try {
          result = onNextFunc(x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
      },
      function (err) {
        var result;
        try {
          result = onErrorFunc(err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      },
      function () {
        var result;
        try {
          result = onCompletedFunc();
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
  }, this).concatAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.controlled" id="apidoc.element.rx.Observable.prototype.controlled">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>controlled
        <span class="apidocSignatureSpan">(enableQueue, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">controlled = function (enableQueue, scheduler) {

  if (enableQueue &amp;&amp; isScheduler(enableQueue)) {
    scheduler = enableQueue;
    enableQueue = true;
  }

  if (enableQueue == null) {  enableQueue = true; }
  return new ControlledObservable(this, enableQueue, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return ControlledSubject;
}(Observable));

/**
 * Attaches a controller to the observable sequence with the ability to queue.
 * @example
 * var source = Rx.Observable.interval(100).<span class="apidocCodeKeywordSpan">controlled</span>();
 * source.request(3); // Reads 3 values
 * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request
 * @param {Scheduler} scheduler determines how the requests will be scheduled
 * @returns {Observable} The observable sequence which only propagates values on request.
 */
observableProto.controlled = function (enableQueue, scheduler) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.count" id="apidoc.element.rx.Observable.prototype.count">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>count
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
  return new CountObservable(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return CountObserver;
}(AbstractObserver));

/**
 * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy
 a condition if provided, else the count of items.
 * @example
 * res = source.<span class="apidocCodeKeywordSpan">count</span>();
 * res = source.count(function (x) { return x &gt; 3; });
 * @param {Function} [predicate]A function to test each element for a condition.
 * @param {Any} [thisArg] Object to use as this when executing callback.
 * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the
 input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.
 */
observableProto.count = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.debounce" id="apidoc.element.rx.Observable.prototype.debounce">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>debounce
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debounce = function () {
  if (isFunction (arguments[0])) {
    return debounceWithSelector(this, arguments[0]);
  } else if (typeof arguments[0] === 'number') {
    return new DebounceObservable(this, arguments[0], arguments[1]);
  } else {
    throw new Error('Invalid arguments');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/* Only get the value from each key up */
var keyups = Rx.Observable.fromEvent($input, 'keyup')
  .pluck('target', 'value')
  .filter(text =&gt; text.length &gt; 2 );

/* Now debounce the input for 500ms */
var debounced = keyups
  .<span class="apidocCodeKeywordSpan">debounce</span>(500 /* ms */);

/* Now get only distinct values, so we eliminate the arrows and other control characters */
var distinct = debounced
  .distinctUntilChanged();
```

Now, let's query Wikipedia!  In RxJS, we can instantly bind to any [Promises A+](https://github.com/promises-aplus/promises
-spec) implementation through the `Rx.Observable.fromPromise` method. Or, directly return it and RxJS will wrap it for you.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.defaultIfEmpty" id="apidoc.element.rx.Observable.prototype.defaultIfEmpty">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>defaultIfEmpty
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultIfEmpty = function (defaultValue) {
  var source = this;
  defaultValue === undefined &amp;&amp; (defaultValue = null);
  return new AnonymousObservable(function (o) {
    return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return DefaultIfEmptyObserver;
}(AbstractObserver));

/**
 *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
 *
 *  var res = obs = xs.<span class="apidocCodeKeywordSpan">defaultIfEmpty</span>();
 *  2 - obs = xs.defaultIfEmpty(false);
 *
 * @memberOf Observable#
 * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
 * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the
 elements of the source itself.
 */
  observableProto.defaultIfEmpty = function (defaultValue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.delay" id="apidoc.element.rx.Observable.prototype.delay">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>delay
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function () {
  var firstArg = arguments[0];
  if (typeof firstArg === 'number' || firstArg instanceof Date) {
    var dueTime = firstArg, scheduler = arguments[1];
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return dueTime instanceof Date ?
      observableDelayAbsolute(this, dueTime, scheduler) :
      observableDelayRelative(this, dueTime, scheduler);
  } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
    return delayWithSelector(this, firstArg, arguments[1]);
  } else {
    throw new Error('Invalid arguments');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

export interface Observable&lt;T&gt; {
    /**
    *  Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.
    *
    * @example
    *  1 - res = Rx.Observable.<span class="apidocCodeKeywordSpan">delay</span>(new Date());
    *  2 - res = Rx.Observable.delay(new Date(), Rx.Scheduler.timeout);
    *
    *  3 - res = Rx.Observable.delay(5000);
    *  4 - res = Rx.Observable.delay(5000, 1000, Rx.Scheduler.timeout);
    * @memberOf Observable#
    * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds
) by which to shift the observable sequence.
    * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.delaySubscription" id="apidoc.element.rx.Observable.prototype.delaySubscription">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>delaySubscription
        <span class="apidocSignatureSpan">(dueTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delaySubscription = function (dueTime, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new DelaySubscription(this, dueTime, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return DelaySubscription;
}(ObservableBase));

/**
 *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified
 scheduler to run timers.
 *
 * @example
 *  1 - res = source.<span class="apidocCodeKeywordSpan">delaySubscription</span>(5000); // 5s
 *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds
 *
 * @param {Number} dueTime Relative or absolute time shift of the subscription.
 * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is
used.
 * @returns {Observable} Time-shifted sequence.
 */
observableProto.delaySubscription = function (dueTime, scheduler) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.dematerialize" id="apidoc.element.rx.Observable.prototype.dematerialize">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>dematerialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dematerialize = function () {
  return new DematerializeObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.distinct" id="apidoc.element.rx.Observable.prototype.distinct">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>distinct
        <span class="apidocSignatureSpan">(keySelector, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinct = function (keySelector, comparer) {
  comparer || (comparer = defaultComparer);
  return new DistinctObservable(this, keySelector, comparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}(AbstractObserver));

/**
 *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
 *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow
large.
 *
 * @example
 *  var res = obs = xs.<span class="apidocCodeKeywordSpan">distinct</span>();
 *  2 - obs = xs.distinct(function (x) { return x.id; });
 *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });
 * @param {Function} [keySelector]  A function to compute the comparison key for each element.
 * @param {Function} [comparer]  Used to compare items in the collection.
 * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source
 sequence.
 */
observableProto.distinct = function (keySelector, comparer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.distinctUntilChanged" id="apidoc.element.rx.Observable.prototype.distinctUntilChanged">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>distinctUntilChanged
        <span class="apidocSignatureSpan">(keyFn, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinctUntilChanged = function (keyFn, comparer) {
  comparer || (comparer = defaultComparer);
  return new DistinctUntilChangedObservable(this, keyFn, comparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* Now debounce the input for 500ms */
var debounced = keyups
.debounce(500 /* ms */);

/* Now get only distinct values, so we eliminate the arrows and other control characters */
var distinct = debounced
.<span class="apidocCodeKeywordSpan">distinctUntilChanged</span>();
```

Now, let's query Wikipedia!  In RxJS, we can instantly bind to any [Promises A+](https://github.com/promises-aplus/promises
-spec) implementation through the `Rx.Observable.fromPromise` method. Or, directly return it and RxJS will wrap it for you.

```js
function searchWikipedia (term) {
return $.ajax({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.do" id="apidoc.element.rx.Observable.prototype.do">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>do
        <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">do = function (observerOrOnNext, onError, onCompleted) {
  return new TapObservable(this, observerOrOnNext, onError, onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.doAction" id="apidoc.element.rx.Observable.prototype.doAction">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doAction
        <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doAction = function (observerOrOnNext, onError, onCompleted) {
  return new TapObservable(this, observerOrOnNext, onError, onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.doOnCompleted" id="apidoc.element.rx.Observable.prototype.doOnCompleted">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doOnCompleted
        <span class="apidocSignatureSpan">(onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOnCompleted = function (onCompleted, thisArg) {
  return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () { onCompleted.call(thisArg); } : onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.doOnError" id="apidoc.element.rx.Observable.prototype.doOnError">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doOnError
        <span class="apidocSignatureSpan">(onError, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOnError = function (onError, thisArg) {
  return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) { onError.call(thisArg, e); } : onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.doOnNext" id="apidoc.element.rx.Observable.prototype.doOnNext">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doOnNext
        <span class="apidocSignatureSpan">(onNext, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOnNext = function (onNext, thisArg) {
  return this.tap(typeof thisArg !== 'undefined' ? function (x) { onNext.call(thisArg, x); } : onNext);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.doWhile" id="apidoc.element.rx.Observable.prototype.doWhile">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>doWhile
        <span class="apidocSignatureSpan">(condition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doWhile = function (condition) {
  return observableConcat([this, observableWhileDo(condition, this)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.elementAt" id="apidoc.element.rx.Observable.prototype.elementAt">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>elementAt
        <span class="apidocSignatureSpan">(index, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elementAt = function (index, defaultValue) {
  if (index &lt; 0) { throw new ArgumentOutOfRangeError(); }
  return new ElementAtObservable(this, index, defaultValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.every" id="apidoc.element.rx.Observable.prototype.every">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>every
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
  return new EveryObservable(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return j !== i;
  };
}

CombineLatestObserver.prototype.next = function (x) {
  this._state.values[this._i] = x;
  this._state.hasValue[this._i] = true;
  if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.<span class="apidocCodeKeywordSpan">every</span>(identity))) {
    var res = tryCatch(this._cb).apply(null, this._state.values);
    if (res === errorObj) { return this._o.onError(res.e); }
    this._o.onNext(res);
  } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {
    this._o.onCompleted();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.exhaustMap" id="apidoc.element.rx.Observable.prototype.exhaustMap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>exhaustMap
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exhaustMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.expand" id="apidoc.element.rx.Observable.prototype.expand">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>expand
        <span class="apidocSignatureSpan">(selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expand = function (selector, scheduler) {
  isScheduler(scheduler) || (scheduler = currentThreadScheduler);
  return new ExpandObservable(this, selector, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.extend" id="apidoc.element.rx.Observable.prototype.extend">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>extend
        <span class="apidocSignatureSpan">(selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (selector, scheduler) {
  isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);
  var source = this;
  return observableDefer(function () {
    var chain;

    return source
      .map(function (x) {
        var curr = new ChainObservable(x);

        chain &amp;&amp; chain.onNext(x);
        chain = curr;

        return curr;
      })
      .tap(
        noop,
        function (e) { chain &amp;&amp; chain.onError(e); },
        function () { chain &amp;&amp; chain.onCompleted(); }
      )
      .observeOn(scheduler)
      .map(selector);
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.filter" id="apidoc.element.rx.Observable.prototype.filter">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>filter
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (predicate, thisArg) {
  return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) :
    new FilterObservable(this, predicate, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * The opposite of _.filter this method returns the elements of a collection that the callback does **not** return truthy for.
 * @param {Function} [callback] The function called per iteration.
 * @param {Any} [thisArg] The this binding of callback.
 * @returns {Observable} An Observable sequence which contains items that the callback does not return truthy for.
 */
Rx.Observable.prototype.reject = function (callback, thisArg) {
  callback || (callback = Rx.helpers.identity);
  return this.<span class="apidocCodeKeywordSpan">filter</span>(function (x, i, o) { return !callback.call(thisArg, x, i o); });
};
```

To show an operator that introduces a level of concurrency, let's implement a custom operator such as an implementation of `
_.pairs` from [Underscore.js](http://underscorejs.org/) / [Lo-Dash](http://lodash.com/).  Note that since this requires recursion
 to implement properly, we'll use the `Rx.Scheduler.currentThread` scheduler.

```js
var keysFunction = Object.keys || someKeysPolyfill;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.finally" id="apidoc.element.rx.Observable.prototype.finally">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>finally
        <span class="apidocSignatureSpan">(action, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finally = function (action, thisArg) {
  return new FinallyObservable(this, action, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.find" id="apidoc.element.rx.Observable.prototype.find">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>find
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (predicate, thisArg) {
  return findValue(this, predicate, thisArg, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.findIndex" id="apidoc.element.rx.Observable.prototype.findIndex">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>findIndex
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findIndex = function (predicate, thisArg) {
  return findValue(this, predicate, thisArg, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.first" id="apidoc.element.rx.Observable.prototype.first">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  var obj = {}, source = this;
  if (typeof arguments[0] === 'object') {
    obj = arguments[0];
  } else {
    obj = {
      predicate: arguments[0],
      thisArg: arguments[1],
      defaultValue: arguments[2]
    };
  }
  if (isFunction (obj.predicate)) {
    var fn = obj.predicate;
    obj.predicate = bindCallback(fn, obj.thisArg, 3);
  }
  return new FirstObservable(this, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMap" id="apidoc.element.rx.Observable.prototype.flatMap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMap
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Number} count Length of each buffer.
 * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count
.
 * @returns {Observable} An observable sequence of buffers.
 */
observableProto.bufferWithCount = observableProto.bufferCount = function (count, skip) {
  typeof skip !== 'number' &amp;&amp; (skip = count);
  return this.windowWithCount(count, skip)
    .<span class="apidocCodeKeywordSpan">flatMap</span>(toArray)
    .filter(notEmpty);
};

var DematerializeObservable = (function (__super__) {
  inherits(DematerializeObservable, __super__);
  function DematerializeObservable(source) {
    this.source = source;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMapConcat" id="apidoc.element.rx.Observable.prototype.flatMapConcat">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapConcat
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapConcat = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMapFirst" id="apidoc.element.rx.Observable.prototype.flatMapFirst">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapFirst
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapFirst = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMapLatest" id="apidoc.element.rx.Observable.prototype.flatMapLatest">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapLatest
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapLatest = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
```

Once that is created, we can tie together the distinct throttled input and query the service.  In this case, we'll call `flatMapLatest
` to get the value and ensure we're not introducing any out of order sequence calls.

```js
var suggestions = distinct
.<span class="apidocCodeKeywordSpan">flatMapLatest</span>(searchWikipedia);
```

Finally, we call the `subscribe` method on our observable sequence to start pulling data.

```js
suggestions.subscribe(
data =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMapMaxConcurrent" id="apidoc.element.rx.Observable.prototype.flatMapMaxConcurrent">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapMaxConcurrent
        <span class="apidocSignatureSpan">(limit, selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapMaxConcurrent = function (limit, selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMapObserver" id="apidoc.element.rx.Observable.prototype.flatMapObserver">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapObserver = function (onNext, onError, onCompleted, thisArg) {
  var source = this;
  return new AnonymousObservable(function (observer) {
    var index = 0;

    return source.subscribe(
      function (x) {
        var result;
        try {
          result = onNext.call(thisArg, x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
      },
      function (err) {
        var result;
        try {
          result = onError.call(thisArg, err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      },
      function () {
        var result;
        try {
          result = onCompleted.call(thisArg);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
  }, source).mergeAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.flatMapWithMaxConcurrent" id="apidoc.element.rx.Observable.prototype.flatMapWithMaxConcurrent">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>flatMapWithMaxConcurrent
        <span class="apidocSignatureSpan">(limit, selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapWithMaxConcurrent = function (limit, selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    export interface Observable&lt;T&gt; {
/**
*  One of the Following:
*  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into
one observable sequence.
*
* @example
*  var res = source.<span class="apidocCodeKeywordSpan">flatMapWithMaxConcurrent</span>(5, function (x) { return Rx.Observable.range
(0, x); });
*  Or:
*  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element
 and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
*
*  var res = source.flatMapWithMaxConcurrent(5, function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x +
y; });
*  Or:
*  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable
sequences into one observable sequence.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.forEach" id="apidoc.element.rx.Observable.prototype.forEach">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>forEach
        <span class="apidocSignatureSpan">(oOrOnNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (oOrOnNext, onError, onCompleted) {
  return this._subscribe(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
/* Get stock data somehow */
const source = getAsyncStockData();

const subscription = source
  .filter(quote =&gt; quote.price &gt; 30)
  .map(quote =&gt; quote.price)
  .<span class="apidocCodeKeywordSpan">forEach</span>(price =&gt; console.log(`Prices higher than $30: ${price}`);
```

Now what if this data were to come as some sort of event, for example a stream, such as a WebSocket? Then we could pretty much write
 the same query to iterate our data, with very little change.

```js
/* Get stock data somehow */
const source = getAsyncStockData();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.forkJoin" id="apidoc.element.rx.Observable.prototype.forkJoin">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>forkJoin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forkJoin = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  if (Array.isArray(args[0])) {
    args[0].unshift(this);
  } else {
    args.unshift(this);
  }
  return Observable.forkJoin.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return ForkJoinObserver;
}(AbstractObserver));

 /**
 *  Runs all observable sequences in parallel and collect their last elements.
 *
 * @example
 *  1 - res = Rx.Observable.<span class="apidocCodeKeywordSpan">forkJoin</span>([obs1, obs2]);
 *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
 * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
 */
Observable.forkJoin = function () {
  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.groupBy" id="apidoc.element.rx.Observable.prototype.groupBy">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>groupBy
        <span class="apidocSignatureSpan">(keySelector, elementSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (keySelector, elementSelector) {
  return this.groupByUntil(keySelector, elementSelector, observableNever);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new DistinctObservable(this, keySelector, comparer);
};

/**
 *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting
 elements by using a specified function.
 *
 * @example
 *  var res = observable.<span class="apidocCodeKeywordSpan">groupBy</span>(function (x) { return x.id; });
 *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
 *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
 * @param {Function} keySelector A function to extract the key for each element.
 * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
 * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements
 that share that same key value.
 */
observableProto.groupBy = function (keySelector, elementSelector) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.groupByUntil" id="apidoc.element.rx.Observable.prototype.groupByUntil">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>groupByUntil
        <span class="apidocSignatureSpan">(keySelector, elementSelector, durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByUntil = function (keySelector, elementSelector, durationSelector) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var map = new Map(),
        groupDisposable = new CompositeDisposable(),
        refCountDisposable = new RefCountDisposable(groupDisposable),
        handleError = function (e) { return function (item) { item.onError(e); }; };

      groupDisposable.add(
        source.subscribe(function (x) {
          var key = tryCatch(keySelector)(x);
          if (key === errorObj) {
            map.forEach(handleError(key.e));
            return o.onError(key.e);
          }

          var fireNewMapEntry = false, writer = map.get(key);
          if (writer === undefined) {
            writer = new Subject();
            map.set(key, writer);
            fireNewMapEntry = true;
          }

          if (fireNewMapEntry) {
            var group = new GroupedObservable(key, writer, refCountDisposable),
              durationGroup = new GroupedObservable(key, writer);
            var duration = tryCatch(durationSelector)(durationGroup);
            if (duration === errorObj) {
              map.forEach(handleError(duration.e));
              return o.onError(duration.e);
            }

            o.onNext(group);

            var md = new SingleAssignmentDisposable();
            groupDisposable.add(md);

            md.setDisposable(duration.take(1).subscribe(
              noop,
              function (e) {
                map.forEach(handleError(e));
                o.onError(e);
              },
              function () {
                if (map['delete'](key)) { writer.onCompleted(); }
                groupDisposable.remove(md);
              }));
          }

          var element = x;
          if (isFunction(elementSelector)) {
            element = tryCatch(elementSelector)(x);
            if (element === errorObj) {
              map.forEach(handleError(element.e));
              return o.onError(element.e);
            }
          }

          writer.onNext(element);
      }, function (e) {
        map.forEach(handleError(e));
        o.onError(e);
      }, function () {
        map.forEach(function (item) { item.onCompleted(); });
        o.onCompleted();
      }));

    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements
 that share that same key value.
   */
  observableProto.groupBy = function (keySelector, elementSelector) {
return this.<span class="apidocCodeKeywordSpan">groupByUntil</span>(keySelector, elementSelector, observableNever);
  };

/**
 *  Groups the elements of an observable sequence according to a specified key selector function.
 *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification
. When a new element with the same
 *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.groupJoin" id="apidoc.element.rx.Observable.prototype.groupJoin">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>groupJoin
        <span class="apidocSignatureSpan">(right, leftDurationSelector, rightDurationSelector, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
  var left = this;
  return new AnonymousObservable(function (o) {
    var group = new CompositeDisposable();
    var r = new RefCountDisposable(group);
    var leftMap = new Map(), rightMap = new Map();
    var leftId = 0, rightId = 0;
    var handleError = function (e) { return function (v) { v.onError(e); }; };

    function handleError(e) { };

    group.add(left.subscribe(
      function (value) {
        var s = new Subject();
        var id = leftId++;
        leftMap.set(id, s);

        var result = tryCatch(resultSelector)(value, addRef(s, r));
        if (result === errorObj) {
          leftMap.forEach(handleError(result.e));
          return o.onError(result.e);
        }
        o.onNext(result);

        rightMap.forEach(function (v) { s.onNext(v); });

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(
          noop,
          function (e) {
            leftMap.forEach(handleError(e));
            o.onError(e);
          },
          function () {
            leftMap['delete'](id) &amp;&amp; s.onCompleted();
            group.remove(md);
          }));
      },
      function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      },
      function () { o.onCompleted(); })
    );

    group.add(right.subscribe(
      function (value) {
        var id = rightId++;
        rightMap.set(id, value);

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(
          noop,
          function (e) {
            leftMap.forEach(handleError(e));
            o.onError(e);
          },
          function () {
            rightMap['delete'](id);
            group.remove(md);
          }));

        leftMap.forEach(function (v) { v.onNext(value); });
      },
      function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      })
    );

    return r;
  }, left);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return typeof windowOpeningsOrClosingSelector === 'function' ?
    observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :
    observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
};

function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
  return windowOpenings.<span class="apidocCodeKeywordSpan">groupJoin</span>(this, windowClosingSelector, observableEmpty, function
 (_, win) {
    return win;
  });
}

function observableWindowWithBoundaries(windowBoundaries) {
  var source = this;
  return new AnonymousObservable(function (observer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.ignoreElements" id="apidoc.element.rx.Observable.prototype.ignoreElements">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>ignoreElements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ignoreElements = function () {
  return new IgnoreElementsObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.includes" id="apidoc.element.rx.Observable.prototype.includes">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>includes
        <span class="apidocSignatureSpan">(searchElement, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (searchElement, fromIndex) {
  return new IncludesObservable(this, searchElement, fromIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.indexOf" id="apidoc.element.rx.Observable.prototype.indexOf">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(searchElement, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (searchElement, fromIndex) {
  var n = +fromIndex || 0;
  Math.abs(n) === Infinity &amp;&amp; (n = 0);
  return new IndexOfObservable(this, searchElement, n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If possible, transform the error stack trace by removing Node and RxJS
// cruft, then concatenating with the stack trace of `observable`.
if (hasStacks &amp;&amp;
    observable.stack &amp;&amp;
    typeof error === 'object' &amp;&amp;
    error !== null &amp;&amp;
    error.stack &amp;&amp;
    error.stack.<span class="apidocCodeKeywordSpan">indexOf</span>(STACK_JUMP_SEPARATOR) === -1
) {
  var stacks = [];
  for (var o = observable; !!o; o = o.source) {
    if (o.stack) {
      stacks.unshift(o.stack);
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.isEmpty" id="apidoc.element.rx.Observable.prototype.isEmpty">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return new IsEmptyObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.join" id="apidoc.element.rx.Observable.prototype.join">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>join
        <span class="apidocSignatureSpan">(right, leftDurationSelector, rightDurationSelector, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
  var left = this;
  return new AnonymousObservable(function (o) {
    var group = new CompositeDisposable();
    var leftDone = false, rightDone = false;
    var leftId = 0, rightId = 0;
    var leftMap = new Map(), rightMap = new Map();
    var handleError = function (e) { o.onError(e); };

    group.add(left.subscribe(
      function (value) {
        var id = leftId++, md = new SingleAssignmentDisposable();

        leftMap.set(id, value);
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) { return o.onError(duration.e); }

        md.setDisposable(duration.take(1).subscribe(
          noop,
          handleError,
          function () {
            leftMap['delete'](id) &amp;&amp; leftMap.size === 0 &amp;&amp; leftDone &amp;&amp; o.onCompleted();
            group.remove(md);
          }));

        rightMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(value, v);
          if (result === errorObj) { return o.onError(result.e); }
          o.onNext(result);
        });
      },
      handleError,
      function () {
        leftDone = true;
        (rightDone || leftMap.size === 0) &amp;&amp; o.onCompleted();
      })
    );

    group.add(right.subscribe(
      function (value) {
        var id = rightId++, md = new SingleAssignmentDisposable();

        rightMap.set(id, value);
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) { return o.onError(duration.e); }

        md.setDisposable(duration.take(1).subscribe(
          noop,
          handleError,
          function () {
            rightMap['delete'](id) &amp;&amp; rightMap.size === 0 &amp;&amp; rightDone &amp;&amp; o.onCompleted();
            group.remove(md);
          }));

        leftMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(v, value);
          if (result === errorObj) { return o.onError(result.e); }
          o.onNext(result);
        });
      },
      handleError,
      function () {
        rightDone = true;
        (leftDone || rightMap.size === 0) &amp;&amp; o.onCompleted();
      })
    );
    return group;
  }, left);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var o = observable; !!o; o = o.source) {
      if (o.stack) {
        stacks.unshift(o.stack);
      }
    }
    stacks.unshift(error.stack);

    var concatedStacks = stacks.<span class="apidocCodeKeywordSpan">join</span>('\n' + STACK_JUMP_SEPARATOR + '\n
');
    error.stack = filterStackString(concatedStacks);
  }
}

function filterStackString(stackString) {
  var lines = stackString.split('\n'), desiredLines = [];
  for (var i = 0, len = lines.length; i &lt; len; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.jortSort" id="apidoc.element.rx.Observable.prototype.jortSort">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>jortSort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jortSort = function () {
  return this.jortSortUntil(observableNever());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.jortSortUntil" id="apidoc.element.rx.Observable.prototype.jortSortUntil">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>jortSortUntil
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jortSortUntil = function (other) {
  var source = this;
  return new AnonymousObservable(function (observer) {
    var arr = [];
    return source.takeUntil(other).subscribe(
      arr.push.bind(arr),
      observer.onError.bind(observer),
      function () {
        var sorted = arr.slice(0).sort(defaultSubComparer);
        observer.onNext(isEqual(arr, sorted));
        observer.onCompleted();
      });
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * jortSort checks if your inputs are sorted.  Note that this is only for a sequence with an end.
 * See http://jort.technology/ for full details.
 * @returns {Observable} An observable which has a single value of true if sorted, else false.
 */
observableProto.jortSort = function () {
  return this.<span class="apidocCodeKeywordSpan">jortSortUntil</span>(observableNever());
};

/**
 * jortSort checks if your inputs are sorted until another Observable sequence fires.
 * See http://jort.technology/ for full details.
 * @returns {Observable} An observable which has a single value of true if sorted, else false.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.last" id="apidoc.element.rx.Observable.prototype.last">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  var obj = {}, source = this;
  if (typeof arguments[0] === 'object') {
    obj = arguments[0];
  } else {
    obj = {
      predicate: arguments[0],
      thisArg: arguments[1],
      defaultValue: arguments[2]
    };
  }
  if (isFunction (obj.predicate)) {
    var fn = obj.predicate;
    obj.predicate = bindCallback(fn, obj.thisArg, 3);
  }
  return new LastObservable(this, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.lastIndexOf" id="apidoc.element.rx.Observable.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(searchElement, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function (searchElement, fromIndex) {
  var n = +fromIndex || 0;
  Math.abs(n) === Infinity &amp;&amp; (n = 0);
  return new LastIndexOfObservable(this, searchElement, n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.let" id="apidoc.element.rx.Observable.prototype.let">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>let
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">let = function (func) {
  return func(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.letBind" id="apidoc.element.rx.Observable.prototype.letBind">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>letBind
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letBind = function (func) {
  return func(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.manySelect" id="apidoc.element.rx.Observable.prototype.manySelect">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>manySelect
        <span class="apidocSignatureSpan">(selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">manySelect = function (selector, scheduler) {
  isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);
  var source = this;
  return observableDefer(function () {
    var chain;

    return source
      .map(function (x) {
        var curr = new ChainObservable(x);

        chain &amp;&amp; chain.onNext(x);
        chain = curr;

        return curr;
      })
      .tap(
        noop,
        function (e) { chain &amp;&amp; chain.onError(e); },
        function () { chain &amp;&amp; chain.onCompleted(); }
      )
      .observeOn(scheduler)
      .map(selector);
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.map" id="apidoc.element.rx.Observable.prototype.map">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>map
        <span class="apidocSignatureSpan">(selector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (selector, thisArg) {
  var selectorFn = typeof selector === 'function' ? selector : function () { return selector; };
  return this instanceof MapObservable ?
    this.internalMap(selectorFn, thisArg) :
    new MapObservable(this, selectorFn, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
/* Get stock data somehow */
const source = getAsyncStockData();

const subscription = source
  .filter(quote =&gt; quote.price &gt; 30)
  .<span class="apidocCodeKeywordSpan">map</span>(quote =&gt; quote.price)
  .forEach(price =&gt; console.log(`Prices higher than $30: ${price}`);
```

Now what if this data were to come as some sort of event, for example a stream, such as a WebSocket? Then we could pretty much write
 the same query to iterate our data, with very little change.

```js
/* Get stock data somehow */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.materialize" id="apidoc.element.rx.Observable.prototype.materialize">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>materialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">materialize = function () {
  return new MaterializeObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
JoinObserverPrototype.completed = noop;

JoinObserverPrototype.addActivePlan = function (activePlan) {
  this.activePlans.push(activePlan);
};

JoinObserverPrototype.subscribe = function () {
  this.subscription.setDisposable(this.source.<span class="apidocCodeKeywordSpan">materialize</span>().subscribe(this));
};

JoinObserverPrototype.removeActivePlan = function (activePlan) {
  this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
  this.activePlans.length === 0 &amp;&amp; this.dispose();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.max" id="apidoc.element.rx.Observable.prototype.max">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>max
        <span class="apidocSignatureSpan">(comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function (comparer) {
  return this.maxBy(identity, comparer).map(firstOnly);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  comparer || (comparer = defaultSubComparer);
  return new ExtremaByObservable(this, keySelector, comparer);
};

/**
 * Returns the maximum value in an observable sequence according to the specified comparer.
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">max</span>();
 * var res = source.max(function (x, y) { return x.value - y.value; });
 * @param {Function} [comparer] Comparer used to compare elements.
 * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.
 */
observableProto.max = function (comparer) {
  return this.maxBy(identity, comparer).map(firstOnly);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.maxBy" id="apidoc.element.rx.Observable.prototype.maxBy">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>maxBy
        <span class="apidocSignatureSpan">(keySelector, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxBy = function (keySelector, comparer) {
  comparer || (comparer = defaultSubComparer);
  return new ExtremaByObservable(this, keySelector, comparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
observableProto.min = function (comparer) {
  return this.minBy(identity, comparer).map(firstOnly);
};

/**
 * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">maxBy</span>(function (x) { return x.value; });
 * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });
 * @param {Function} keySelector Key selector function.
 * @param {Function} [comparer]  Comparer used to compare key values.
 * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.
 */
observableProto.maxBy = function (keySelector, comparer) {
  comparer || (comparer = defaultSubComparer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.merge" id="apidoc.element.rx.Observable.prototype.merge">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>merge
        <span class="apidocSignatureSpan">(maxConcurrentOrOther)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (maxConcurrentOrOther) {
  return typeof maxConcurrentOrOther !== 'number' ?
    observableMerge(this, maxConcurrentOrOther) :
    new MergeObservable(this, maxConcurrentOrOther);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  /**
   * Concatenates an observable sequence of observable sequences.
   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order
.
   */
  observableProto.concatAll = function () {
return this.<span class="apidocCodeKeywordSpan">merge</span>(1);
  };

  var MergeObservable = (function (__super__) {
inherits(MergeObservable, __super__);

function MergeObservable(source, maxConcurrent) {
  this.source = source;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.mergeAll" id="apidoc.element.rx.Observable.prototype.mergeAll">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>mergeAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeAll = function () {
  return new MergeAllObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  scheduler = immediateScheduler;
  for(i = 0; i &lt; len; i++) { sources.push(arguments[i]); }
}
if (Array.isArray(sources[0])) {
  sources = sources[0];
}
return observableOf(scheduler, sources).<span class="apidocCodeKeywordSpan">mergeAll</span>();
  };

  var MergeAllObservable = (function (__super__) {
inherits(MergeAllObservable, __super__);

function MergeAllObservable(source) {
  this.source = source;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.mergeMap" id="apidoc.element.rx.Observable.prototype.mergeMap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>mergeMap
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.min" id="apidoc.element.rx.Observable.prototype.min">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>min
        <span class="apidocSignatureSpan">(comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function (comparer) {
  return this.minBy(identity, comparer).map(firstOnly);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  comparer || (comparer = defaultSubComparer);
  return new ExtremaByObservable(this, keySelector, function (x, y) { return comparer(x, y) * -1; });
};

/**
 * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than
 check.
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">min</span>();
 * var res = source.min(function (x, y) { return x.value - y.value; });
 * @param {Function} [comparer] Comparer used to compare elements.
 * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.
 */
observableProto.min = function (comparer) {
  return this.minBy(identity, comparer).map(firstOnly);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.minBy" id="apidoc.element.rx.Observable.prototype.minBy">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>minBy
        <span class="apidocSignatureSpan">(keySelector, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minBy = function (keySelector, comparer) {
  comparer || (comparer = defaultSubComparer);
  return new ExtremaByObservable(this, keySelector, function (x, y) { return comparer(x, y) * -1; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var fn = bindCallback(keySelector, thisArg, 3);
  return new SumObservable(this, fn);
};

/**
 * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">minBy</span>(function (x) { return x.value; });
 * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });
 * @param {Function} keySelector Key selector function.
 * @param {Function} [comparer] Comparer used to compare key values.
 * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.
 */
observableProto.minBy = function (keySelector, comparer) {
  comparer || (comparer = defaultSubComparer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.multicast" id="apidoc.element.rx.Observable.prototype.multicast">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>multicast
        <span class="apidocSignatureSpan">(subjectOrSubjectSelector, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multicast = function (subjectOrSubjectSelector, selector) {
  return isFunction(subjectOrSubjectSelector) ?
    new MulticastObservable(this, subjectOrSubjectSelector, selector) :
    new ConnectableObservable(this, subjectOrSubjectSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  var ControlledObservable = (function (__super__) {
inherits(ControlledObservable, __super__);
function ControlledObservable (source, enableQueue, scheduler) {
  __super__.call(this);
  this.subject = new ControlledSubject(enableQueue, scheduler);
  this.source = source.<span class="apidocCodeKeywordSpan">multicast</span>(this.subject).refCount();
}

ControlledObservable.prototype._subscribe = function (o) {
  return this.source.subscribe(o);
};

ControlledObservable.prototype.request = function (numberOfItems) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.observeOn" id="apidoc.element.rx.Observable.prototype.observeOn">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>observeOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observeOn = function (scheduler) {
  return new ObserveOnObservable(this, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return curr;
      })
      .tap(
        noop,
        function (e) { chain &amp;&amp; chain.onError(e); },
        function () { chain &amp;&amp; chain.onCompleted(); }
      )
      .<span class="apidocCodeKeywordSpan">observeOn</span>(scheduler)
      .map(selector);
  }, source);
};

var ChainObservable = (function (__super__) {
  inherits(ChainObservable, __super__);
  function ChainObservable(head) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.onErrorResumeNext" id="apidoc.element.rx.Observable.prototype.onErrorResumeNext">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>onErrorResumeNext
        <span class="apidocSignatureSpan">(second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorResumeNext = function (second) {
  if (!second) { throw new Error('Second observable is required'); }
  return onErrorResumeNext([this, second]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

export interface ObservableStatic {
    /**
    * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
    *
    * @example
    * 1 - res = Rx.Observable.<span class="apidocCodeKeywordSpan">onErrorResumeNext</span>(xs, ys, zs);
    * 1 - res = Rx.Observable.onErrorResumeNext([xs, ys, zs]);
    * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally
.
    */
    onErrorResumeNext&lt;T&gt;(...sources: ObservableOrPromise&lt;T&gt;[]): Observable&lt;T&gt;;
    /**
    * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
    *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.pairwise" id="apidoc.element.rx.Observable.prototype.pairwise">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pairwise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pairwise = function () {
  return new PairwiseObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.partition" id="apidoc.element.rx.Observable.prototype.partition">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>partition
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">partition = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
  return [
    this.filter(predicate, thisArg),
    this.filter(function (x, i, o) { return !fn(x, i, o); })
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.pausable" id="apidoc.element.rx.Observable.prototype.pausable">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pausable
        <span class="apidocSignatureSpan">(pauser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pausable = function (pauser) {
  return new PausableObservable(this, pauser);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}(Observable));

/**
 * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
 * @example
 * var pauser = new Rx.Subject();
 * var source = Rx.Observable.interval(100).<span class="apidocCodeKeywordSpan">pausable</span>(pauser);
 * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
 * @returns {Observable} The observable sequence which is paused based upon the pauser.
 */
observableProto.pausable = function (pauser) {
  return new PausableObservable(this, pauser);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.pausableBuffered" id="apidoc.element.rx.Observable.prototype.pausableBuffered">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pausableBuffered
        <span class="apidocSignatureSpan">(pauser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pausableBuffered = function (pauser) {
  return new PausableBufferedObservable(this, pauser);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}(Observable));

/**
 * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
 * and yields the values that were buffered while paused.
 * @example
 * var pauser = new Rx.Subject();
 * var source = Rx.Observable.interval(100).<span class="apidocCodeKeywordSpan">pausableBuffered</span>(pauser);
 * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
 * @returns {Observable} The observable sequence which is paused based upon the pauser.
 */
observableProto.pausableBuffered = function (pauser) {
  return new PausableBufferedObservable(this, pauser);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.pipe" id="apidoc.element.rx.Observable.prototype.pipe">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pipe
        <span class="apidocSignatureSpan">(dest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (dest) {
  var source = this.pausableBuffered();

  function onDrain() {
    source.resume();
  }

  dest.addListener('drain', onDrain);

  source.subscribe(
    function (x) {
      !dest.write(x) &amp;&amp; source.pause();
    },
    function (err) {
      dest.emit('error', err);
    },
    function () {
      // Hack check because STDIO is not closable
      !dest._isStdio &amp;&amp; dest.end();
      dest.removeListener('drain', onDrain);
    });

  source.resume();

  return dest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.pluck" id="apidoc.element.rx.Observable.prototype.pluck">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>pluck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pluck = function () {
  var len = arguments.length, args = new Array(len);
  if (len === 0) { throw new Error('List of properties cannot be empty.'); }
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  return this.map(plucker(args, len));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const $input = $('#input');
const $results = $('#results');

/* Only get the value from each key up */
var keyups = Rx.Observable.fromEvent($input, 'keyup')
  .<span class="apidocCodeKeywordSpan">pluck</span>('target', 'value')
  .filter(text =&gt; text.length &gt; 2 );

/* Now debounce the input for 500ms */
var debounced = keyups
  .debounce(500 /* ms */);

/* Now get only distinct values, so we eliminate the arrows and other control characters */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.publish" id="apidoc.element.rx.Observable.prototype.publish">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>publish
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (selector) {
  return selector &amp;&amp; isFunction(selector) ?
    this.multicast(function () { return new Subject(); }, selector) :
    this.multicast(new Subject());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return fromEventPattern(
        function (h) { element.on(eventName, h); },
        function (h) { element.off(eventName, h); },
        selector);
    }
  }

  return new EventObservable(element, eventName, selector).<span class="apidocCodeKeywordSpan">publish</span>().refCount();
};

var EventPatternObservable = (function(__super__) {
  inherits(EventPatternObservable, __super__);
  function EventPatternObservable(add, del, fn) {
    this._add = add;
    this._del = del;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.publishLast" id="apidoc.element.rx.Observable.prototype.publishLast">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>publishLast
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publishLast = function (selector) {
  return selector &amp;&amp; isFunction(selector) ?
    this.multicast(function () { return new AsyncSubject(); }, selector) :
    this.multicast(new AsyncSubject());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a
 single subscription to the underlying sequence containing only the last notification.
 * This operator is a specialization of Multicast using a AsyncSubject.
 *
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">publishLast</span>();
 * var res = source.publishLast(function (x) { return x; });
 *
 * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing
 multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source
.
 * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence
 within a selector function.
 */
observableProto.publishLast = function (selector) {
  return selector &amp;&amp; isFunction(selector) ?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.publishValue" id="apidoc.element.rx.Observable.prototype.publishValue">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>publishValue
        <span class="apidocSignatureSpan">(initialValueOrSelector, initialValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publishValue = function (initialValueOrSelector, initialValue) {
  return arguments.length === 2 ?
    this.multicast(function () {
      return new BehaviorSubject(initialValue);
    }, initialValueOrSelector) :
    this.multicast(new BehaviorSubject(initialValueOrSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a
 single subscription to the underlying sequence and starts with initialValue.
 * This operator is a specialization of Multicast using a BehaviorSubject.
 *
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">publishValue</span>(42);
 * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);
 *
 * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed
, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive
 the initial value, followed by all notifications of the source from the time of the subscription on.
 * @param {Mixed} initialValue Initial value received by observers upon subscription.
 * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence
 within a selector function.
 */
observableProto.publishValue = function (initialValueOrSelector, initialValue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.reduce" id="apidoc.element.rx.Observable.prototype.reduce">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>reduce
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function () {
  var hasSeed = false, seed, accumulator = arguments[0];
  if (arguments.length === 2) {
    hasSeed = true;
    seed = arguments[1];
  }
  return new ReduceObservable(this, accumulator, hasSeed, seed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.repeat" id="apidoc.element.rx.Observable.prototype.repeat">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>repeat
        <span class="apidocSignatureSpan">(repeatCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (repeatCount) {
  return enumerableRepeat(this, repeatCount).concat();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count
 is not specified, it retries indefinitely.
 *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
 *
 * @example
 *  var res = retried = retry.<span class="apidocCodeKeywordSpan">repeat</span>();
 *  var res = retried = retry.repeat(2);
 * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
 * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully
.
 */
observableProto.retry = function (retryCount) {
  return enumerableRepeat(this, retryCount).catchError();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.repeatWhen" id="apidoc.element.rx.Observable.prototype.repeatWhen">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>repeatWhen
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeatWhen = function (notifier) {
  return new RepeatWhenObservable(repeat(this), notifier);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.replay" id="apidoc.element.rx.Observable.prototype.replay">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>replay
        <span class="apidocSignatureSpan">(selector, bufferSize, windowSize, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replay = function (selector, bufferSize, windowSize, scheduler) {
  return selector &amp;&amp; isFunction(selector) ?
    this.multicast(function () { return new ReplaySubject(bufferSize, windowSize, scheduler); }, selector) :
    this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a
 single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
 * This operator is a specialization of Multicast using a ReplaySubject.
 *
 * @example
 * var res = source.<span class="apidocCodeKeywordSpan">replay</span>(null, 3);
 * var res = source.replay(null, 3, 500);
 * var res = source.replay(null, 3, 500, scheduler);
 * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);
 *
 * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing
 multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source
 subject to the specified replay buffer trimming policy.
 * @param bufferSize [Optional] Maximum element count of the replay buffer.
 * @param windowSize [Optional] Maximum time length of the replay buffer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.retry" id="apidoc.element.rx.Observable.prototype.retry">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>retry
        <span class="apidocSignatureSpan">(retryCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (retryCount) {
  return enumerableRepeat(this, retryCount).catchError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
observableProto.repeat = function (repeatCount) {
  return enumerableRepeat(this, repeatCount).concat();
};

/**
 *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count
 is not specified, it retries indefinitely.
 *  Note if you encounter an error and want it to retry once, then you must use .<span class="apidocCodeKeywordSpan">retry</span>(2);
 *
 * @example
 *  var res = retried = retry.repeat();
 *  var res = retried = retry.repeat(2);
 * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
 * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully
.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.retryWhen" id="apidoc.element.rx.Observable.prototype.retryWhen">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>retryWhen
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryWhen = function (notifier) {
  return new RetryWhenObservable(repeat(this), notifier);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
export interface Observable&lt;T&gt; {
    /**
     *  Repeats the source observable sequence upon error each time the notifier emits or until it successfully terminates.
     *  if the notifier completes, the observable sequence completes.
     *
     * @example
     *  var timer = Observable.timer(500);
     *  var source = observable.<span class="apidocCodeKeywordSpan">retryWhen</span>(timer);
     * @param {Observable} [notifier] An observable that triggers the retries or completes the observable with onNext or onCompleted
 respectively.
     * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates
successfully.
     */
    retryWhen(notifier: (errors: Observable&lt;any&gt;) =&gt; Observable&lt;any&gt;): Observable&lt;T&gt;;
}

export interface Observable&lt;T&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.sample" id="apidoc.element.rx.Observable.prototype.sample">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>sample
        <span class="apidocSignatureSpan">(intervalOrSampler, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sample = function (intervalOrSampler, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return typeof intervalOrSampler === 'number' ?
    new SampleObservable(this, observableinterval(intervalOrSampler, scheduler)) :
    new SampleObservable(this, intervalOrSampler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return SampleSourceObserver;
}(AbstractObserver));

/**
 *  Samples the observable sequence at each interval.
 *
 * @example
 *  1 - res = source.<span class="apidocCodeKeywordSpan">sample</span>(sampleObservable); // Sampler tick sequence
 *  2 - res = source.sample(5000); // 5 seconds
 *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds
 *
 * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable
.
 * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.
 * @returns {Observable} Sampled observable sequence.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.scan" id="apidoc.element.rx.Observable.prototype.scan">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>scan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function () {
  var hasSeed = false, seed, accumulator = arguments[0];
  if (arguments.length === 2) {
    hasSeed = true;
    seed = arguments[1];
  }
  return new ScanObservable(this, accumulator, hasSeed, seed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

export interface Observable&lt;T&gt; {
    /**
    *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value
 is used as the initial accumulator value.
    *  For aggregation behavior with no intermediate results, see Observable.aggregate.
    * @example
    *  var res = source.<span class="apidocCodeKeywordSpan">scan</span>(function (acc, x) { return acc + x; });
    *  var res = source.scan(function (acc, x) { return acc + x; }, 0);
    * @param {Function} accumulator An accumulator function to be invoked on each element.
    * @param {Mixed} [seed] The initial accumulator value.
    * @returns {Observable} An observable sequence containing the accumulated values.
    */
    scan&lt;TAcc&gt;(accumulator: _Accumulator&lt;T, TAcc&gt;, seed?: TAcc): Observable&lt;TAcc&gt;;
    /**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.select" id="apidoc.element.rx.Observable.prototype.select">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>select
        <span class="apidocSignatureSpan">(selector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (selector, thisArg) {
  var selectorFn = typeof selector === 'function' ? selector : function () { return selector; };
  return this instanceof MapObservable ?
    this.internalMap(selectorFn, thisArg) :
    new MapObservable(this, selectorFn, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a
 single subscription to the underlying sequence and starts with initialValue.
 * This operator is a specialization of Multicast using a BehaviorSubject.
 *
 * @example
 * var res = source.publishValue(42);
 * var res = source.publishValue(function (x) { return x.<span class="apidocCodeKeywordSpan">select</span>(function (y) { return
 y * y; }) }, 42);
 *
 * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed
, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive
 the initial value, followed by all notifications of the source from the time of the subscription on.
 * @param {Mixed} initialValue Initial value received by observers upon subscription.
 * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence
 within a selector function.
 */
observableProto.publishValue = function (initialValueOrSelector, initialValue) {
  return arguments.length === 2 ?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.selectConcatObserver" id="apidoc.element.rx.Observable.prototype.selectConcatObserver">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>selectConcatObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectConcatObserver = function (onNext, onError, onCompleted, thisArg) {
  var source = this,
      onNextFunc = bindCallback(onNext, thisArg, 2),
      onErrorFunc = bindCallback(onError, thisArg, 1),
      onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
  return new AnonymousObservable(function (observer) {
    var index = 0;
    return source.subscribe(
      function (x) {
        var result;
        try {
          result = onNextFunc(x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
      },
      function (err) {
        var result;
        try {
          result = onErrorFunc(err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      },
      function () {
        var result;
        try {
          result = onCompletedFunc();
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
  }, this).concatAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.selectMany" id="apidoc.element.rx.Observable.prototype.selectMany">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>selectMany
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectMany = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    export interface Observable&lt;T&gt; {
/**
*  One of the Following:
*  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into
one observable sequence.
*
* @example
*  var res = source.<span class="apidocCodeKeywordSpan">selectMany</span>(function (x) { return Rx.Observable.range(0, x); });
*  Or:
*  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element
 and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
*
*  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
*  Or:
*  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable
sequences into one observable sequence.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.selectManyObserver" id="apidoc.element.rx.Observable.prototype.selectManyObserver">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>selectManyObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectManyObserver = function (onNext, onError, onCompleted, thisArg) {
  var source = this;
  return new AnonymousObservable(function (observer) {
    var index = 0;

    return source.subscribe(
      function (x) {
        var result;
        try {
          result = onNext.call(thisArg, x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
      },
      function (err) {
        var result;
        try {
          result = onError.call(thisArg, err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      },
      function () {
        var result;
        try {
          result = onCompleted.call(thisArg);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) &amp;&amp; (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
  }, source).mergeAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.sequenceEqual" id="apidoc.element.rx.Observable.prototype.sequenceEqual">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>sequenceEqual
        <span class="apidocSignatureSpan">(second, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceEqual = function (second, comparer) {
  var first = this;
  comparer || (comparer = defaultComparer);
  return new AnonymousObservable(function (o) {
    var donel = false, doner = false, ql = [], qr = [];
    var subscription1 = first.subscribe(function (x) {
      if (qr.length &gt; 0) {
        var v = qr.shift();
        var equal = tryCatch(comparer)(v, x);
        if (equal === errorObj) { return o.onError(equal.e); }
        if (!equal) {
          o.onNext(false);
          o.onCompleted();
        }
      } else if (doner) {
        o.onNext(false);
        o.onCompleted();
      } else {
        ql.push(x);
      }
    }, function(e) { o.onError(e); }, function () {
      donel = true;
      if (ql.length === 0) {
        if (qr.length &gt; 0) {
          o.onNext(false);
          o.onCompleted();
        } else if (doner) {
          o.onNext(true);
          o.onCompleted();
        }
      }
    });

    (isArrayLike(second) || isIterable(second)) &amp;&amp; (second = observableFrom(second));
    isPromise(second) &amp;&amp; (second = observableFromPromise(second));
    var subscription2 = second.subscribe(function (x) {
      if (ql.length &gt; 0) {
        var v = ql.shift();
        var equal = tryCatch(comparer)(v, x);
        if (equal === errorObj) { return o.onError(equal.e); }
        if (!equal) {
          o.onNext(false);
          o.onCompleted();
        }
      } else if (donel) {
        o.onNext(false);
        o.onCompleted();
      } else {
        qr.push(x);
      }
    }, function(e) { o.onError(e); }, function () {
      doner = true;
      if (qr.length === 0) {
        if (ql.length &gt; 0) {
          o.onNext(false);
          o.onCompleted();
        } else if (donel) {
          o.onNext(true);
          o.onCompleted();
        }
      }
    });
    return new BinaryDisposable(subscription1, subscription2);
  }, first);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new AverageObservable(source, fn);
};

/**
 *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
 *
 * @example
 * var res = res = source.<span class="apidocCodeKeywordSpan">sequenceEqual</span>([1,2,3]);
 * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });
 * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));
 * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });
 * @param {Observable} second Second observable sequence or array to compare.
 * @param {Function} [comparer] Comparer used to compare elements of both sequences.
 * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal
 length and their corresponding elements are equal according to the specified equality comparer.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.share" id="apidoc.element.rx.Observable.prototype.share">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>share
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">share = function () {
  return this.publish().refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.shareReplay" id="apidoc.element.rx.Observable.prototype.shareReplay">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>shareReplay
        <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shareReplay = function (bufferSize, windowSize, scheduler) {
  return this.replay(null, bufferSize, windowSize, scheduler).refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  /**
* Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to
 a maximum time length for the replay buffer.
* This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then
 shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription
 is disposed.
*
* @example
* var res = source.<span class="apidocCodeKeywordSpan">shareReplay</span>(3);
* var res = source.shareReplay(3, 500);
* var res = source.shareReplay(3, 500, scheduler);
*

* @param bufferSize [Optional] Maximum element count of the replay buffer.
* @param window [Optional] Maximum time length of the replay buffer.
* @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.shareValue" id="apidoc.element.rx.Observable.prototype.shareValue">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>shareValue
        <span class="apidocSignatureSpan">(initialValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shareValue = function (initialValue) {
  return this.publishValue(initialValue).refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.single" id="apidoc.element.rx.Observable.prototype.single">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>single
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">single = function (predicate, thisArg) {
  var obj = {}, source = this;
  if (typeof arguments[0] === 'object') {
    obj = arguments[0];
  } else {
    obj = {
      predicate: arguments[0],
      thisArg: arguments[1],
      defaultValue: arguments[2]
    };
  }
  if (isFunction (obj.predicate)) {
    var fn = obj.predicate;
    obj.predicate = bindCallback(fn, obj.thisArg, 3);
  }
  return new AnonymousObservable(function (o) {
    return source.subscribe(new SingleObserver(o, obj, source));
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.singleInstance" id="apidoc.element.rx.Observable.prototype.singleInstance">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>singleInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">singleInstance = function () {
  var source = this, hasObservable = false, observable;

  function getObservable() {
    if (!hasObservable) {
      hasObservable = true;
      observable = source['finally'](function() { hasObservable = false; }).publish().refCount();
    }
    return observable;
  }

  return new AnonymousObservable(function(o) {
    return getObservable().subscribe(o);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skip" id="apidoc.element.rx.Observable.prototype.skip">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skip
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (count) {
  if (count &lt; 0) { throw new ArgumentOutOfRangeError(); }
  return new SkipObservable(this, count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skipLast" id="apidoc.element.rx.Observable.prototype.skipLast">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipLast
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLast = function (count) {
  if (count &lt; 0) { throw new ArgumentOutOfRangeError(); }
  return new SkipLastObservable(this, count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skipLastWithTime" id="apidoc.element.rx.Observable.prototype.skipLastWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipLastWithTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLastWithTime = function (duration, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new SkipLastWithTimeObservable(this, duration, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delaySubscription(dueTime: number, scheduler?: IScheduler): Observable&lt;T&gt;;
}

export interface Observable&lt;T&gt; {
    /**
    *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to
 run timers.
    *
    *  1 - res = source.<span class="apidocCodeKeywordSpan">skipLastWithTime</span>(5000);
    *  2 - res = source.skipLastWithTime(5000, scheduler);
    *
    * @description
    *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
    *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
    *  result sequence. This causes elements to be delayed with duration.
    * @param {Number} duration Duration for skipping elements from the end of the sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skipUntil" id="apidoc.element.rx.Observable.prototype.skipUntil">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipUntil
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipUntil = function (other) {
  return new SkipUntilObservable(this, other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skipUntilWithTime" id="apidoc.element.rx.Observable.prototype.skipUntilWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipUntilWithTime
        <span class="apidocSignatureSpan">(startTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipUntilWithTime = function (startTime, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new SkipUntilWithTimeObservable(this, startTime, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/**
 *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers
.
 *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start
 time.
 *
 * @examples
 *  1 - res = source.<span class="apidocCodeKeywordSpan">skipUntilWithTime</span>(new Date(), [scheduler]);
 *  2 - res = source.skipUntilWithTime(5000, [scheduler]);
 * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to
 Date(), no elements will be skipped.
 * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
 * @returns {Observable} An observable sequence with the elements skipped until the specified start time.
 */
observableProto.skipUntilWithTime = function (startTime, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skipWhile" id="apidoc.element.rx.Observable.prototype.skipWhile">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWhile = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
  return new SkipWhileObservable(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return SkipWhileObserver;
}(AbstractObserver));

/**
 *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements
.
 *  The element's index is used in the logic of the predicate function.
 *
 *  var res = source.<span class="apidocCodeKeywordSpan">skipWhile</span>(function (value) { return value &lt; 10; });
 *  var res = source.skipWhile(function (value, index) { return value &lt; 10 || index &lt; 10; });
 * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents
the index of the source element.
 * @param {Any} [thisArg] Object to use as this when executing callback.
 * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element
 in the linear series that does not pass the test specified by predicate.
 */
observableProto.skipWhile = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.skipWithTime" id="apidoc.element.rx.Observable.prototype.skipWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>skipWithTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWithTime = function (duration, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new SkipWithTimeObservable(this, duration, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

export interface Observable&lt;T&gt; {
    /**
    *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler
 to run timers.
    *
    * @example
    *  1 - res = source.<span class="apidocCodeKeywordSpan">skipWithTime</span>(5000, [optional scheduler]);
    *
    * @description
    *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence
.
    *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source
 sequence to be forwarded
    *  may not execute immediately, despite the zero due time.
    *
    *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.slice" id="apidoc.element.rx.Observable.prototype.slice">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  var start = begin || 0;
  if (start &lt; 0) { throw new Rx.ArgumentOutOfRangeError(); }
  if (typeof end === 'number' &amp;&amp; end &lt; start) {
    throw new Rx.ArgumentOutOfRangeError();
  }
  return new SliceObservable(this, start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

JoinObserverPrototype.next = function (notification) {
  if (!this.isDisposed) {
    if (notification.kind === 'E') {
      return this.onError(notification.error);
    }
    this.queue.push(notification);
    var activePlans = this.activePlans.<span class="apidocCodeKeywordSpan">slice</span>(0);
    for (var i = 0, len = activePlans.length; i &lt; len; i++) {
      activePlans[i].match();
    }
  }
};

JoinObserverPrototype.error = noop;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.some" id="apidoc.element.rx.Observable.prototype.some">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>some
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
  return new SomeObservable(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.startWith" id="apidoc.element.rx.Observable.prototype.startWith">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>startWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startWith = function () {
  var values, scheduler, start = 0;
  if (!!arguments.length &amp;&amp; isScheduler(arguments[0])) {
    scheduler = arguments[0];
    start = 1;
  } else {
    scheduler = immediateScheduler;
  }
  for(var args = [], i = start, len = arguments.length; i &lt; len; i++) { args.push(arguments[i]); }
  return observableConcat.apply(null, [observableFromArray(args, scheduler), this]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (count &lt; 0) { throw new ArgumentOutOfRangeError(); }
  return new SkipLastObservable(this, count);
};

/**
 *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend
.
 *  @example
 *  var res = source.<span class="apidocCodeKeywordSpan">startWith</span>(1, 2, 3);
 *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);
 * @param {Arguments} args The specified values to prepend to the observable sequence
 * @returns {Observable} The source sequence prepended with the specified values.
 */
observableProto.startWith = function () {
  var values, scheduler, start = 0;
  if (!!arguments.length &amp;&amp; isScheduler(arguments[0])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.subscribe" id="apidoc.element.rx.Observable.prototype.subscribe">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(oOrOnNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (oOrOnNext, onError, onCompleted) {
  return this._subscribe(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Observable} An Observable sequence which contains items that the callback does not return truthy for.
 */
Rx.Observable.prototype.reject = function (callback, thisArg) {
callback || (callback = Rx.helpers.identity);
var source = this;
return new Rx.AnonymousObservable(function (observer) {
  var i = 0;
  return source.<span class="apidocCodeKeywordSpan">subscribe</span>(
    function (x) {
      var noYield = true;
      try {
        noYield = callback.call(thisArg, x, i++, source);
      } catch (e) {
        observer.onError(e);
        return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.subscribeOn" id="apidoc.element.rx.Observable.prototype.subscribeOn">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeOn = function (scheduler) {
  return new SubscribeOnObservable(this, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.subscribeOnCompleted" id="apidoc.element.rx.Observable.prototype.subscribeOnCompleted">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOnCompleted
        <span class="apidocSignatureSpan">(onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeOnCompleted = function (onCompleted, thisArg) {
  return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() { onCompleted.call(thisArg); } :
onCompleted));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

observable.subscribeOnNext((v) =&gt; {});
observable.subscribeOnNext((v) =&gt; {}, {});

observable.subscribeOnError((v) =&gt; {});
observable.subscribeOnError((v) =&gt; {}, {});

observable.<span class="apidocCodeKeywordSpan">subscribeOnCompleted</span>(() =&gt; {});
observable.subscribeOnCompleted(() =&gt; {}, {});

observable.forEach(observer);
observable.forEach((v) =&gt; {});
observable.forEach((v) =&gt; {}, (e) =&gt; {});
observable.forEach((v) =&gt; {}, (e) =&gt; {}, () =&gt; {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.subscribeOnError" id="apidoc.element.rx.Observable.prototype.subscribeOnError">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOnError
        <span class="apidocSignatureSpan">(onError, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeOnError = function (onError, thisArg) {
  return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) { onError.call(thisArg, e); } : onError
));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
observable.subscribe((v) =&gt; {});
observable.subscribe((v) =&gt; {}, (e) =&gt; {});
observable.subscribe((v) =&gt; {}, (e) =&gt; {}, () =&gt; {});

observable.subscribeOnNext((v) =&gt; {});
observable.subscribeOnNext((v) =&gt; {}, {});

observable.<span class="apidocCodeKeywordSpan">subscribeOnError</span>((v) =&gt; {});
observable.subscribeOnError((v) =&gt; {}, {});

observable.subscribeOnCompleted(() =&gt; {});
observable.subscribeOnCompleted(() =&gt; {}, {});

observable.forEach(observer);
observable.forEach((v) =&gt; {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.subscribeOnNext" id="apidoc.element.rx.Observable.prototype.subscribeOnNext">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>subscribeOnNext
        <span class="apidocSignatureSpan">(onNext, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeOnNext = function (onNext, thisArg) {
  return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) { onNext.call(thisArg, x); } : onNext));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observable: Rx.Observable&lt;number&gt;;

observable.subscribe(observer);
observable.subscribe((v) =&gt; {});
observable.subscribe((v) =&gt; {}, (e) =&gt; {});
observable.subscribe((v) =&gt; {}, (e) =&gt; {}, () =&gt; {});

observable.<span class="apidocCodeKeywordSpan">subscribeOnNext</span>((v) =&gt; {});
observable.subscribeOnNext((v) =&gt; {}, {});

observable.subscribeOnError((v) =&gt; {});
observable.subscribeOnError((v) =&gt; {}, {});

observable.subscribeOnCompleted(() =&gt; {});
observable.subscribeOnCompleted(() =&gt; {}, {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.sum" id="apidoc.element.rx.Observable.prototype.sum">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>sum
        <span class="apidocSignatureSpan">(keySelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function (keySelector, thisArg) {
  var fn = bindCallback(keySelector, thisArg, 3);
  return new SumObservable(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.switch" id="apidoc.element.rx.Observable.prototype.switch">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switch = function () {
  return new SwitchObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.switchFirst" id="apidoc.element.rx.Observable.prototype.switchFirst">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switchFirst
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchFirst = function () {
  return new SwitchFirstObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Observable} A exclusive observable with only the results that happen when subscribed.
 */
observableProto.switchFirst = function () {
  return new SwitchFirstObservable(this);
};

observableProto.flatMapFirst = observableProto.exhaustMap = function(selector, resultSelector, thisArg) {
  return new FlatMapObservable(this, selector, resultSelector, thisArg).<span class="apidocCodeKeywordSpan">switchFirst</span>();
};

observableProto.flatMapWithMaxConcurrent = observableProto.flatMapMaxConcurrent = function(limit, selector, resultSelector, thisArg
) {
  return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
};

var TransduceObserver = (function (__super__) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.switchLatest" id="apidoc.element.rx.Observable.prototype.switchLatest">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switchLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchLatest = function () {
  return new SwitchObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        observer.onNext(result);
        observer.onCompleted();
      });
  }, source).mergeAll();
};

observableProto.flatMapLatest = observableProto.switchMap = function(selector, resultSelector, thisArg) {
  return new FlatMapObservable(this, selector, resultSelector, thisArg).<span class="apidocCodeKeywordSpan">switchLatest</span>();
};

var SkipObservable = (function(__super__) {
  inherits(SkipObservable, __super__);
  function SkipObservable(source, count) {
    this.source = source;
    this._count = count;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.switchMap" id="apidoc.element.rx.Observable.prototype.switchMap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>switchMap
        <span class="apidocSignatureSpan">(selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.take" id="apidoc.element.rx.Observable.prototype.take">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>take
        <span class="apidocSignatureSpan">(count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">take = function (count, scheduler) {
  if (count &lt; 0) { throw new ArgumentOutOfRangeError(); }
  if (count === 0) { return observableEmpty(scheduler); }
  return new TakeObservable(this, count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

o.onNext(group);

var md = new SingleAssignmentDisposable();
groupDisposable.add(md);

md.setDisposable(duration.<span class="apidocCodeKeywordSpan">take</span>(1).subscribe(
  noop,
  function (e) {
    map.forEach(handleError(e));
    o.onError(e);
  },
  function () {
    if (map['delete'](key)) { writer.onCompleted(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeLast" id="apidoc.element.rx.Observable.prototype.takeLast">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLast
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLast = function (count) {
  if (count &lt; 0) { throw new ArgumentOutOfRangeError(); }
  var source = this;
  return new AnonymousObservable(function (o) {
    return source.subscribe(new TakeLastObserver(o, count));
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeLastBuffer" id="apidoc.element.rx.Observable.prototype.takeLastBuffer">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLastBuffer
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLastBuffer = function (count) {
  if (count &lt; 0) { throw new ArgumentOutOfRangeError(); }
  var source = this;
  return new AnonymousObservable(function (o) {
    return source.subscribe(new TakeLastBufferObserver(o, count));
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeLastBufferWithTime" id="apidoc.element.rx.Observable.prototype.takeLastBufferWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLastBufferWithTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLastBufferWithTime = function (duration, scheduler) {
  var source = this;
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new AnonymousObservable(function (o) {
    var q = [];
    return source.subscribe(function (x) {
      var now = scheduler.now();
      q.push({ interval: now, value: x });
      while (q.length &gt; 0 &amp;&amp; now - q[0].interval &gt;= duration) {
        q.shift();
      }
    }, function (e) { o.onError(e); }, function () {
      var now = scheduler.now(), res = [];
      while (q.length &gt; 0) {
        var next = q.shift();
        now - next.interval &lt;= duration &amp;&amp; res.push(next.value);
      }
      o.onNext(res);
      o.onCompleted();
    });
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeLastWithTime" id="apidoc.element.rx.Observable.prototype.takeLastWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeLastWithTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLastWithTime = function (duration, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new TakeLastWithTimeObservable(this, duration, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeUntil" id="apidoc.element.rx.Observable.prototype.takeUntil">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeUntil
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeUntil = function (other) {
  return new TakeUntilObservable(this, other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * See http://jort.technology/ for full details.
 * @returns {Observable} An observable which has a single value of true if sorted, else false.
 */
observableProto.jortSortUntil = function (other) {
  var source = this;
  return new AnonymousObservable(function (observer) {
    var arr = [];
    return source.<span class="apidocCodeKeywordSpan">takeUntil</span>(other).subscribe(
      arr.push.bind(arr),
      observer.onError.bind(observer),
      function () {
        var sorted = arr.slice(0).sort(defaultSubComparer);
        observer.onNext(isEqual(arr, sorted));
        observer.onCompleted();
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeUntilWithTime" id="apidoc.element.rx.Observable.prototype.takeUntilWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeUntilWithTime
        <span class="apidocSignatureSpan">(endTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeUntilWithTime = function (endTime, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  var source = this;
  return new AnonymousObservable(function (o) {
    return new BinaryDisposable(
      scheduler.scheduleFuture(o, endTime, function (_, o) { o.onCompleted(); }),
      source.subscribe(o));
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeWhile" id="apidoc.element.rx.Observable.prototype.takeWhile">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeWhile
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeWhile = function (predicate, thisArg) {
  var fn = bindCallback(predicate, thisArg, 3);
  return new TakeWhileObservable(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.takeWithTime" id="apidoc.element.rx.Observable.prototype.takeWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>takeWithTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeWithTime = function (duration, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new TakeWithTimeObservable(this, duration, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return TakeWithTimeObservable;
}(ObservableBase));

/**
 *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to
 run timers.
 *
 * @example
 *  1 - res = source.<span class="apidocCodeKeywordSpan">takeWithTime</span>(5000,  [optional scheduler]);
 * @description
 *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
 *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
 *  result sequence. This causes elements to be delayed with duration.
 * @param {Number} duration Duration for taking elements from the start of the sequence.
 * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
 * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source
 sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.tap" id="apidoc.element.rx.Observable.prototype.tap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tap
        <span class="apidocSignatureSpan">(observerOrOnNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tap = function (observerOrOnNext, onError, onCompleted) {
  return new TapObservable(this, observerOrOnNext, onError, onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  Invokes an action for each element in the observable sequence.
*  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions
 for messages on the pipeline.
* @param {Function} onNext Action to invoke for each element in the observable sequence.
* @param {Any} [thisArg] Object to use as this when executing callback.
* @returns {Observable} The source sequence with the side-effecting behavior applied.
*/
observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
  return this.<span class="apidocCodeKeywordSpan">tap</span>(typeof thisArg !== 'undefined' ? function (x) { onNext.call
(thisArg, x); } : onNext);
};

/**
*  Invokes an action upon exceptional termination of the observable sequence.
*  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions
 for messages on the pipeline.
* @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.
* @param {Any} [thisArg] Object to use as this when executing callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.tapOnCompleted" id="apidoc.element.rx.Observable.prototype.tapOnCompleted">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tapOnCompleted
        <span class="apidocSignatureSpan">(onCompleted, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tapOnCompleted = function (onCompleted, thisArg) {
  return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () { onCompleted.call(thisArg); } : onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.tapOnError" id="apidoc.element.rx.Observable.prototype.tapOnError">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tapOnError
        <span class="apidocSignatureSpan">(onError, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tapOnError = function (onError, thisArg) {
  return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) { onError.call(thisArg, e); } : onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.tapOnNext" id="apidoc.element.rx.Observable.prototype.tapOnNext">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>tapOnNext
        <span class="apidocSignatureSpan">(onNext, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tapOnNext = function (onNext, thisArg) {
  return this.tap(typeof thisArg !== 'undefined' ? function (x) { onNext.call(thisArg, x); } : onNext);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.thenDo" id="apidoc.element.rx.Observable.prototype.thenDo">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>thenDo
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thenDo = function (selector) {
  return new Pattern([this]).thenDo(selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 *  Matches when the observable sequence has an available value and projects the value.
 *
 *  @param {Function} selector Selector that will be invoked for values in the source sequence.
 *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
 */
observableProto.thenDo = function (selector) {
  return new Pattern([this]).<span class="apidocCodeKeywordSpan">thenDo</span>(selector);
};

/**
 *  Joins together the results from several patterns.
 *
 *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns
.
 *  @returns {Observable} Observable sequence with the results form matching several patterns.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.throttle" id="apidoc.element.rx.Observable.prototype.throttle">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>throttle
        <span class="apidocSignatureSpan">(windowDuration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throttle = function (windowDuration, scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  var duration = +windowDuration || 0;
  if (duration &lt;= 0) { throw new RangeError('windowDuration cannot be less or equal zero.'); }
  var source = this;
  return new AnonymousObservable(function (o) {
    var lastOnNext = 0;
    return source.subscribe(
      function (x) {
        var now = scheduler.now();
        if (lastOnNext === 0 || now - lastOnNext &gt;= duration) {
          lastOnNext = now;
          o.onNext(x);
        }
      },function (e) { o.onError(e); }, function () { o.onCompleted(); }
    );
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.timeInterval" id="apidoc.element.rx.Observable.prototype.timeInterval">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>timeInterval
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeInterval = function (scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new TimeIntervalObservable(this, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return TimeIntervalObserver;
}(AbstractObserver));

/**
 *  Records the time interval between consecutive values in an observable sequence.
 *
 * @example
 *  1 - res = source.<span class="apidocCodeKeywordSpan">timeInterval</span>();
 *  2 - res = source.timeInterval(Rx.Scheduler.timeout);
 *
 * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.
 * @returns {Observable} An observable sequence with time interval information on values.
 */
observableProto.timeInterval = function (scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.timeout" id="apidoc.element.rx.Observable.prototype.timeout">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>timeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeout = function () {
  var firstArg = arguments[0];
  if (firstArg instanceof Date || typeof firstArg === 'number') {
    return timeout(this, firstArg, arguments[1], arguments[2]);
  } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
    return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);
  } else {
    throw new Error('Invalid arguments');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.timestamp" id="apidoc.element.rx.Observable.prototype.timestamp">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>timestamp
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timestamp = function (scheduler) {
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new TimestampObservable(this, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new AnonymousObservable(function (o) {
var active = false,
  cancelable = new SerialDisposable(),
  exception = null,
  q = [],
  running = false,
  subscription;
subscription = source.materialize().<span class="apidocCodeKeywordSpan">timestamp</span>(scheduler).subscribe(function (notification
) {
  var d, shouldRun;
  if (notification.value.kind === 'E') {
    q = [];
    q.push(notification);
    exception = notification.value.error;
    shouldRun = !running;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.toArray" id="apidoc.element.rx.Observable.prototype.toArray">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return new ToArrayObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Hides the identity of an observable sequence.
 * @returns {Observable} An observable sequence that hides the identity of the source sequence.
 */
observableProto.asObservable = function () {
  return new AnonymousObservable(asObservable(this), this);
};

function toArray(x) { return x.<span class="apidocCodeKeywordSpan">toArray</span>(); }
function notEmpty(x) { return x.length &gt; 0; }

/**
 *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information
.
 * @param {Number} count Length of each buffer.
 * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count
.
 * @returns {Observable} An observable sequence of buffers.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.toMap" id="apidoc.element.rx.Observable.prototype.toMap">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toMap
        <span class="apidocSignatureSpan">(keySelector, elementSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toMap = function (keySelector, elementSelector) {
  if (typeof root.Map === 'undefined') { throw new TypeError(); }
  return new ToMapObservable(this, keySelector, elementSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.toPromise" id="apidoc.element.rx.Observable.prototype.toPromise">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toPromise
        <span class="apidocSignatureSpan">(promiseCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPromise = function (promiseCtor) {
  promiseCtor || (promiseCtor = Rx.config.Promise);
  if (!promiseCtor) { throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise'); }
  var source = this;
  return new promiseCtor(function (resolve, reject) {
    // No cancellation can be done
    var value;
    source.subscribe(function (v) {
      value = v;
    }, reject, function () {
      resolve(value);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  scheduler || (scheduler = defaultScheduler);
  return new FromPromiseObservable(promise, scheduler);
};

/*
 * Converts an existing observable sequence to an ES6 Compatible Promise
 * @example
 * var promise = Rx.Observable.return(42).<span class="apidocCodeKeywordSpan">toPromise</span>(RSVP.Promise);
 *
 * // With config
 * Rx.config.Promise = RSVP.Promise;
 * var promise = Rx.Observable.return(42).toPromise();
 * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
 * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.toSet" id="apidoc.element.rx.Observable.prototype.toSet">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>toSet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSet = function () {
  if (typeof root.Set === 'undefined') { throw new TypeError(); }
  return new ToSetObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.transduce" id="apidoc.element.rx.Observable.prototype.transduce">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>transduce
        <span class="apidocSignatureSpan">(transducer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transduce = function (transducer) {
  var source = this;
  return new AnonymousObservable(function(o) {
    var xform = transducer(transformForObserver(o));
    return source.subscribe(new TransduceObserver(o, xform));
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.where" id="apidoc.element.rx.Observable.prototype.where">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>where
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">where = function (predicate, thisArg) {
  return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) :
    new FilterObservable(this, predicate, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

export interface Observable&lt;T&gt; {
    /**
    *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
    *
    * @example
    *  var res = source.<span class="apidocCodeKeywordSpan">where</span>(function (value) { return value &lt; 10; });
    *  var res = source.where(function (value, index) { return value &lt; 10 || index &lt; 10; });
    * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents
 the index of the source element.
    * @param {Any} [thisArg] Object to use as this when executing callback.
    * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.
    */
    where(predicate: _Predicate&lt;T&gt;, thisArg?: any): Observable&lt;T&gt;;
    /**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.window" id="apidoc.element.rx.Observable.prototype.window">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>window
        <span class="apidocSignatureSpan">(windowOpeningsOrClosingSelector, windowClosingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {
  if (arguments.length === 1 &amp;&amp; typeof arguments[0] !== 'function') {
    return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
  }
  return typeof windowOpeningsOrClosingSelector === 'function' ?
    observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :
    observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.windowCount" id="apidoc.element.rx.Observable.prototype.windowCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowCount
        <span class="apidocSignatureSpan">(count, skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowCount = function (count, skip) {
  var source = this;
  +count || (count = 0);
  Math.abs(count) === Infinity &amp;&amp; (count = 0);
  if (count &lt;= 0) { throw new ArgumentOutOfRangeError(); }
  skip == null &amp;&amp; (skip = count);
  +skip || (skip = 0);
  Math.abs(skip) === Infinity &amp;&amp; (skip = 0);

  if (skip &lt;= 0) { throw new ArgumentOutOfRangeError(); }
  return new AnonymousObservable(function (observer) {
    var m = new SingleAssignmentDisposable(),
      refCountDisposable = new RefCountDisposable(m),
      n = 0,
      q = [];

    function createWindow () {
      var s = new Subject();
      q.push(s);
      observer.onNext(addRef(s, refCountDisposable));
    }

    createWindow();

    m.setDisposable(source.subscribe(
      function (x) {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onNext(x); }
        var c = n - count + 1;
        c &gt;= 0 &amp;&amp; c % skip === 0 &amp;&amp; q.shift().onCompleted();
        ++n % skip === 0 &amp;&amp; createWindow();
      },
      function (e) {
        while (q.length &gt; 0) { q.shift().onError(e); }
        observer.onError(e);
      },
      function () {
        while (q.length &gt; 0) { q.shift().onCompleted(); }
        observer.onCompleted();
      }
    ));
    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.windowTime" id="apidoc.element.rx.Observable.prototype.windowTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowTime
        <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
  var source = this, timeShift;
  timeShiftOrScheduler == null &amp;&amp; (timeShift = timeSpan);
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  if (typeof timeShiftOrScheduler === 'number') {
    timeShift = timeShiftOrScheduler;
  } else if (isScheduler(timeShiftOrScheduler)) {
    timeShift = timeSpan;
    scheduler = timeShiftOrScheduler;
  }
  return new AnonymousObservable(function (observer) {
    var groupDisposable,
      nextShift = timeShift,
      nextSpan = timeSpan,
      q = [],
      refCountDisposable,
      timerD = new SerialDisposable(),
      totalTime = 0;
      groupDisposable = new CompositeDisposable(timerD),
      refCountDisposable = new RefCountDisposable(groupDisposable);

     function createTimer () {
      var m = new SingleAssignmentDisposable(),
        isSpan = false,
        isShift = false;
      timerD.setDisposable(m);
      if (nextSpan === nextShift) {
        isSpan = true;
        isShift = true;
      } else if (nextSpan &lt; nextShift) {
          isSpan = true;
      } else {
        isShift = true;
      }
      var newTotalTime = isSpan ? nextSpan : nextShift,
        ts = newTotalTime - totalTime;
      totalTime = newTotalTime;
      if (isSpan) {
        nextSpan += timeShift;
      }
      if (isShift) {
        nextShift += timeShift;
      }
      m.setDisposable(scheduler.scheduleFuture(null, ts, function () {
        if (isShift) {
          var s = new Subject();
          q.push(s);
          observer.onNext(addRef(s, refCountDisposable));
        }
        isSpan &amp;&amp; q.shift().onCompleted();
        createTimer();
      }));
    };
    q.push(new Subject());
    observer.onNext(addRef(q[0], refCountDisposable));
    createTimer();
    groupDisposable.add(source.subscribe(
      function (x) {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onNext(x); }
      },
      function (e) {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onError(e); }
        observer.onError(e);
      },
      function () {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onCompleted(); }
        observer.onCompleted();
      }
    ));
    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.windowTimeOrCount" id="apidoc.element.rx.Observable.prototype.windowTimeOrCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowTimeOrCount
        <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowTimeOrCount = function (timeSpan, count, scheduler) {
  var source = this;
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new AnonymousObservable(function (observer) {
    var timerD = new SerialDisposable(),
        groupDisposable = new CompositeDisposable(timerD),
        refCountDisposable = new RefCountDisposable(groupDisposable),
        n = 0,
        windowId = 0,
        s = new Subject();

    function createTimer(id) {
      var m = new SingleAssignmentDisposable();
      timerD.setDisposable(m);
      m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {
        if (id !== windowId) { return; }
        n = 0;
        var newId = ++windowId;
        s.onCompleted();
        s = new Subject();
        observer.onNext(addRef(s, refCountDisposable));
        createTimer(newId);
      }));
    }

    observer.onNext(addRef(s, refCountDisposable));
    createTimer(0);

    groupDisposable.add(source.subscribe(
      function (x) {
        var newId = 0, newWindow = false;
        s.onNext(x);
        if (++n === count) {
          newWindow = true;
          n = 0;
          newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
        }
        newWindow &amp;&amp; createTimer(newId);
      },
      function (e) {
        s.onError(e);
        observer.onError(e);
      }, function () {
        s.onCompleted();
        observer.onCompleted();
      }
    ));
    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.windowWithCount" id="apidoc.element.rx.Observable.prototype.windowWithCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowWithCount
        <span class="apidocSignatureSpan">(count, skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowWithCount = function (count, skip) {
  var source = this;
  +count || (count = 0);
  Math.abs(count) === Infinity &amp;&amp; (count = 0);
  if (count &lt;= 0) { throw new ArgumentOutOfRangeError(); }
  skip == null &amp;&amp; (skip = count);
  +skip || (skip = 0);
  Math.abs(skip) === Infinity &amp;&amp; (skip = 0);

  if (skip &lt;= 0) { throw new ArgumentOutOfRangeError(); }
  return new AnonymousObservable(function (observer) {
    var m = new SingleAssignmentDisposable(),
      refCountDisposable = new RefCountDisposable(m),
      n = 0,
      q = [];

    function createWindow () {
      var s = new Subject();
      q.push(s);
      observer.onNext(addRef(s, refCountDisposable));
    }

    createWindow();

    m.setDisposable(source.subscribe(
      function (x) {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onNext(x); }
        var c = n - count + 1;
        c &gt;= 0 &amp;&amp; c % skip === 0 &amp;&amp; q.shift().onCompleted();
        ++n % skip === 0 &amp;&amp; createWindow();
      },
      function (e) {
        while (q.length &gt; 0) { q.shift().onError(e); }
        observer.onError(e);
      },
      function () {
        while (q.length &gt; 0) { q.shift().onCompleted(); }
        observer.onCompleted();
      }
    ));
    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information
.
 * @param {Number} count Length of each buffer.
 * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count
.
 * @returns {Observable} An observable sequence of buffers.
 */
observableProto.bufferWithCount = observableProto.bufferCount = function (count, skip) {
  typeof skip !== 'number' &amp;&amp; (skip = count);
  return this.<span class="apidocCodeKeywordSpan">windowWithCount</span>(count, skip)
    .flatMap(toArray)
    .filter(notEmpty);
};

var DematerializeObservable = (function (__super__) {
  inherits(DematerializeObservable, __super__);
  function DematerializeObservable(source) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.windowWithTime" id="apidoc.element.rx.Observable.prototype.windowWithTime">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowWithTime
        <span class="apidocSignatureSpan">(timeSpan, timeShiftOrScheduler, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
  var source = this, timeShift;
  timeShiftOrScheduler == null &amp;&amp; (timeShift = timeSpan);
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  if (typeof timeShiftOrScheduler === 'number') {
    timeShift = timeShiftOrScheduler;
  } else if (isScheduler(timeShiftOrScheduler)) {
    timeShift = timeSpan;
    scheduler = timeShiftOrScheduler;
  }
  return new AnonymousObservable(function (observer) {
    var groupDisposable,
      nextShift = timeShift,
      nextSpan = timeSpan,
      q = [],
      refCountDisposable,
      timerD = new SerialDisposable(),
      totalTime = 0;
      groupDisposable = new CompositeDisposable(timerD),
      refCountDisposable = new RefCountDisposable(groupDisposable);

     function createTimer () {
      var m = new SingleAssignmentDisposable(),
        isSpan = false,
        isShift = false;
      timerD.setDisposable(m);
      if (nextSpan === nextShift) {
        isSpan = true;
        isShift = true;
      } else if (nextSpan &lt; nextShift) {
          isSpan = true;
      } else {
        isShift = true;
      }
      var newTotalTime = isSpan ? nextSpan : nextShift,
        ts = newTotalTime - totalTime;
      totalTime = newTotalTime;
      if (isSpan) {
        nextSpan += timeShift;
      }
      if (isShift) {
        nextShift += timeShift;
      }
      m.setDisposable(scheduler.scheduleFuture(null, ts, function () {
        if (isShift) {
          var s = new Subject();
          q.push(s);
          observer.onNext(addRef(s, refCountDisposable));
        }
        isSpan &amp;&amp; q.shift().onCompleted();
        createTimer();
      }));
    };
    q.push(new Subject());
    observer.onNext(addRef(q[0], refCountDisposable));
    createTimer();
    groupDisposable.add(source.subscribe(
      function (x) {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onNext(x); }
      },
      function (e) {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onError(e); }
        observer.onError(e);
      },
      function () {
        for (var i = 0, len = q.length; i &lt; len; i++) { q[i].onCompleted(); }
        observer.onCompleted();
      }
    ));
    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
 * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).
 * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds
), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-
overlapping adjacent buffers.
 * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.
 * @returns {Observable} An observable sequence of buffers.
 */
observableProto.bufferWithTime = observableProto.bufferTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
  return this.<span class="apidocCodeKeywordSpan">windowWithTime</span>(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray
);
};

function toArray(x) { return x.toArray(); }

/**
 *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount
 of time has elapsed.
 * @param {Number} timeSpan Maximum time length of a buffer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.windowWithTimeOrCount" id="apidoc.element.rx.Observable.prototype.windowWithTimeOrCount">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>windowWithTimeOrCount
        <span class="apidocSignatureSpan">(timeSpan, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowWithTimeOrCount = function (timeSpan, count, scheduler) {
  var source = this;
  isScheduler(scheduler) || (scheduler = defaultScheduler);
  return new AnonymousObservable(function (observer) {
    var timerD = new SerialDisposable(),
        groupDisposable = new CompositeDisposable(timerD),
        refCountDisposable = new RefCountDisposable(groupDisposable),
        n = 0,
        windowId = 0,
        s = new Subject();

    function createTimer(id) {
      var m = new SingleAssignmentDisposable();
      timerD.setDisposable(m);
      m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {
        if (id !== windowId) { return; }
        n = 0;
        var newId = ++windowId;
        s.onCompleted();
        s = new Subject();
        observer.onNext(addRef(s, refCountDisposable));
        createTimer(newId);
      }));
    }

    observer.onNext(addRef(s, refCountDisposable));
    createTimer(0);

    groupDisposable.add(source.subscribe(
      function (x) {
        var newId = 0, newWindow = false;
        s.onNext(x);
        if (++n === count) {
          newWindow = true;
          n = 0;
          newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
        }
        newWindow &amp;&amp; createTimer(newId);
      },
      function (e) {
        s.onError(e);
        observer.onError(e);
      }, function () {
        s.onCompleted();
        observer.onCompleted();
      }
    ));
    return refCountDisposable;
  }, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount
 of time has elapsed.
 * @param {Number} timeSpan Maximum time length of a buffer.
 * @param {Number} count Maximum element count of a buffer.
 * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.
 * @returns {Observable} An observable sequence of buffers.
 */
observableProto.bufferWithTimeOrCount = observableProto.bufferTimeOrCount = function (timeSpan, count, scheduler) {
  return this.<span class="apidocCodeKeywordSpan">windowWithTimeOrCount</span>(timeSpan, count, scheduler).flatMap(toArray);
};

var TimeIntervalObservable = (function (__super__) {
  inherits(TimeIntervalObservable, __super__);
  function TimeIntervalObservable(source, s) {
    this.source = source;
    this._s = s;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.withLatestFrom" id="apidoc.element.rx.Observable.prototype.withLatestFrom">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>withLatestFrom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withLatestFrom = function () {
  if (arguments.length === 0) { throw new Error('invalid arguments'); }

  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
  Array.isArray(args[0]) &amp;&amp; (args = args[0]);

  return new WithLatestFromObservable(this, args, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.zip" id="apidoc.element.rx.Observable.prototype.zip">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  if (arguments.length === 0) { throw new Error('invalid arguments'); }

  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
  Array.isArray(args[0]) &amp;&amp; (args = args[0]);

  var parent = this;
  args.unshift(parent);

  return new ZipObservable(args, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observable.prototype.zipIterable" id="apidoc.element.rx.Observable.prototype.zipIterable">
        function <span class="apidocSignatureSpan">rx.Observable.prototype.</span>zipIterable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipIterable = function () {
  if (arguments.length === 0) { throw new Error('invalid arguments'); }

  var len = arguments.length, args = new Array(len);
  for(var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;

  var parent = this;
  args.unshift(parent);
  return new ZipIterableObservable(args, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ObservableBase" id="apidoc.module.rx.ObservableBase">module rx.ObservableBase</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ObservableBase.ObservableBase" id="apidoc.element.rx.ObservableBase.ObservableBase">
        function <span class="apidocSignatureSpan">rx.</span>ObservableBase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableBase() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ObservableBase.prototype" id="apidoc.module.rx.ObservableBase.prototype">module rx.ObservableBase.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ObservableBase.prototype._subscribe" id="apidoc.element.rx.ObservableBase.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.ObservableBase.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  var ado = new AutoDetachObserver(o), state = [ado, this];

  if (currentThreadScheduler.scheduleRequired()) {
    currentThreadScheduler.schedule(state, setDisposable);
  } else {
    setDisposable(null, state);
  }
  return ado;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ObservableBase.prototype.constructor" id="apidoc.element.rx.ObservableBase.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.ObservableBase.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableBase() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ObservableBase.prototype.subscribeCore" id="apidoc.element.rx.ObservableBase.prototype.subscribeCore">
        function <span class="apidocSignatureSpan">rx.ObservableBase.prototype.</span>subscribeCore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeCore = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Observer" id="apidoc.module.rx.Observer">module rx.Observer</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Observer.Observer" id="apidoc.element.rx.Observer.Observer">
        function <span class="apidocSignatureSpan">rx.</span>Observer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Observer = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer.create" id="apidoc.element.rx.Observer.create">
        function <span class="apidocSignatureSpan">rx.Observer.</span>create
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (onNext, onError, onCompleted) {
  onNext || (onNext = noop);
  onError || (onError = defaultError);
  onCompleted || (onCompleted = noop);
  return new AnonymousObserver(onNext, onError, onCompleted);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  root.CustomEvent = CustomEvent;
}());

var EmptyError = Rx.EmptyError = function() {
  this.message = 'Sequence contains no elements.';
  Error.call(this);
};
EmptyError.prototype = Object.<span class="apidocCodeKeywordSpan">create</span>(Error.prototype);
EmptyError.prototype.name = 'EmptyError';

var ObjectDisposedError = Rx.ObjectDisposedError = function() {
  this.message = 'Object has been disposed';
  Error.call(this);
};
ObjectDisposedError.prototype = Object.create(Error.prototype);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer.fromNotifier" id="apidoc.element.rx.Observer.fromNotifier">
        function <span class="apidocSignatureSpan">rx.Observer.</span>fromNotifier
        <span class="apidocSignatureSpan">(handler, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromNotifier = function (handler, thisArg) {
  var cb = bindCallback(handler, thisArg, 1);
  return new AnonymousObserver(function (x) {
    return cb(notificationCreateOnNext(x));
  }, function (e) {
    return cb(notificationCreateOnError(e));
  }, function () {
    return cb(notificationCreateOnCompleted());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Observer.prototype" id="apidoc.module.rx.Observer.prototype">module rx.Observer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Observer.prototype.asObserver" id="apidoc.element.rx.Observer.prototype.asObserver">
        function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>asObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObserver = function () {
  var self = this;
  return new AnonymousObserver(
    function (x) { self.onNext(x); },
    function (err) { self.onError(err); },
    function () { self.onCompleted(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">asObserver</span>();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer.prototype.checked" id="apidoc.element.rx.Observer.prototype.checked">
        function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>checked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checked = function () { return new CheckedObserver(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">checked</span>();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer.prototype.makeSafe" id="apidoc.element.rx.Observer.prototype.makeSafe">
        function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>makeSafe
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSafe = function (disposable) {
  return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	export interface Observer&lt;T&gt; {
        makeSafe(disposable: IDisposable): Observer&lt;T&gt;;
	}
}

(function() {
    var observer: Rx.Observer&lt;boolean&gt;;
	observer = observer.<span class="apidocCodeKeywordSpan">makeSafe</span>(Rx.Disposable.create(() =&gt; {}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer.prototype.notifyOn" id="apidoc.element.rx.Observer.prototype.notifyOn">
        function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>notifyOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyOn = function (scheduler) {
  return new ObserveOnObserver(scheduler, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.<span class="apidocCodeKeywordSpan">notifyOn</span>(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Observer.prototype.toNotifier" id="apidoc.element.rx.Observer.prototype.toNotifier">
        function <span class="apidocSignatureSpan">rx.Observer.prototype.</span>toNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNotifier = function () {
  var observer = this;
  return function (n) { return n.accept(observer); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		fromNotifier&lt;T&gt;(handler: (notification: Notification&lt;T&gt;, thisArg?: any) =&gt; void): Observer&lt;T&gt;
;;
	}
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.<span class="apidocCodeKeywordSpan">toNotifier
</span>();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Pauser" id="apidoc.module.rx.Pauser">module rx.Pauser</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Pauser.Pauser" id="apidoc.element.rx.Pauser.Pauser">
        function <span class="apidocSignatureSpan">rx.</span>Pauser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pauser() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Pauser.prototype" id="apidoc.module.rx.Pauser.prototype">module rx.Pauser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Pauser.prototype.constructor" id="apidoc.element.rx.Pauser.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.Pauser.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pauser() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Pauser.prototype.pause" id="apidoc.element.rx.Pauser.prototype.pause">
        function <span class="apidocSignatureSpan">rx.Pauser.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () { this.onNext(false); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  source.resume();
}

dest.addListener('drain', onDrain);

source.subscribe(
  function (x) {
    !dest.write(x) &amp;&amp; source.<span class="apidocCodeKeywordSpan">pause</span>();
  },
  function (err) {
    dest.emit('error', err);
  },
  function () {
    // Hack check because STDIO is not closable
    !dest._isStdio &amp;&amp; dest.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Pauser.prototype.resume" id="apidoc.element.rx.Pauser.prototype.resume">
        function <span class="apidocSignatureSpan">rx.Pauser.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () { this.onNext(true); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Stream} dest The destination Node.js stream.
   * @returns {Stream} The destination stream.
   */
  observableProto.pipe = function (dest) {
var source = this.pausableBuffered();

function onDrain() {
  source.<span class="apidocCodeKeywordSpan">resume</span>();
}

dest.addListener('drain', onDrain);

source.subscribe(
  function (x) {
    !dest.write(x) &amp;&amp; source.pause();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ReactiveTest" id="apidoc.module.rx.ReactiveTest">module rx.ReactiveTest</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ReactiveTest.onCompleted" id="apidoc.element.rx.ReactiveTest.onCompleted">
        function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>onCompleted
        <span class="apidocSignatureSpan">(ticks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function (ticks) {
  return new Recorded(ticks, Notification.createOnCompleted());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReactiveTest.onError" id="apidoc.element.rx.ReactiveTest.onError">
        function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>onError
        <span class="apidocSignatureSpan">(ticks, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (ticks, error) {
  return typeof error === 'function' ?
    new Recorded(ticks, new OnErrorPredicate(error)) :
    new Recorded(ticks, Notification.createOnError(error));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReactiveTest.onNext" id="apidoc.element.rx.ReactiveTest.onNext">
        function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>onNext
        <span class="apidocSignatureSpan">(ticks, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (ticks, value) {
  return typeof value === 'function' ?
    new Recorded(ticks, new OnNextPredicate(value)) :
    new Recorded(ticks, Notification.createOnNext(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReactiveTest.subscribe" id="apidoc.element.rx.ReactiveTest.subscribe">
        function <span class="apidocSignatureSpan">rx.ReactiveTest.</span>subscribe
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (start, end) {
  return new Subscription(start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Observable} An Observable sequence which contains items that the callback does not return truthy for.
 */
Rx.Observable.prototype.reject = function (callback, thisArg) {
callback || (callback = Rx.helpers.identity);
var source = this;
return new Rx.AnonymousObservable(function (observer) {
  var i = 0;
  return source.<span class="apidocCodeKeywordSpan">subscribe</span>(
    function (x) {
      var noYield = true;
      try {
        noYield = callback.call(thisArg, x, i++, source);
      } catch (e) {
        observer.onError(e);
        return;
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Recorded" id="apidoc.module.rx.Recorded">module rx.Recorded</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Recorded.Recorded" id="apidoc.element.rx.Recorded.Recorded">
        function <span class="apidocSignatureSpan">rx.</span>Recorded
        <span class="apidocSignatureSpan">(time, value, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Recorded = function (time, value, comparer) {
  this.time = time;
  this.value = value;
  this.comparer = comparer || defaultComparer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Recorded.prototype" id="apidoc.module.rx.Recorded.prototype">module rx.Recorded.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Recorded.prototype.equals" id="apidoc.element.rx.Recorded.prototype.equals">
        function <span class="apidocSignatureSpan">rx.Recorded.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return this.time === other.time &amp;&amp; this.comparer(this.value, other.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Recorded.prototype.toString" id="apidoc.element.rx.Recorded.prototype.toString">
        function <span class="apidocSignatureSpan">rx.Recorded.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.value.toString() + '@' + this.time;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Defaults
var noop = Rx.helpers.noop = function () { },
  identity = Rx.helpers.identity = function (x) { return x; },
  defaultNow = Rx.helpers.defaultNow = (function () { return !!Date.now ? Date.now : function () { return +new Date; }; }()),
  defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },
  defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x &gt; y ? 1 : (x &lt; y ? -1 : 0); },
  defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.<span class="apidocCodeKeywordSpan">toString<!--
span-->(); },
  defaultError = Rx.helpers.defaultError = function (err) { throw err; },
  isPromise = Rx.helpers.isPromise = function (p) { return !!p &amp;&amp; typeof p.subscribe !== 'function' &amp;&amp;#
x26; typeof p.then === 'function'; },
  isFunction = Rx.helpers.isFunction = (function () {
    var isFn = function (value) {
      return typeof value == 'function' || false;
    };
...</span></pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.RefCountDisposable" id="apidoc.module.rx.RefCountDisposable">module rx.RefCountDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.RefCountDisposable.RefCountDisposable" id="apidoc.element.rx.RefCountDisposable.RefCountDisposable">
        function <span class="apidocSignatureSpan">rx.</span>RefCountDisposable
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RefCountDisposable(disposable) {
  this.underlyingDisposable = disposable;
  this.isDisposed = false;
  this.isPrimaryDisposed = false;
  this.count = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.RefCountDisposable.prototype" id="apidoc.module.rx.RefCountDisposable.prototype">module rx.RefCountDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.RefCountDisposable.prototype.dispose" id="apidoc.element.rx.RefCountDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.RefCountDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed &amp;&amp; !this.isPrimaryDisposed) {
    this.isPrimaryDisposed = true;
    if (this.count === 0) {
      this.isDisposed = true;
      this.underlyingDisposable.dispose();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.RefCountDisposable.prototype.getDisposable" id="apidoc.element.rx.RefCountDisposable.prototype.getDisposable">
        function <span class="apidocSignatureSpan">rx.RefCountDisposable.prototype.</span>getDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDisposable = function () {
  return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
};

// Rx Utils
var addRef = Rx.internals.addRef = function (xs, r) {
  return new AnonymousObservable(function (observer) {
    return new BinaryDisposable(r.<span class="apidocCodeKeywordSpan">getDisposable</span>(), xs.subscribe(observer));
  });
};

function arrayInitialize(count, factory) {
  var a = new Array(count);
  for (var i = 0; i &lt; count; i++) {
    a[i] = factory();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ReplaySubject" id="apidoc.module.rx.ReplaySubject">module rx.ReplaySubject</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.ReplaySubject" id="apidoc.element.rx.ReplaySubject.ReplaySubject">
        function <span class="apidocSignatureSpan">rx.</span>ReplaySubject
        <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowSize, scheduler) {
  this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
  this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
  this.scheduler = scheduler || currentThreadScheduler;
  this.q = [];
  this.observers = [];
  this.isStopped = false;
  this.isDisposed = false;
  this.hasError = false;
  this.error = null;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.ReplaySubject.prototype" id="apidoc.module.rx.ReplaySubject.prototype">module rx.ReplaySubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype._subscribe" id="apidoc.element.rx.ReplaySubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  checkDisposed(this);
  var so = new ScheduledObserver(this.scheduler, o), subscription = createRemovableDisposable(this, so);

  this._trim(this.scheduler.now());
  this.observers.push(so);

  for (var i = 0, len = this.q.length; i &lt; len; i++) {
    so.onNext(this.q[i].value);
  }

  if (this.hasError) {
    so.onError(this.error);
  } else if (this.isStopped) {
    so.onCompleted();
  }

  so.ensureActive();
  return subscription;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype._trim" id="apidoc.element.rx.ReplaySubject.prototype._trim">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>_trim
        <span class="apidocSignatureSpan">(now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trim = function (now) {
  while (this.q.length &gt; this.bufferSize) {
    this.q.shift();
  }
  while (this.q.length &gt; 0 &amp;&amp; (now - this.q[0].interval) &gt; this.windowSize) {
    this.q.shift();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    addProperties(ReplaySubject.prototype, Observer.prototype, {
      _subscribe: function (o) {
checkDisposed(this);
var so = new ScheduledObserver(this.scheduler, o), subscription = createRemovableDisposable(this, so);

this.<span class="apidocCodeKeywordSpan">_trim</span>(this.scheduler.now());
this.observers.push(so);

for (var i = 0, len = this.q.length; i &lt; len; i++) {
  so.onNext(this.q[i].value);
}

if (this.hasError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.asObserver" id="apidoc.element.rx.ReplaySubject.prototype.asObserver">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>asObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObserver = function () {
  var self = this;
  return new AnonymousObserver(
    function (x) { self.onNext(x); },
    function (err) { self.onError(err); },
    function () { self.onCompleted(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">asObserver</span>();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.checked" id="apidoc.element.rx.ReplaySubject.prototype.checked">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>checked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checked = function () { return new CheckedObserver(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">checked</span>();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.constructor" id="apidoc.element.rx.ReplaySubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowSize, scheduler) {
  this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
  this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
  this.scheduler = scheduler || currentThreadScheduler;
  this.q = [];
  this.observers = [];
  this.isStopped = false;
  this.isDisposed = false;
  this.hasError = false;
  this.error = null;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.dispose" id="apidoc.element.rx.ReplaySubject.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  this.isDisposed = true;
  this.observers = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.hasObservers" id="apidoc.element.rx.ReplaySubject.prototype.hasObservers">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>hasObservers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasObservers = function () { checkDisposed(this); return this.observers.length &gt; 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.makeSafe" id="apidoc.element.rx.ReplaySubject.prototype.makeSafe">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>makeSafe
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSafe = function (disposable) {
  return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	export interface Observer&lt;T&gt; {
        makeSafe(disposable: IDisposable): Observer&lt;T&gt;;
	}
}

(function() {
    var observer: Rx.Observer&lt;boolean&gt;;
	observer = observer.<span class="apidocCodeKeywordSpan">makeSafe</span>(Rx.Disposable.create(() =&gt; {}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.notifyOn" id="apidoc.element.rx.ReplaySubject.prototype.notifyOn">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>notifyOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyOn = function (scheduler) {
  return new ObserveOnObserver(scheduler, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.<span class="apidocCodeKeywordSpan">notifyOn</span>(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.onCompleted" id="apidoc.element.rx.ReplaySubject.prototype.onCompleted">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>onCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function () {
  checkDisposed(this);
  if (this.isStopped) { return; }
  this.isStopped = true;
  var now = this.scheduler.now();
  this._trim(now);
  for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
    var observer = os[i];
    observer.onCompleted();
    observer.ensureActive();
  }
  this.observers.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.onError" id="apidoc.element.rx.ReplaySubject.prototype.onError">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
  checkDisposed(this);
  if (this.isStopped) { return; }
  this.isStopped = true;
  this.error = error;
  this.hasError = true;
  var now = this.scheduler.now();
  this._trim(now);
  for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
    var observer = os[i];
    observer.onError(error);
    observer.ensureActive();
  }
  this.observers.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.onNext" id="apidoc.element.rx.ReplaySubject.prototype.onNext">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>onNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (value) {
  checkDisposed(this);
  if (this.isStopped) { return; }
  var now = this.scheduler.now();
  this.q.push({ interval: now, value: value });
  this._trim(now);

  for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
    var observer = os[i];
    observer.onNext(value);
    observer.ensureActive();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.ReplaySubject.prototype.toNotifier" id="apidoc.element.rx.ReplaySubject.prototype.toNotifier">
        function <span class="apidocSignatureSpan">rx.ReplaySubject.prototype.</span>toNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNotifier = function () {
  var observer = this;
  return function (n) { return n.accept(observer); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		fromNotifier&lt;T&gt;(handler: (notification: Notification&lt;T&gt;, thisArg?: any) =&gt; void): Observer&lt;T&gt;
;;
	}
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.<span class="apidocCodeKeywordSpan">toNotifier
</span>();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Rx" id="apidoc.module.rx.Rx">module rx.Rx</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Rx.AnonymousObservable" id="apidoc.element.rx.Rx.AnonymousObservable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>AnonymousObservable
        <span class="apidocSignatureSpan">(subscribe, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObservable(subscribe, parent) {
  this.source = parent;
  this.__subscribe = subscribe;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} [callback] The function called per iteration.
 * @param {Any} [thisArg] The this binding of callback.
 * @returns {Observable} An Observable sequence which contains items that the callback does not return truthy for.
 */
Rx.Observable.prototype.reject = function (callback, thisArg) {
callback || (callback = Rx.helpers.identity);
var source = this;
return new Rx.<span class="apidocCodeKeywordSpan">AnonymousObservable</span>(function (observer) {
  var i = 0;
  return source.subscribe(
    function (x) {
      var noYield = true;
      try {
        noYield = callback.call(thisArg, x, i++, source);
      } catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.AnonymousObserver" id="apidoc.element.rx.Rx.AnonymousObserver">
        function <span class="apidocSignatureSpan">rx.Rx.</span>AnonymousObserver
        <span class="apidocSignatureSpan">(onNext, onError, onCompleted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousObserver(onNext, onError, onCompleted) {
  __super__.call(this);
  this._onNext = onNext;
  this._onError = onError;
  this._onCompleted = onCompleted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.AnonymousSubject" id="apidoc.element.rx.Rx.AnonymousSubject">
        function <span class="apidocSignatureSpan">rx.Rx.</span>AnonymousSubject
        <span class="apidocSignatureSpan">(observer, observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(observer, observable) {
  this.observer = observer;
  this.observable = observable;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.ArgumentOutOfRangeError" id="apidoc.element.rx.Rx.ArgumentOutOfRangeError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>ArgumentOutOfRangeError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ArgumentOutOfRangeError = function () {
  this.message = 'Argument out of range';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.
* @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.
* If omitted, this will emit the rest of the Observable object.
* @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.
*/
observableProto.slice = function (begin, end) {
  var start = begin || 0;
  if (start &lt; 0) { throw new Rx.<span class="apidocCodeKeywordSpan">ArgumentOutOfRangeError</span>(); }
  if (typeof end === 'number' &amp;&amp; end &lt; start) {
    throw new Rx.ArgumentOutOfRangeError();
  }
  return new SliceObservable(this, start, end);
};

var LastIndexOfObservable = (function (__super__) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.AsyncSubject" id="apidoc.element.rx.Rx.AsyncSubject">
        function <span class="apidocSignatureSpan">rx.Rx.</span>AsyncSubject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.hasValue = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.BehaviorSubject" id="apidoc.element.rx.Rx.BehaviorSubject">
        function <span class="apidocSignatureSpan">rx.Rx.</span>BehaviorSubject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(value) {
  __super__.call(this);
  this.value = value;
  this.observers = [];
  this.isDisposed = false;
  this.isStopped = false;
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.BinaryDisposable" id="apidoc.element.rx.Rx.BinaryDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>BinaryDisposable
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BinaryDisposable = function (first, second) {
  this._first = first;
  this._second = second;
  this.isDisposed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.CompositeDisposable" id="apidoc.element.rx.Rx.CompositeDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>CompositeDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompositeDisposable = function () {
  var args = [], i, len;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    len = arguments.length;
    args = new Array(len);
    for(i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  this.disposables = args;
  this.isDisposed = false;
  this.length = args.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.CompositeError" id="apidoc.element.rx.Rx.CompositeError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>CompositeError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompositeError = function (errors) {
  this.innerErrors = errors;
  this.message = 'This contains multiple errors. Check the innerErrors';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.ConnectableObservable" id="apidoc.element.rx.Rx.ConnectableObservable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>ConnectableObservable
        <span class="apidocSignatureSpan">(source, subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subject) {
  this.source = source;
  this._connection = null;
  this._source = source.asObservable();
  this._subject = subject;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Disposable" id="apidoc.element.rx.Rx.Disposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Disposable
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Disposable = function (action) {
  this.isDisposed = false;
  this.action = action || noop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.EmptyError" id="apidoc.element.rx.Rx.EmptyError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>EmptyError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EmptyError = function () {
  this.message = 'Sequence contains no elements.';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.FlatMapObservable" id="apidoc.element.rx.Rx.FlatMapObservable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>FlatMapObservable
        <span class="apidocSignatureSpan">(source, selector, resultSelector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FlatMapObservable(source, selector, resultSelector, thisArg) {
  this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
  this.selector = bindCallback(isFunction(selector) ? selector : function() { return selector; }, thisArg, 3);
  this.source = source;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.HistoricalScheduler" id="apidoc.element.rx.Rx.HistoricalScheduler">
        function <span class="apidocSignatureSpan">rx.Rx.</span>HistoricalScheduler
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HistoricalScheduler(initialClock, comparer) {
  var clock = initialClock == null ? 0 : initialClock;
  var cmp = comparer || defaultSubComparer;
  __super__.call(this, clock, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * @param {Function} comparer Comparer to determine causality of events based on absolute time.
         */
        new (initialClock: number, comparer: _Comparer&lt;number, number&gt;): HistoricalScheduler;
    };
}

(function() {
    var a: Rx.HistoricalScheduler = new Rx.<span class="apidocCodeKeywordSpan">HistoricalScheduler</span>(1, (a, b) =&gt; 1);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.MockDisposable" id="apidoc.element.rx.Rx.MockDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>MockDisposable
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MockDisposable = function (scheduler) {
  this.scheduler = scheduler;
  this.disposes = [];
  this.disposes.push(this.scheduler.clock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.NAryDisposable" id="apidoc.element.rx.Rx.NAryDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>NAryDisposable
        <span class="apidocSignatureSpan">(disposables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NAryDisposable = function (disposables) {
  this._disposables = disposables;
  this.isDisposed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.NotImplementedError" id="apidoc.element.rx.Rx.NotImplementedError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>NotImplementedError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotImplementedError = function (message) {
  this.message = message || 'This operation is not implemented';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.NotSupportedError" id="apidoc.element.rx.Rx.NotSupportedError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>NotSupportedError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotSupportedError = function (message) {
  this.message = message || 'This operation is not supported';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Notification" id="apidoc.element.rx.Rx.Notification">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Notification
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Notification() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.ObjectDisposedError" id="apidoc.element.rx.Rx.ObjectDisposedError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>ObjectDisposedError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ObjectDisposedError = function () {
  this.message = 'Object has been disposed';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Observable" id="apidoc.element.rx.Rx.Observable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Observable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable() {
  if (Rx.config.longStackSupport &amp;&amp; hasStacks) {
    var oldSubscribe = this._subscribe;
    var e = tryCatch(thrower)(new Error()).e;
    this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
    this._subscribe = makeSubscribe(this, oldSubscribe);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.ObservableBase" id="apidoc.element.rx.Rx.ObservableBase">
        function <span class="apidocSignatureSpan">rx.Rx.</span>ObservableBase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableBase() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Observer" id="apidoc.element.rx.Rx.Observer">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Observer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Observer = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Pauser" id="apidoc.element.rx.Rx.Pauser">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Pauser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pauser() {
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Recorded" id="apidoc.element.rx.Rx.Recorded">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Recorded
        <span class="apidocSignatureSpan">(time, value, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Recorded = function (time, value, comparer) {
  this.time = time;
  this.value = value;
  this.comparer = comparer || defaultComparer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.RefCountDisposable" id="apidoc.element.rx.Rx.RefCountDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>RefCountDisposable
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RefCountDisposable(disposable) {
  this.underlyingDisposable = disposable;
  this.isDisposed = false;
  this.isPrimaryDisposed = false;
  this.count = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.ReplaySubject" id="apidoc.element.rx.Rx.ReplaySubject">
        function <span class="apidocSignatureSpan">rx.Rx.</span>ReplaySubject
        <span class="apidocSignatureSpan">(bufferSize, windowSize, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowSize, scheduler) {
  this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
  this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
  this.scheduler = scheduler || currentThreadScheduler;
  this.q = [];
  this.observers = [];
  this.isStopped = false;
  this.isDisposed = false;
  this.hasError = false;
  this.error = null;
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Scheduler" id="apidoc.element.rx.Rx.Scheduler">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Scheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scheduler() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.SerialDisposable" id="apidoc.element.rx.Rx.SerialDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>SerialDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialDisposable = function () {
  this.isDisposed = false;
  this.current = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.SingleAssignmentDisposable" id="apidoc.element.rx.Rx.SingleAssignmentDisposable">
        function <span class="apidocSignatureSpan">rx.Rx.</span>SingleAssignmentDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SingleAssignmentDisposable = function () {
  this.isDisposed = false;
  this.current = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Subject" id="apidoc.element.rx.Rx.Subject">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Subject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return PausableObservable;

}(Observable));

/**
 * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
 * @example
 * var pauser = new Rx.<span class="apidocCodeKeywordSpan">Subject</span>();
 * var source = Rx.Observable.interval(100).pausable(pauser);
 * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
 * @returns {Observable} The observable sequence which is paused based upon the pauser.
 */
observableProto.pausable = function (pauser) {
  return new PausableObservable(this, pauser);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.Subscription" id="apidoc.element.rx.Rx.Subscription">
        function <span class="apidocSignatureSpan">rx.Rx.</span>Subscription
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (start, end) {
  this.subscribe = start;
  this.unsubscribe = end || Number.MAX_VALUE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.TestScheduler" id="apidoc.element.rx.Rx.TestScheduler">
        function <span class="apidocSignatureSpan">rx.Rx.</span>TestScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler() {
  __super__.call(this, 0, baseComparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.TimeoutError" id="apidoc.element.rx.Rx.TimeoutError">
        function <span class="apidocSignatureSpan">rx.Rx.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimeoutError = function (message) {
  this.message = message || 'Timeout has occurred';
  this.name = 'TimeoutError';
  Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Rx.VirtualTimeScheduler" id="apidoc.element.rx.Rx.VirtualTimeScheduler">
        function <span class="apidocSignatureSpan">rx.Rx.</span>VirtualTimeScheduler
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(initialClock, comparer) {
  this.clock = initialClock;
  this.comparer = comparer;
  this.isEnabled = false;
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Scheduler" id="apidoc.module.rx.Scheduler">module rx.Scheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Scheduler.Scheduler" id="apidoc.element.rx.Scheduler.Scheduler">
        function <span class="apidocSignatureSpan">rx.</span>Scheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scheduler() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.isScheduler" id="apidoc.element.rx.Scheduler.isScheduler">
        function <span class="apidocSignatureSpan">rx.Scheduler.</span>isScheduler
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isScheduler = function (s) {
  return s instanceof Scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.normalize" id="apidoc.element.rx.Scheduler.normalize">
        function <span class="apidocSignatureSpan">rx.Scheduler.</span>normalize
        <span class="apidocSignatureSpan">(timeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize = function (timeSpan) {
  timeSpan &lt; 0 &amp;&amp; (timeSpan = 0);
  return timeSpan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Function} action Action to be executed.
   * @param {Number} dueTime Relative time after which to execute the action.
   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
   */
schedulerProto.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime;
  dt instanceof Date &amp;&amp; (dt = dt - this.now());
  dt = Scheduler.<span class="apidocCodeKeywordSpan">normalize</span>(dt);

  if (dt === 0) { return this.schedule(state, action); }

  return this._scheduleFuture(state, dt, action);
};

schedulerProto._scheduleFuture = function (state, dueTime, action) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.now" id="apidoc.element.rx.Scheduler.now">
        function <span class="apidocSignatureSpan">rx.Scheduler.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param state State passed to the action to be executed.
   * @param {Function} action Action to be executed.
   * @param {Number} dueTime Relative time after which to execute the action.
   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
   */
schedulerProto.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime;
  dt instanceof Date &amp;&amp; (dt = dt - this.<span class="apidocCodeKeywordSpan">now</span>());
  dt = Scheduler.normalize(dt);

  if (dt === 0) { return this.schedule(state, action); }

  return this._scheduleFuture(state, dt, action);
};
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Scheduler.prototype" id="apidoc.module.rx.Scheduler.prototype">module rx.Scheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype._scheduleFuture" id="apidoc.element.rx.Scheduler.prototype._scheduleFuture">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>_scheduleFuture
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_scheduleFuture = function (state, dueTime, action) {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
schedulerProto.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime;
  dt instanceof Date &amp;&amp; (dt = dt - this.now());
  dt = Scheduler.normalize(dt);

  if (dt === 0) { return this.schedule(state, action); }

  return this.<span class="apidocCodeKeywordSpan">_scheduleFuture</span>(state, dt, action);
};

schedulerProto._scheduleFuture = function (state, dueTime, action) {
  throw new NotImplementedError();
};

/** Gets the current time according to the local machine's system clock. */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.catch" id="apidoc.element.rx.Scheduler.prototype.catch">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>catch
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (handler) {
  return new CatchScheduler(this, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.catchError" id="apidoc.element.rx.Scheduler.prototype.catchError">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>catchError
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchError = function (handler) {
  return new CatchScheduler(this, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (Array.isArray(arguments[0])) {
    items = arguments[0];
  } else {
    var len = arguments.length;
    items = new Array(len);
    for(var i = 0; i &lt; len; i++) { items[i] = arguments[i]; }
  }
  return enumerableOf(items).<span class="apidocCodeKeywordSpan">catchError</span>();
};

/**
 * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable
 sequences or Promises produces an element.
 * This can be in the form of an argument list of observables or an array.
 *
 * @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.now" id="apidoc.element.rx.Scheduler.prototype.now">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param state State passed to the action to be executed.
   * @param {Function} action Action to be executed.
   * @param {Number} dueTime Relative time after which to execute the action.
   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
   */
schedulerProto.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime;
  dt instanceof Date &amp;&amp; (dt = dt - this.<span class="apidocCodeKeywordSpan">now</span>());
  dt = Scheduler.normalize(dt);

  if (dt === 0) { return this.schedule(state, action); }

  return this._scheduleFuture(state, dt, action);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.schedule" id="apidoc.element.rx.Scheduler.prototype.schedule">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>schedule
        <span class="apidocSignatureSpan">(state, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedule = function (state, action) {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!self.isDisposed) {
    self.isDisposed = true;
    self.disposable.dispose();
  }
}

ScheduledDisposable.prototype.dispose = function () {
  this.scheduler.<span class="apidocCodeKeywordSpan">schedule</span>(this, scheduleItem);
};

var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
  this.scheduler = scheduler;
  this.state = state;
  this.action = action;
  this.dueTime = dueTime;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.scheduleFuture" id="apidoc.element.rx.Scheduler.prototype.scheduleFuture">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>scheduleFuture
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime;
  dt instanceof Date &amp;&amp; (dt = dt - this.now());
  dt = Scheduler.normalize(dt);

  if (dt === 0) { return this.schedule(state, action); }

  return this._scheduleFuture(state, dt, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var state = pair[0], action = pair[1], group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2, dueTime1) {
var isAdded = false, isDone = false;

var d = scheduler.<span class="apidocCodeKeywordSpan">scheduleFuture</span>(state2, dueTime1, scheduleWork);
if (!isDone) {
  group.add(d);
  isAdded = true;
}

function scheduleWork(_, state3) {
  if (isAdded) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.schedulePeriodic" id="apidoc.element.rx.Scheduler.prototype.schedulePeriodic">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>schedulePeriodic
        <span class="apidocSignatureSpan">(state, period, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedulePeriodic = function (state, period, action) {
  if (typeof root.setInterval === 'undefined') { throw new NotSupportedError(); }
  period = normalizeTime(period);
  var s = state, id = root.setInterval(function () { s = action(s); }, period);
  return disposableCreate(function () { root.clearInterval(id); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return this._recursiveWrapper;
    };

    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {
var self = this, failed = false, d = new SingleAssignmentDisposable();

d.setDisposable(this._scheduler.<span class="apidocCodeKeywordSpan">schedulePeriodic</span>(state, period, function (state1) {
  if (failed) { return null; }
  var res = tryCatch(action)(state1);
  if (res === errorObj) {
    failed = true;
    if (!self._handler(res.e)) { thrower(res.e); }
    d.dispose();
    return null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.scheduleRecursive" id="apidoc.element.rx.Scheduler.prototype.scheduleRecursive">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>scheduleRecursive
        <span class="apidocSignatureSpan">(state, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleRecursive = function (state, action) {
  return this.schedule([state, action], invokeRecImmediate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Rx.Observable.pairs = function (obj, scheduler) {
scheduler || (scheduler = Rx.Scheduler.currentThread);
return new Rx.AnonymousObservable(function (observer) {
  var keys = keysFunction(object),
      i = 0,
      len = keys.length;
  return scheduler.<span class="apidocCodeKeywordSpan">scheduleRecursive</span>(function (self) {
    if (i &lt; len) {
      var key = keys[i++], value = obj[key];
      observer.onNext([key, value]);
      self();
    } else {
      observer.onCompleted();
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Scheduler.prototype.scheduleRecursiveFuture" id="apidoc.element.rx.Scheduler.prototype.scheduleRecursiveFuture">
        function <span class="apidocSignatureSpan">rx.Scheduler.prototype.</span>scheduleRecursiveFuture
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleRecursiveFuture = function (state, dueTime, action) {
  return this.scheduleFuture([state, action], dueTime, invokeRecDate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._period = period;
    this._action = action;
  }

  SchedulePeriodicRecursive.prototype.start = function () {
    var d = new SingleAssignmentDisposable();
    this._cancel = d;
    d.setDisposable(this._scheduler.<span class="apidocCodeKeywordSpan">scheduleRecursiveFuture</span>(0, this._period, createTick
(this)));

    return d;
  };

  return SchedulePeriodicRecursive;
}());
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.SerialDisposable" id="apidoc.module.rx.SerialDisposable">module rx.SerialDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.SerialDisposable.SerialDisposable" id="apidoc.element.rx.SerialDisposable.SerialDisposable">
        function <span class="apidocSignatureSpan">rx.</span>SerialDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialDisposable = function () {
  this.isDisposed = false;
  this.current = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.SerialDisposable.prototype" id="apidoc.module.rx.SerialDisposable.prototype">module rx.SerialDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.SerialDisposable.prototype.dispose" id="apidoc.element.rx.SerialDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.SerialDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed) {
    this.isDisposed = true;
    var old = this.current;
    this.current = null;
  }
  old &amp;&amp; old.dispose();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.SerialDisposable.prototype.getDisposable" id="apidoc.element.rx.SerialDisposable.prototype.getDisposable">
        function <span class="apidocSignatureSpan">rx.SerialDisposable.prototype.</span>getDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDisposable = function () {
  return this.current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
};

// Rx Utils
var addRef = Rx.internals.addRef = function (xs, r) {
  return new AnonymousObservable(function (observer) {
    return new BinaryDisposable(r.<span class="apidocCodeKeywordSpan">getDisposable</span>(), xs.subscribe(observer));
  });
};

function arrayInitialize(count, factory) {
  var a = new Array(count);
  for (var i = 0; i &lt; count; i++) {
    a[i] = factory();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.SerialDisposable.prototype.setDisposable" id="apidoc.element.rx.SerialDisposable.prototype.setDisposable">
        function <span class="apidocSignatureSpan">rx.SerialDisposable.prototype.</span>setDisposable
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDisposable = function (value) {
  var shouldDispose = this.isDisposed;
  if (!shouldDispose) {
    var old = this.current;
    this.current = value;
  }
  old &amp;&amp; old.dispose();
  shouldDispose &amp;&amp; value &amp;&amp; value.dispose();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.action = action;
  this.dueTime = dueTime;
  this.comparer = comparer || defaultSubComparer;
  this.disposable = new SingleAssignmentDisposable();
};

ScheduledItem.prototype.invoke = function () {
  this.disposable.<span class="apidocCodeKeywordSpan">setDisposable</span>(this.invokeCore());
};

ScheduledItem.prototype.compareTo = function (other) {
  return this.comparer(this.dueTime, other.dueTime);
};

ScheduledItem.prototype.isCancelled = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.SingleAssignmentDisposable" id="apidoc.module.rx.SingleAssignmentDisposable">module rx.SingleAssignmentDisposable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.SingleAssignmentDisposable.SingleAssignmentDisposable" id="apidoc.element.rx.SingleAssignmentDisposable.SingleAssignmentDisposable">
        function <span class="apidocSignatureSpan">rx.</span>SingleAssignmentDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SingleAssignmentDisposable = function () {
  this.isDisposed = false;
  this.current = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.SingleAssignmentDisposable.prototype" id="apidoc.module.rx.SingleAssignmentDisposable.prototype">module rx.SingleAssignmentDisposable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.SingleAssignmentDisposable.prototype.dispose" id="apidoc.element.rx.SingleAssignmentDisposable.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.SingleAssignmentDisposable.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  if (!this.isDisposed) {
    this.isDisposed = true;
    var old = this.current;
    this.current = null;
    old &amp;&amp; old.dispose();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.SingleAssignmentDisposable.prototype.getDisposable" id="apidoc.element.rx.SingleAssignmentDisposable.prototype.getDisposable">
        function <span class="apidocSignatureSpan">rx.SingleAssignmentDisposable.prototype.</span>getDisposable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDisposable = function () {
  return this.current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
};

// Rx Utils
var addRef = Rx.internals.addRef = function (xs, r) {
  return new AnonymousObservable(function (observer) {
    return new BinaryDisposable(r.<span class="apidocCodeKeywordSpan">getDisposable</span>(), xs.subscribe(observer));
  });
};

function arrayInitialize(count, factory) {
  var a = new Array(count);
  for (var i = 0; i &lt; count; i++) {
    a[i] = factory();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.SingleAssignmentDisposable.prototype.setDisposable" id="apidoc.element.rx.SingleAssignmentDisposable.prototype.setDisposable">
        function <span class="apidocSignatureSpan">rx.SingleAssignmentDisposable.prototype.</span>setDisposable
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDisposable = function (value) {
  if (this.current) { throw new Error('Disposable has already been assigned'); }
  var shouldDispose = this.isDisposed;
  !shouldDispose &amp;&amp; (this.current = value);
  shouldDispose &amp;&amp; value &amp;&amp; value.dispose();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.action = action;
  this.dueTime = dueTime;
  this.comparer = comparer || defaultSubComparer;
  this.disposable = new SingleAssignmentDisposable();
};

ScheduledItem.prototype.invoke = function () {
  this.disposable.<span class="apidocCodeKeywordSpan">setDisposable</span>(this.invokeCore());
};

ScheduledItem.prototype.compareTo = function (other) {
  return this.comparer(this.dueTime, other.dueTime);
};

ScheduledItem.prototype.isCancelled = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Subject" id="apidoc.module.rx.Subject">module rx.Subject</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Subject.Subject" id="apidoc.element.rx.Subject.Subject">
        function <span class="apidocSignatureSpan">rx.</span>Subject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return PausableObservable;

}(Observable));

/**
 * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
 * @example
 * var pauser = new Rx.<span class="apidocCodeKeywordSpan">Subject</span>();
 * var source = Rx.Observable.interval(100).pausable(pauser);
 * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
 * @returns {Observable} The observable sequence which is paused based upon the pauser.
 */
observableProto.pausable = function (pauser) {
  return new PausableObservable(this, pauser);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.create" id="apidoc.element.rx.Subject.create">
        function <span class="apidocSignatureSpan">rx.Subject.</span>create
        <span class="apidocSignatureSpan">(observer, observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (observer, observable) {
  return new AnonymousSubject(observer, observable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  root.CustomEvent = CustomEvent;
}());

var EmptyError = Rx.EmptyError = function() {
  this.message = 'Sequence contains no elements.';
  Error.call(this);
};
EmptyError.prototype = Object.<span class="apidocCodeKeywordSpan">create</span>(Error.prototype);
EmptyError.prototype.name = 'EmptyError';

var ObjectDisposedError = Rx.ObjectDisposedError = function() {
  this.message = 'Object has been disposed';
  Error.call(this);
};
ObjectDisposedError.prototype = Object.create(Error.prototype);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Subject.prototype" id="apidoc.module.rx.Subject.prototype">module rx.Subject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Subject.prototype._subscribe" id="apidoc.element.rx.Subject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (o) {
  checkDisposed(this);
  if (!this.isStopped) {
    this.observers.push(o);
    return new InnerSubscription(this, o);
  }
  if (this.hasError) {
    o.onError(this.error);
    return disposableEmpty;
  }
  o.onCompleted();
  return disposableEmpty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  Subscribes an o to the observable sequence.
 *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable
 sequence.
 *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
 *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
 *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
 */
observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
  return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(typeof oOrOnNext === 'object' ?
    oOrOnNext :
    observerCreate(oOrOnNext, onError, onCompleted));
};

/**
 * Subscribes to the next value in the sequence with an optional "this" argument.
 * @param {Function} onNext The function to invoke on each element in the observable sequence.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.asObserver" id="apidoc.element.rx.Subject.prototype.asObserver">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>asObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObserver = function () {
  var self = this;
  return new AnonymousObserver(
    function (x) { self.onNext(x); },
    function (err) { self.onError(err); },
    function () { self.onCompleted(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">asObserver</span>();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.checked" id="apidoc.element.rx.Subject.prototype.checked">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>checked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checked = function () { return new CheckedObserver(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.<span class="apidocCodeKeywordSpan">checked</span>();

o = observer.notifyOn(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.constructor" id="apidoc.element.rx.Subject.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
  __super__.call(this);
  this.isDisposed = false;
  this.isStopped = false;
  this.observers = [];
  this.hasError = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.dispose" id="apidoc.element.rx.Subject.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  this.isDisposed = true;
  this.observers = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.hasObservers" id="apidoc.element.rx.Subject.prototype.hasObservers">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>hasObservers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasObservers = function () { checkDisposed(this); return this.observers.length &gt; 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.makeSafe" id="apidoc.element.rx.Subject.prototype.makeSafe">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>makeSafe
        <span class="apidocSignatureSpan">(disposable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSafe = function (disposable) {
  return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	export interface Observer&lt;T&gt; {
        makeSafe(disposable: IDisposable): Observer&lt;T&gt;;
	}
}

(function() {
    var observer: Rx.Observer&lt;boolean&gt;;
	observer = observer.<span class="apidocCodeKeywordSpan">makeSafe</span>(Rx.Disposable.create(() =&gt; {}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.notifyOn" id="apidoc.element.rx.Subject.prototype.notifyOn">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>notifyOn
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyOn = function (scheduler) {
  return new ObserveOnObserver(scheduler, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.toNotifier();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.<span class="apidocCodeKeywordSpan">notifyOn</span>(Rx.Scheduler.immediate);

var so : Rx.Observer&lt;number&gt; = Rx.Observer.fromNotifier&lt;number&gt;((n) =&gt; {
    // Handle next calls
    if (n.kind === 'N') {
        console.log('Next: ' + n.value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.onCompleted" id="apidoc.element.rx.Subject.prototype.onCompleted">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>onCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function () {
  checkDisposed(this);
  if (!this.isStopped) {
    this.isStopped = true;
    for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
      os[i].onCompleted();
    }

    this.observers.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.onError" id="apidoc.element.rx.Subject.prototype.onError">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
  checkDisposed(this);
  if (!this.isStopped) {
    this.isStopped = true;
    this.error = error;
    this.hasError = true;
    for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
      os[i].onError(error);
    }

    this.observers.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.onNext" id="apidoc.element.rx.Subject.prototype.onNext">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>onNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (value) {
  checkDisposed(this);
  if (!this.isStopped) {
    for (var i = 0, os = cloneArray(this.observers), len = os.length; i &lt; len; i++) {
      os[i].onNext(value);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subject.prototype.toNotifier" id="apidoc.element.rx.Subject.prototype.toNotifier">
        function <span class="apidocSignatureSpan">rx.Subject.prototype.</span>toNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNotifier = function () {
  var observer = this;
  return function (n) { return n.accept(observer); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		fromNotifier&lt;T&gt;(handler: (notification: Notification&lt;T&gt;, thisArg?: any) =&gt; void): Observer&lt;T&gt;
;;
	}
}


(function() {
var observer: Rx.Observer&lt;boolean&gt;;
var n: (notification: Rx.Notification&lt;boolean&gt;) =&gt; void = observer.<span class="apidocCodeKeywordSpan">toNotifier
</span>();

var o: Rx.Observer&lt;boolean&gt; = observer.asObserver();

var c: Rx.CheckedObserver&lt;boolean&gt; = observer.checked();

o = observer.notifyOn(Rx.Scheduler.immediate);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Subscription" id="apidoc.module.rx.Subscription">module rx.Subscription</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Subscription.Subscription" id="apidoc.element.rx.Subscription.Subscription">
        function <span class="apidocSignatureSpan">rx.</span>Subscription
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (start, end) {
  this.subscribe = start;
  this.unsubscribe = end || Number.MAX_VALUE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.Subscription.prototype" id="apidoc.module.rx.Subscription.prototype">module rx.Subscription.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.Subscription.prototype.equals" id="apidoc.element.rx.Subscription.prototype.equals">
        function <span class="apidocSignatureSpan">rx.Subscription.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return this.subscribe === other.subscribe &amp;&amp; this.unsubscribe === other.unsubscribe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.Subscription.prototype.toString" id="apidoc.element.rx.Subscription.prototype.toString">
        function <span class="apidocSignatureSpan">rx.Subscription.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Defaults
var noop = Rx.helpers.noop = function () { },
  identity = Rx.helpers.identity = function (x) { return x; },
  defaultNow = Rx.helpers.defaultNow = (function () { return !!Date.now ? Date.now : function () { return +new Date; }; }()),
  defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },
  defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x &gt; y ? 1 : (x &lt; y ? -1 : 0); },
  defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.<span class="apidocCodeKeywordSpan">toString<!--
span-->(); },
  defaultError = Rx.helpers.defaultError = function (err) { throw err; },
  isPromise = Rx.helpers.isPromise = function (p) { return !!p &amp;&amp; typeof p.subscribe !== 'function' &amp;&amp;#
x26; typeof p.then === 'function'; },
  isFunction = Rx.helpers.isFunction = (function () {
    var isFn = function (value) {
      return typeof value == 'function' || false;
    };
...</span></pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.TestScheduler" id="apidoc.module.rx.TestScheduler">module rx.TestScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rx.TestScheduler.TestScheduler" id="apidoc.element.rx.TestScheduler.TestScheduler">
        function <span class="apidocSignatureSpan">rx.</span>TestScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler() {
  __super__.call(this, 0, baseComparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.TestScheduler.prototype" id="apidoc.module.rx.TestScheduler.prototype">module rx.TestScheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.add" id="apidoc.element.rx.TestScheduler.prototype.add">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>add
        <span class="apidocSignatureSpan">(absolute, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (absolute, relative) {
  return absolute + relative;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ToSetObserver(o) {
  this._o = o;
  this._s = new root.Set();
  __super__.call(this);
}

ToSetObserver.prototype.next = function (x) {
  this._s.<span class="apidocCodeKeywordSpan">add</span>(x);
};

ToSetObserver.prototype.error = function (e) {
  this._o.onError(e);
};

ToSetObserver.prototype.completed = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.constructor" id="apidoc.element.rx.TestScheduler.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler() {
  __super__.call(this, 0, baseComparer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.createColdObservable" id="apidoc.element.rx.TestScheduler.prototype.createColdObservable">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createColdObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createColdObservable = function () {
  var len = arguments.length, args;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    args = new Array(len);
    for (var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  return new ColdObservable(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.createHotObservable" id="apidoc.element.rx.TestScheduler.prototype.createHotObservable">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createHotObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createHotObservable = function () {
  var len = arguments.length, args;
  if (Array.isArray(arguments[0])) {
    args = arguments[0];
  } else {
    args = new Array(len);
    for (var i = 0; i &lt; len; i++) { args[i] = arguments[i]; }
  }
  return new HotObservable(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.createObserver" id="apidoc.element.rx.TestScheduler.prototype.createObserver">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createObserver = function () {
  return new MockObserver(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    TestScheduler.prototype.startScheduler = function (createFn, settings) {
settings || (settings = {});
settings.created == null &amp;&amp; (settings.created = ReactiveTest.created);
settings.subscribed == null &amp;&amp; (settings.subscribed = ReactiveTest.subscribed);
settings.disposed == null &amp;&amp; (settings.disposed = ReactiveTest.disposed);

var observer = this.<span class="apidocCodeKeywordSpan">createObserver</span>(), source, subscription;

this.scheduleAbsolute(null, settings.created, function () {
  source = createFn();
  return disposableEmpty;
});

this.scheduleAbsolute(null, settings.subscribed, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.createRejectedPromise" id="apidoc.element.rx.TestScheduler.prototype.createRejectedPromise">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createRejectedPromise
        <span class="apidocSignatureSpan">(ticks, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRejectedPromise = function (ticks, reason) {
  return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.createResolvedPromise" id="apidoc.element.rx.TestScheduler.prototype.createResolvedPromise">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>createResolvedPromise
        <span class="apidocSignatureSpan">(ticks, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createResolvedPromise = function (ticks, value) {
  return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.scheduleAbsolute" id="apidoc.element.rx.TestScheduler.prototype.scheduleAbsolute">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>scheduleAbsolute
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleAbsolute = function (state, dueTime, action) {
  dueTime &lt;= this.clock &amp;&amp; (dueTime = this.clock + 1);
  return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

VirtualTimeSchedulerPrototype.now = function () {
  return this.toAbsoluteTime(this.clock);
};

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.<span class="apidocCodeKeywordSpan">scheduleAbsolute</span>(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.toRelativeTime(dueTime - this.now()) :
    this.toRelativeTime(dueTime);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.startScheduler" id="apidoc.element.rx.TestScheduler.prototype.startScheduler">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>startScheduler
        <span class="apidocSignatureSpan">(createFn, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startScheduler = function (createFn, settings) {
  settings || (settings = {});
  settings.created == null &amp;&amp; (settings.created = ReactiveTest.created);
  settings.subscribed == null &amp;&amp; (settings.subscribed = ReactiveTest.subscribed);
  settings.disposed == null &amp;&amp; (settings.disposed = ReactiveTest.disposed);

  var observer = this.createObserver(), source, subscription;

  this.scheduleAbsolute(null, settings.created, function () {
    source = createFn();
    return disposableEmpty;
  });

  this.scheduleAbsolute(null, settings.subscribed, function () {
    subscription = source.subscribe(observer);
    return disposableEmpty;
  });

  this.scheduleAbsolute(null, settings.disposed, function () {
    subscription.dispose();
    return disposableEmpty;
  });

  this.start();

  return observer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.toAbsoluteTime" id="apidoc.element.rx.TestScheduler.prototype.toAbsoluteTime">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>toAbsoluteTime
        <span class="apidocSignatureSpan">(absolute)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAbsoluteTime = function (absolute) {
  return new Date(absolute).getTime();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}

var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

VirtualTimeSchedulerPrototype.now = function () {
  return this.<span class="apidocCodeKeywordSpan">toAbsoluteTime</span>(this.clock);
};

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.TestScheduler.prototype.toRelativeTime" id="apidoc.element.rx.TestScheduler.prototype.toRelativeTime">
        function <span class="apidocSignatureSpan">rx.TestScheduler.prototype.</span>toRelativeTime
        <span class="apidocSignatureSpan">(timeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toRelativeTime = function (timeSpan) {
  return timeSpan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.<span class="apidocCodeKeywordSpan">toRelativeTime</span>(dueTime - this.now()) :
    this.toRelativeTime(dueTime);

  return this.scheduleRelative(state, dt, action);
};

/**
 * Adds a relative time value to an absolute time value.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.VirtualTimeScheduler" id="apidoc.module.rx.VirtualTimeScheduler">module rx.VirtualTimeScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.VirtualTimeScheduler" id="apidoc.element.rx.VirtualTimeScheduler.VirtualTimeScheduler">
        function <span class="apidocSignatureSpan">rx.</span>VirtualTimeScheduler
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(initialClock, comparer) {
  this.clock = initialClock;
  this.comparer = comparer;
  this.isEnabled = false;
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.VirtualTimeScheduler.prototype" id="apidoc.module.rx.VirtualTimeScheduler.prototype">module rx.VirtualTimeScheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.add" id="apidoc.element.rx.VirtualTimeScheduler.prototype.add">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ToSetObserver(o) {
  this._o = o;
  this._s = new root.Set();
  __super__.call(this);
}

ToSetObserver.prototype.next = function (x) {
  this._s.<span class="apidocCodeKeywordSpan">add</span>(x);
};

ToSetObserver.prototype.error = function (e) {
  this._o.onError(e);
};

ToSetObserver.prototype.completed = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.advanceBy" id="apidoc.element.rx.VirtualTimeScheduler.prototype.advanceBy">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>advanceBy
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advanceBy = function (time) {
  var dt = this.add(this.clock, time),
      dueToClock = this.comparer(this.clock, dt);
  if (dueToClock &gt; 0) { throw new ArgumentOutOfRangeError(); }
  if (dueToClock === 0) {  return; }

  this.advanceTo(dt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.advanceTo" id="apidoc.element.rx.VirtualTimeScheduler.prototype.advanceTo">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>advanceTo
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advanceTo = function (time) {
  var dueToClock = this.comparer(this.clock, time);
  if (this.comparer(this.clock, time) &gt; 0) { throw new ArgumentOutOfRangeError(); }
  if (dueToClock === 0) { return; }
  if (!this.isEnabled) {
    this.isEnabled = true;
    do {
      var next = this.getNext();
      if (next !== null &amp;&amp; this.comparer(next.dueTime, time) &lt;= 0) {
        this.comparer(next.dueTime, this.clock) &gt; 0 &amp;&amp; (this.clock = next.dueTime);
        next.invoke();
      } else {
        this.isEnabled = false;
      }
    } while (this.isEnabled);
    this.clock = time;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
VirtualTimeSchedulerPrototype.advanceBy = function (time) {
  var dt = this.add(this.clock, time),
      dueToClock = this.comparer(this.clock, dt);
  if (dueToClock &gt; 0) { throw new ArgumentOutOfRangeError(); }
  if (dueToClock === 0) {  return; }

  this.<span class="apidocCodeKeywordSpan">advanceTo</span>(dt);
};

/**
 * Advances the scheduler's clock by the specified relative time.
 * @param {Number} time Relative time to advance the scheduler's clock by.
 */
VirtualTimeSchedulerPrototype.sleep = function (time) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.constructor" id="apidoc.element.rx.VirtualTimeScheduler.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>constructor
        <span class="apidocSignatureSpan">(initialClock, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(initialClock, comparer) {
  this.clock = initialClock;
  this.comparer = comparer;
  this.isEnabled = false;
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.getNext" id="apidoc.element.rx.VirtualTimeScheduler.prototype.getNext">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>getNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNext = function () {
  while (this.queue.length &gt; 0) {
    var next = this.queue.peek();
    if (next.isCancelled()) {
      this.queue.dequeue();
    } else {
      return next;
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Starts the virtual time scheduler.
 */
VirtualTimeSchedulerPrototype.start = function () {
  if (!this.isEnabled) {
    this.isEnabled = true;
    do {
      var next = this.<span class="apidocCodeKeywordSpan">getNext</span>();
      if (next !== null) {
        this.comparer(next.dueTime, this.clock) &gt; 0 &amp;&amp; (this.clock = next.dueTime);
        next.invoke();
      } else {
        this.isEnabled = false;
      }
    } while (this.isEnabled);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.now" id="apidoc.element.rx.VirtualTimeScheduler.prototype.now">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now = function () {
  return this.toAbsoluteTime(this.clock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param state State passed to the action to be executed.
   * @param {Function} action Action to be executed.
   * @param {Number} dueTime Relative time after which to execute the action.
   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
   */
schedulerProto.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime;
  dt instanceof Date &amp;&amp; (dt = dt - this.<span class="apidocCodeKeywordSpan">now</span>());
  dt = Scheduler.normalize(dt);

  if (dt === 0) { return this.schedule(state, action); }

  return this._scheduleFuture(state, dt, action);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.schedule" id="apidoc.element.rx.VirtualTimeScheduler.prototype.schedule">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>schedule
        <span class="apidocSignatureSpan">(state, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!self.isDisposed) {
    self.isDisposed = true;
    self.disposable.dispose();
  }
}

ScheduledDisposable.prototype.dispose = function () {
  this.scheduler.<span class="apidocCodeKeywordSpan">schedule</span>(this, scheduleItem);
};

var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
  this.scheduler = scheduler;
  this.state = state;
  this.action = action;
  this.dueTime = dueTime;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleAbsolute" id="apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleAbsolute">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>scheduleAbsolute
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleAbsolute = function (state, dueTime, action) {
  var self = this;

  function run(scheduler, state1) {
    self.queue.remove(si);
    return action(scheduler, state1);
  }

  var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
  this.queue.enqueue(si);

  return si.disposable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

VirtualTimeSchedulerPrototype.now = function () {
  return this.toAbsoluteTime(this.clock);
};

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.<span class="apidocCodeKeywordSpan">scheduleAbsolute</span>(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.toRelativeTime(dueTime - this.now()) :
    this.toRelativeTime(dueTime);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleFuture" id="apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleFuture">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>scheduleFuture
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.toRelativeTime(dueTime - this.now()) :
    this.toRelativeTime(dueTime);

  return this.scheduleRelative(state, dt, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var state = pair[0], action = pair[1], group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2, dueTime1) {
var isAdded = false, isDone = false;

var d = scheduler.<span class="apidocCodeKeywordSpan">scheduleFuture</span>(state2, dueTime1, scheduleWork);
if (!isDone) {
  group.add(d);
  isAdded = true;
}

function scheduleWork(_, state3) {
  if (isAdded) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.schedulePeriodic" id="apidoc.element.rx.VirtualTimeScheduler.prototype.schedulePeriodic">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>schedulePeriodic
        <span class="apidocSignatureSpan">(state, period, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedulePeriodic = function (state, period, action) {
  var s = new SchedulePeriodicRecursive(this, state, period, action);
  return s.start();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return this._recursiveWrapper;
    };

    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {
var self = this, failed = false, d = new SingleAssignmentDisposable();

d.setDisposable(this._scheduler.<span class="apidocCodeKeywordSpan">schedulePeriodic</span>(state, period, function (state1) {
  if (failed) { return null; }
  var res = tryCatch(action)(state1);
  if (res === errorObj) {
    failed = true;
    if (!self._handler(res.e)) { thrower(res.e); }
    d.dispose();
    return null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleRelative" id="apidoc.element.rx.VirtualTimeScheduler.prototype.scheduleRelative">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>scheduleRelative
        <span class="apidocSignatureSpan">(state, dueTime, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleRelative = function (state, dueTime, action) {
  var runAt = this.add(this.clock, dueTime);
  return this.scheduleAbsolute(state, runAt, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.toRelativeTime(dueTime - this.now()) :
    this.toRelativeTime(dueTime);

  return this.<span class="apidocCodeKeywordSpan">scheduleRelative</span>(state, dt, action);
};

/**
 * Adds a relative time value to an absolute time value.
 * @param {Number} absolute Absolute virtual time value.
 * @param {Number} relative Relative virtual time value to add.
 * @return {Number} Resulting absolute virtual time sum value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.sleep" id="apidoc.element.rx.VirtualTimeScheduler.prototype.sleep">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>sleep
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sleep = function (time) {
  var dt = this.add(this.clock, time);
  if (this.comparer(this.clock, dt) &gt;= 0) { throw new ArgumentOutOfRangeError(); }

  this.clock = dt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.start" id="apidoc.element.rx.VirtualTimeScheduler.prototype.start">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  if (!this.isEnabled) {
    this.isEnabled = true;
    do {
      var next = this.getNext();
      if (next !== null) {
        this.comparer(next.dueTime, this.clock) &gt; 0 &amp;&amp; (this.clock = next.dueTime);
        next.invoke();
      } else {
        this.isEnabled = false;
      }
    } while (this.isEnabled);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Object == val.constructor;
}

/**
 * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence
.
 *
 * @example
 * var res = Rx.Observable.<span class="apidocCodeKeywordSpan">start</span>(function () { console.log('hello'); });
 * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
 * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
 *
 * @param {Function} func Function to run asynchronously.
 * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
 * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
 * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.stop" id="apidoc.element.rx.VirtualTimeScheduler.prototype.stop">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {
  this.isEnabled = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.toAbsoluteTime" id="apidoc.element.rx.VirtualTimeScheduler.prototype.toAbsoluteTime">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>toAbsoluteTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAbsoluteTime = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.queue = new PriorityQueue(1024);
  __super__.call(this);
}

var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

VirtualTimeSchedulerPrototype.now = function () {
  return this.<span class="apidocCodeKeywordSpan">toAbsoluteTime</span>(this.clock);
};

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.VirtualTimeScheduler.prototype.toRelativeTime" id="apidoc.element.rx.VirtualTimeScheduler.prototype.toRelativeTime">
        function <span class="apidocSignatureSpan">rx.VirtualTimeScheduler.prototype.</span>toRelativeTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toRelativeTime = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

VirtualTimeSchedulerPrototype.schedule = function (state, action) {
  return this.scheduleAbsolute(state, this.clock, action);
};

VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
  var dt = dueTime instanceof Date ?
    this.<span class="apidocCodeKeywordSpan">toRelativeTime</span>(dueTime - this.now()) :
    this.toRelativeTime(dueTime);

  return this.scheduleRelative(state, dt, action);
};

/**
 * Adds a relative time value to an absolute time value.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.config" id="apidoc.module.rx.config">module rx.config</a></h1>






    <h2>
        <a href="#apidoc.element.rx.config.Promise" id="apidoc.element.rx.config.Promise">
        function <span class="apidocSignatureSpan">rx.config.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.helpers" id="apidoc.module.rx.helpers">module rx.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.rx.helpers.defaultComparer" id="apidoc.element.rx.helpers.defaultComparer">
        function <span class="apidocSignatureSpan">rx.helpers.</span>defaultComparer
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultComparer = function (x, y) { return isEqual(x, y); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.defaultError" id="apidoc.element.rx.helpers.defaultError">
        function <span class="apidocSignatureSpan">rx.helpers.</span>defaultError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultError = function (err) { throw err; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.defaultKeySerializer" id="apidoc.element.rx.helpers.defaultKeySerializer">
        function <span class="apidocSignatureSpan">rx.helpers.</span>defaultKeySerializer
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultKeySerializer = function (x) { return x.toString(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.defaultNow" id="apidoc.element.rx.helpers.defaultNow">
        function <span class="apidocSignatureSpan">rx.helpers.</span>defaultNow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.defaultSubComparer" id="apidoc.element.rx.helpers.defaultSubComparer">
        function <span class="apidocSignatureSpan">rx.helpers.</span>defaultSubComparer
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultSubComparer = function (x, y) { return x &gt; y ? 1 : (x &lt; y ? -1 : 0); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.identity" id="apidoc.element.rx.helpers.identity">
        function <span class="apidocSignatureSpan">rx.helpers.</span>identity
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (x) { return x; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.isArrayLike" id="apidoc.element.rx.helpers.isArrayLike">
        function <span class="apidocSignatureSpan">rx.helpers.</span>isArrayLike
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArrayLike = function (o) {
  return o &amp;&amp; o.length !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.isFunction" id="apidoc.element.rx.helpers.isFunction">
        function <span class="apidocSignatureSpan">rx.helpers.</span>isFunction
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFunction = function (value) {
  return typeof value == 'function' || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.isIterable" id="apidoc.element.rx.helpers.isIterable">
        function <span class="apidocSignatureSpan">rx.helpers.</span>isIterable
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isIterable = function (o) {
  return o &amp;&amp; o[$iterator$] !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.isPromise" id="apidoc.element.rx.helpers.isPromise">
        function <span class="apidocSignatureSpan">rx.helpers.</span>isPromise
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPromise = function (p) { return !!p &amp;&amp; typeof p.subscribe !== 'function' &amp;&amp; typeof p.then === 'function'; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.noop" id="apidoc.element.rx.helpers.noop">
        function <span class="apidocSignatureSpan">rx.helpers.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noop = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.notImplemented" id="apidoc.element.rx.helpers.notImplemented">
        function <span class="apidocSignatureSpan">rx.helpers.</span>notImplemented
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notImplemented = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.helpers.notSupported" id="apidoc.element.rx.helpers.notSupported">
        function <span class="apidocSignatureSpan">rx.helpers.</span>notSupported
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notSupported = function () {
  throw new NotSupportedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals" id="apidoc.module.rx.internals">module rx.internals</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver" id="apidoc.element.rx.internals.AbstractObserver">
        function <span class="apidocSignatureSpan">rx.internals.</span>AbstractObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractObserver() {
  this.isStopped = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable" id="apidoc.element.rx.internals.Enumerable">
        function <span class="apidocSignatureSpan">rx.internals.</span>Enumerable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Enumerable = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue" id="apidoc.element.rx.internals.PriorityQueue">
        function <span class="apidocSignatureSpan">rx.internals.</span>PriorityQueue
        <span class="apidocSignatureSpan">(capacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PriorityQueue = function (capacity) {
  this.items = new Array(capacity);
  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.SchedulePeriodicRecursive" id="apidoc.element.rx.internals.SchedulePeriodicRecursive">
        function <span class="apidocSignatureSpan">rx.internals.</span>SchedulePeriodicRecursive
        <span class="apidocSignatureSpan">(scheduler, state, period, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SchedulePeriodicRecursive(scheduler, state, period, action) {
  this._scheduler = scheduler;
  this._state = state;
  this._period = period;
  this._action = action;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        export var SchedulePeriodicRecursive: SchedulePeriodicRecursiveStatic;
    }
}

(function() {
    var item = new Rx.internals.<span class="apidocCodeKeywordSpan">SchedulePeriodicRecursive</span>(undefined, undefined, undefined
, undefined);

    var d : Rx.IDisposable = item.start();
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem" id="apidoc.element.rx.internals.ScheduledItem">
        function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledItem
        <span class="apidocSignatureSpan">(scheduler, state, action, dueTime, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
  this.scheduler = scheduler;
  this.state = state;
  this.action = action;
  this.dueTime = dueTime;
  this.comparer = comparer || defaultSubComparer;
  this.disposable = new SingleAssignmentDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    export var ScheduledItem: ScheduledItemStatic
}
}

(function() {
var item = new Rx.internals.<span class="apidocCodeKeywordSpan">ScheduledItem</span>(Rx.Scheduler.default, {}, (sc, s) =&gt; Rx
.Disposable.create(() =&gt; {}), 100);
var item = new Rx.internals.ScheduledItem(Rx.Scheduler.default, {}, (sc, s) =&gt; Rx.Disposable.create(() =&gt; {}), 100, (x
, y) =&gt; 500);

item.scheduler
item.state;
item.action;
item.dueTime;
item.comparer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver" id="apidoc.element.rx.internals.ScheduledObserver">
        function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledObserver
        <span class="apidocSignatureSpan">(scheduler, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScheduledObserver(scheduler, observer) {
  __super__.call(this);
  this.scheduler = scheduler;
  this.observer = observer;
  this.isAcquired = false;
  this.hasFaulted = false;
  this.queue = [];
  this.disposable = new SerialDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.addProperties" id="apidoc.element.rx.internals.addProperties">
        function <span class="apidocSignatureSpan">rx.internals.</span>addProperties
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addProperties = function (obj) {
  for(var sources = [], i = 1, len = arguments.length; i &lt; len; i++) { sources.push(arguments[i]); }
  for (var idx = 0, ln = sources.length; idx &lt; ln; idx++) {
    var source = sources[idx];
    for (var prop in source) {
      obj[prop] = source[prop];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.addRef" id="apidoc.element.rx.internals.addRef">
        function <span class="apidocSignatureSpan">rx.internals.</span>addRef
        <span class="apidocSignatureSpan">(xs, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addRef = function (xs, r) {
  return new AnonymousObservable(function (observer) {
    return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.bindCallback" id="apidoc.element.rx.internals.bindCallback">
        function <span class="apidocSignatureSpan">rx.internals.</span>bindCallback
        <span class="apidocSignatureSpan">(func, thisArg, argCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindCallback = function (func, thisArg, argCount) {
  if (typeof thisArg === 'undefined') { return func; }
  switch(argCount) {
    case 0:
      return function() {
        return func.call(thisArg)
      };
    case 1:
      return function(arg) {
        return func.call(thisArg, arg);
      };
    case 2:
      return function(value, index) {
        return func.call(thisArg, value, index);
      };
    case 3:
      return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
  }

  return function() {
    return func.apply(thisArg, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.inherits" id="apidoc.element.rx.internals.inherits">
        function <span class="apidocSignatureSpan">rx.internals.</span>inherits
        <span class="apidocSignatureSpan">(child, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (child, parent) {
  function __() { this.constructor = child; }
  __.prototype = parent.prototype;
  child.prototype = new __();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.isEqual" id="apidoc.element.rx.internals.isEqual">
        function <span class="apidocSignatureSpan">rx.internals.</span>isEqual
        <span class="apidocSignatureSpan">(value, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEqual = function (value, other) {
  return baseIsEqual(value, other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.isObject" id="apidoc.element.rx.internals.isObject">
        function <span class="apidocSignatureSpan">rx.internals.</span>isObject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObject = function (value) {
  var type = typeof value;
  return !!value &amp;&amp; (type === 'object' || type === 'function');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.tryCatch" id="apidoc.element.rx.internals.tryCatch">
        function <span class="apidocSignatureSpan">rx.internals.</span>tryCatch
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryCatch(fn) {
  if (!isFunction(fn)) { throw new TypeError('fn must be a function'); }
  return tryCatcherGen(fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.AbstractObserver" id="apidoc.module.rx.internals.AbstractObserver">module rx.internals.AbstractObserver</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.AbstractObserver" id="apidoc.element.rx.internals.AbstractObserver.AbstractObserver">
        function <span class="apidocSignatureSpan">rx.internals.</span>AbstractObserver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractObserver() {
  this.isStopped = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.AbstractObserver.prototype" id="apidoc.module.rx.internals.AbstractObserver.prototype">module rx.internals.AbstractObserver.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.completed" id="apidoc.element.rx.internals.AbstractObserver.prototype.completed">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>completed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completed = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Notifies the observer of the end of the sequence.
 */
AbstractObserver.prototype.onCompleted = function () {
  if (!this.isStopped) {
    this.isStopped = true;
    this.<span class="apidocCodeKeywordSpan">completed</span>();
  }
};

/**
 * Disposes the observer, causing it to transition to the stopped state.
 */
AbstractObserver.prototype.dispose = function () { this.isStopped = true; };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.constructor" id="apidoc.element.rx.internals.AbstractObserver.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbstractObserver() {
  this.isStopped = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.dispose" id="apidoc.element.rx.internals.AbstractObserver.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () { this.isStopped = true; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.error" id="apidoc.element.rx.internals.AbstractObserver.prototype.error">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Notifies the observer that an exception has occurred.
 * @param {Any} error The error that has occurred.
 */
AbstractObserver.prototype.onError = function (error) {
  if (!this.isStopped) {
    this.isStopped = true;
    this.<span class="apidocCodeKeywordSpan">error</span>(error);
  }
};

/**
 * Notifies the observer of the end of the sequence.
 */
AbstractObserver.prototype.onCompleted = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.fail" id="apidoc.element.rx.internals.AbstractObserver.prototype.fail">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>fail
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function (e) {
  if (!this.isStopped) {
    this.isStopped = true;
    this.error(e);
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return subscriber &amp;&amp; isFunction(subscriber.dispose) ? subscriber :
    isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
}

function setDisposable(s, state) {
  var ado = state[0], self = state[1];
  var sub = tryCatch(self.subscribeCore).call(self, ado);
  if (sub === errorObj &amp;&amp; !ado.<span class="apidocCodeKeywordSpan">fail</span>(errorObj.e)) { thrower(errorObj.e); }
  ado.setDisposable(fixSubscriber(sub));
}

function ObservableBase() {
  __super__.call(this);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.next" id="apidoc.element.rx.internals.AbstractObserver.prototype.next">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
  throw new NotImplementedError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AbstractObserver.prototype.completed = notImplemented;

/**
 * Notifies the observer of a new element in the sequence.
 * @param {Any} value Next element in the sequence.
 */
AbstractObserver.prototype.onNext = function (value) {
  !this.isStopped &amp;&amp; this.<span class="apidocCodeKeywordSpan">next</span>(value);
};

/**
 * Notifies the observer that an exception has occurred.
 * @param {Any} error The error that has occurred.
 */
AbstractObserver.prototype.onError = function (error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.onCompleted" id="apidoc.element.rx.internals.AbstractObserver.prototype.onCompleted">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>onCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onCompleted = function () {
  if (!this.isStopped) {
    this.isStopped = true;
    this.completed();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        len = keys.length;
    return scheduler.scheduleRecursive(function (self) {
      if (i &lt; len) {
        var key = keys[i++], value = obj[key];
        observer.onNext([key, value]);
        self();
      } else {
        observer.<span class="apidocCodeKeywordSpan">onCompleted</span>();
      }
    });
  });
};
```

Note that all operators must have the documentation and must be split out into its own file.  This allows us to be able to put it
 in different files, or make it available in custom builds.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.onError" id="apidoc.element.rx.internals.AbstractObserver.prototype.onError">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
  if (!this.isStopped) {
    this.isStopped = true;
    this.error(error);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i = 0;
    return source.subscribe(
function (x) {
  var noYield = true;
  try {
    noYield = callback.call(thisArg, x, i++, source);
  } catch (e) {
    observer.<span class="apidocCodeKeywordSpan">onError</span>(e);
    return;
  }

  if (!noYield) { observer.onNext(x); }
},
observer.onError.bind(observer),
observer.onCompleted.bind(observer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.AbstractObserver.prototype.onNext" id="apidoc.element.rx.internals.AbstractObserver.prototype.onNext">
        function <span class="apidocSignatureSpan">rx.internals.AbstractObserver.prototype.</span>onNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onNext = function (value) {
  !this.isStopped &amp;&amp; this.next(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          noYield = callback.call(thisArg, x, i++, source);
        } catch (e) {
          observer.onError(e);
          return;
        }

        if (!noYield) { observer.<span class="apidocCodeKeywordSpan">onNext</span>(x); }
      },
      observer.onError.bind(observer),
      observer.onCompleted.bind(observer)
    );
  });
};
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.Enumerable" id="apidoc.module.rx.internals.Enumerable">module rx.internals.Enumerable</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable.Enumerable" id="apidoc.element.rx.internals.Enumerable.Enumerable">
        function <span class="apidocSignatureSpan">rx.internals.</span>Enumerable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Enumerable = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable.of" id="apidoc.element.rx.internals.Enumerable.of">
        function <span class="apidocSignatureSpan">rx.internals.Enumerable.</span>of
        <span class="apidocSignatureSpan">(source, selector, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function (source, selector, thisArg) {
  return new OfEnumerable(source, selector, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
require({
  'paths': {
    'rx': 'path/to/rx-lite.js'
  }
},
['rx'], (Rx) =&gt; {
  const obs = Rx.Observable.<span class="apidocCodeKeywordSpan">of</span>(42);
  obs.forEach(x =&gt; console.log(x));
});
```

## What about my libraries? ##

The Reactive Extensions for JavaScript have no external dependencies on any library, so they'll work well with just about any
 library.  We provide bridges and support for various libraries including:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable.repeat" id="apidoc.element.rx.internals.Enumerable.repeat">
        function <span class="apidocSignatureSpan">rx.internals.Enumerable.</span>repeat
        <span class="apidocSignatureSpan">(value, repeatCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (value, repeatCount) {
  return new RepeatEnumerable(value, repeatCount);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count
 is not specified, it retries indefinitely.
 *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
 *
 * @example
 *  var res = retried = retry.<span class="apidocCodeKeywordSpan">repeat</span>();
 *  var res = retried = retry.repeat(2);
 * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
 * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully
.
 */
observableProto.retry = function (retryCount) {
  return enumerableRepeat(this, retryCount).catchError();
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.Enumerable.prototype" id="apidoc.module.rx.internals.Enumerable.prototype">module rx.internals.Enumerable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable.prototype.catchError" id="apidoc.element.rx.internals.Enumerable.prototype.catchError">
        function <span class="apidocSignatureSpan">rx.internals.Enumerable.prototype.</span>catchError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchError = function () {
  return new CatchErrorObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (Array.isArray(arguments[0])) {
    items = arguments[0];
  } else {
    var len = arguments.length;
    items = new Array(len);
    for(var i = 0; i &lt; len; i++) { items[i] = arguments[i]; }
  }
  return enumerableOf(items).<span class="apidocCodeKeywordSpan">catchError</span>();
};

/**
 * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable
 sequences or Promises produces an element.
 * This can be in the form of an argument list of observables or an array.
 *
 * @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.Enumerable.prototype.concat" id="apidoc.element.rx.internals.Enumerable.prototype.concat">
        function <span class="apidocSignatureSpan">rx.internals.Enumerable.prototype.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  return new ConcatEnumerableObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  var copiedEvent = {};
  for (var prop in e) {
    copiedEvent[prop] = e[prop];
  }

  for (var i = 0, typeListenersCache = [].<span class="apidocCodeKeywordSpan">concat</span>(typeListeners), typeListenerCache, immediatePropagation
 = true; immediatePropagation &amp;&amp; (typeListenerCache = typeListenersCache[i]); ++i) {
    for (var ii = 0, typeListener; typeListener = typeListeners[ii]; ++ii) {
      if (typeListener === typeListenerCache) { typeListener.call(target, copiedEvent); break; }
    }
  }
});

typeListeners.push(listener);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.PriorityQueue" id="apidoc.module.rx.internals.PriorityQueue">module rx.internals.PriorityQueue</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.PriorityQueue" id="apidoc.element.rx.internals.PriorityQueue.PriorityQueue">
        function <span class="apidocSignatureSpan">rx.internals.</span>PriorityQueue
        <span class="apidocSignatureSpan">(capacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PriorityQueue = function (capacity) {
  this.items = new Array(capacity);
  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.PriorityQueue.prototype" id="apidoc.module.rx.internals.PriorityQueue.prototype">module rx.internals.PriorityQueue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.dequeue" id="apidoc.element.rx.internals.PriorityQueue.prototype.dequeue">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>dequeue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dequeue = function () {
  var result = this.peek();
  this.removeAt(0);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Gets a scheduler that schedules work as soon as possible on the current thread.
   */
  var CurrentThreadScheduler = (function (__super__) {
var queue;

function runTrampoline () {
  while (queue.length &gt; 0) {
    var item = queue.<span class="apidocCodeKeywordSpan">dequeue</span>();
    !item.isCancelled() &amp;&amp; item.invoke();
  }
}

inherits(CurrentThreadScheduler, __super__);
function CurrentThreadScheduler() {
  __super__.call(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.enqueue" id="apidoc.element.rx.internals.PriorityQueue.prototype.enqueue">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueue = function (item) {
  var index = this.length++;
  this.items[index] = new IndexedItem(PriorityQueue.count++, item);
  this.percolate(index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    CurrentThreadScheduler.prototype.schedule = function (state, action) {
var si = new ScheduledItem(this, state, action, this.now());

if (!queue) {
  queue = new PriorityQueue(4);
  queue.<span class="apidocCodeKeywordSpan">enqueue</span>(si);

  var result = tryCatch(runTrampoline)();
  queue = null;
  if (result === errorObj) { thrower(result.e); }
} else {
  queue.enqueue(si);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.heapify" id="apidoc.element.rx.internals.PriorityQueue.prototype.heapify">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>heapify
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function (index) {
  +index || (index = 0);
  if (index &gt;= this.length || index &lt; 0) { return; }
  var left = 2 * index + 1,
      right = 2 * index + 2,
      first = index;
  if (left &lt; this.length &amp;&amp; this.isHigherPriority(left, first)) {
    first = left;
  }
  if (right &lt; this.length &amp;&amp; this.isHigherPriority(right, first)) {
    first = right;
  }
  if (first !== index) {
    var temp = this.items[index];
    this.items[index] = this.items[first];
    this.items[first] = temp;
    this.heapify(first);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (right &lt; this.length &amp;&amp; this.isHigherPriority(right, first)) {
    first = right;
  }
  if (first !== index) {
    var temp = this.items[index];
    this.items[index] = this.items[first];
    this.items[first] = temp;
    this.<span class="apidocCodeKeywordSpan">heapify</span>(first);
  }
};

priorityProto.peek = function () { return this.items[0].value; };

priorityProto.removeAt = function (index) {
  this.items[index] = this.items[--this.length];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.isHigherPriority" id="apidoc.element.rx.internals.PriorityQueue.prototype.isHigherPriority">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>isHigherPriority
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHigherPriority = function (left, right) {
  return this.items[left].compareTo(this.items[right]) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.items[left].compareTo(this.items[right]) &lt; 0;
};

priorityProto.percolate = function (index) {
  if (index &gt;= this.length || index &lt; 0) { return; }
  var parent = index - 1 &gt;&gt; 1;
  if (parent &lt; 0 || parent === index) { return; }
  if (this.<span class="apidocCodeKeywordSpan">isHigherPriority</span>(index, parent)) {
    var temp = this.items[index];
    this.items[index] = this.items[parent];
    this.items[parent] = temp;
    this.percolate(parent);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.peek" id="apidoc.element.rx.internals.PriorityQueue.prototype.peek">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () { return this.items[0].value; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
priorityProto.removeAt = function (index) {
  this.items[index] = this.items[--this.length];
  this.items[this.length] = undefined;
  this.heapify();
};

priorityProto.dequeue = function () {
  var result = this.<span class="apidocCodeKeywordSpan">peek</span>();
  this.removeAt(0);
  return result;
};

priorityProto.enqueue = function (item) {
  var index = this.length++;
  this.items[index] = new IndexedItem(PriorityQueue.count++, item);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.percolate" id="apidoc.element.rx.internals.PriorityQueue.prototype.percolate">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>percolate
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">percolate = function (index) {
  if (index &gt;= this.length || index &lt; 0) { return; }
  var parent = index - 1 &gt;&gt; 1;
  if (parent &lt; 0 || parent === index) { return; }
  if (this.isHigherPriority(index, parent)) {
    var temp = this.items[index];
    this.items[index] = this.items[parent];
    this.items[parent] = temp;
    this.percolate(parent);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (index &gt;= this.length || index &lt; 0) { return; }
  var parent = index - 1 &gt;&gt; 1;
  if (parent &lt; 0 || parent === index) { return; }
  if (this.isHigherPriority(index, parent)) {
    var temp = this.items[index];
    this.items[index] = this.items[parent];
    this.items[parent] = temp;
    this.<span class="apidocCodeKeywordSpan">percolate</span>(parent);
  }
};

priorityProto.heapify = function (index) {
  +index || (index = 0);
  if (index &gt;= this.length || index &lt; 0) { return; }
  var left = 2 * index + 1,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.remove" id="apidoc.element.rx.internals.PriorityQueue.prototype.remove">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>remove
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (item) {
  for (var i = 0; i &lt; this.length; i++) {
    if (this.items[i].value === item) {
      this.removeAt(i);
      return true;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!isDone) {
    group.add(d);
    isAdded = true;
  }

  function scheduleWork(_, state3) {
    if (isAdded) {
      group.<span class="apidocCodeKeywordSpan">remove</span>(d);
    } else {
      isDone = true;
    }
    action(state3, innerAction);
    return disposableEmpty;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.PriorityQueue.prototype.removeAt" id="apidoc.element.rx.internals.PriorityQueue.prototype.removeAt">
        function <span class="apidocSignatureSpan">rx.internals.PriorityQueue.prototype.</span>removeAt
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAt = function (index) {
  this.items[index] = this.items[--this.length];
  this.items[this.length] = undefined;
  this.heapify();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.items[index] = this.items[--this.length];
  this.items[this.length] = undefined;
  this.heapify();
};

priorityProto.dequeue = function () {
  var result = this.peek();
  this.<span class="apidocCodeKeywordSpan">removeAt</span>(0);
  return result;
};

priorityProto.enqueue = function (item) {
  var index = this.length++;
  this.items[index] = new IndexedItem(PriorityQueue.count++, item);
  this.percolate(index);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.SchedulePeriodicRecursive" id="apidoc.module.rx.internals.SchedulePeriodicRecursive">module rx.internals.SchedulePeriodicRecursive</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.SchedulePeriodicRecursive.SchedulePeriodicRecursive" id="apidoc.element.rx.internals.SchedulePeriodicRecursive.SchedulePeriodicRecursive">
        function <span class="apidocSignatureSpan">rx.internals.</span>SchedulePeriodicRecursive
        <span class="apidocSignatureSpan">(scheduler, state, period, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SchedulePeriodicRecursive(scheduler, state, period, action) {
  this._scheduler = scheduler;
  this._state = state;
  this._period = period;
  this._action = action;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        export var SchedulePeriodicRecursive: SchedulePeriodicRecursiveStatic;
    }
}

(function() {
    var item = new Rx.internals.<span class="apidocCodeKeywordSpan">SchedulePeriodicRecursive</span>(undefined, undefined, undefined
, undefined);

    var d : Rx.IDisposable = item.start();
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.SchedulePeriodicRecursive.prototype" id="apidoc.module.rx.internals.SchedulePeriodicRecursive.prototype">module rx.internals.SchedulePeriodicRecursive.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.SchedulePeriodicRecursive.prototype.start" id="apidoc.element.rx.internals.SchedulePeriodicRecursive.prototype.start">
        function <span class="apidocSignatureSpan">rx.internals.SchedulePeriodicRecursive.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  var d = new SingleAssignmentDisposable();
  this._cancel = d;
  d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));

  return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Object == val.constructor;
}

/**
 * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence
.
 *
 * @example
 * var res = Rx.Observable.<span class="apidocCodeKeywordSpan">start</span>(function () { console.log('hello'); });
 * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
 * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
 *
 * @param {Function} func Function to run asynchronously.
 * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
 * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
 * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.ScheduledItem" id="apidoc.module.rx.internals.ScheduledItem">module rx.internals.ScheduledItem</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem.ScheduledItem" id="apidoc.element.rx.internals.ScheduledItem.ScheduledItem">
        function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledItem
        <span class="apidocSignatureSpan">(scheduler, state, action, dueTime, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
  this.scheduler = scheduler;
  this.state = state;
  this.action = action;
  this.dueTime = dueTime;
  this.comparer = comparer || defaultSubComparer;
  this.disposable = new SingleAssignmentDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    export var ScheduledItem: ScheduledItemStatic
}
}

(function() {
var item = new Rx.internals.<span class="apidocCodeKeywordSpan">ScheduledItem</span>(Rx.Scheduler.default, {}, (sc, s) =&gt; Rx
.Disposable.create(() =&gt; {}), 100);
var item = new Rx.internals.ScheduledItem(Rx.Scheduler.default, {}, (sc, s) =&gt; Rx.Disposable.create(() =&gt; {}), 100, (x
, y) =&gt; 500);

item.scheduler
item.state;
item.action;
item.dueTime;
item.comparer;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.ScheduledItem.prototype" id="apidoc.module.rx.internals.ScheduledItem.prototype">module rx.internals.ScheduledItem.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem.prototype.compareTo" id="apidoc.element.rx.internals.ScheduledItem.prototype.compareTo">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>compareTo
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compareTo = function (other) {
  return this.comparer(this.dueTime, other.dueTime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function IndexedItem(id, value) {
  this.id = id;
  this.value = value;
}

IndexedItem.prototype.compareTo = function (other) {
  var c = this.value.<span class="apidocCodeKeywordSpan">compareTo</span>(other.value);
  c === 0 &amp;&amp; (c = this.id - other.id);
  return c;
};

var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {
  this.items = new Array(capacity);
  this.length = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem.prototype.invoke" id="apidoc.element.rx.internals.ScheduledItem.prototype.invoke">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>invoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invoke = function () {
  this.disposable.setDisposable(this.invokeCore());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  var CurrentThreadScheduler = (function (__super__) {
var queue;

function runTrampoline () {
  while (queue.length &gt; 0) {
    var item = queue.dequeue();
    !item.isCancelled() &amp;&amp; item.<span class="apidocCodeKeywordSpan">invoke</span>();
  }
}

inherits(CurrentThreadScheduler, __super__);
function CurrentThreadScheduler() {
  __super__.call(this);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem.prototype.invokeCore" id="apidoc.element.rx.internals.ScheduledItem.prototype.invokeCore">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>invokeCore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invokeCore = function () {
  return disposableFixup(this.action(this.scheduler, this.state));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.action = action;
  this.dueTime = dueTime;
  this.comparer = comparer || defaultSubComparer;
  this.disposable = new SingleAssignmentDisposable();
};

ScheduledItem.prototype.invoke = function () {
  this.disposable.setDisposable(this.<span class="apidocCodeKeywordSpan">invokeCore</span>());
};

ScheduledItem.prototype.compareTo = function (other) {
  return this.comparer(this.dueTime, other.dueTime);
};

ScheduledItem.prototype.isCancelled = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledItem.prototype.isCancelled" id="apidoc.element.rx.internals.ScheduledItem.prototype.isCancelled">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledItem.prototype.</span>isCancelled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCancelled = function () {
  return this.disposable.isDisposed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  var CurrentThreadScheduler = (function (__super__) {
var queue;

function runTrampoline () {
  while (queue.length &gt; 0) {
    var item = queue.dequeue();
    !item.<span class="apidocCodeKeywordSpan">isCancelled</span>() &amp;&amp; item.invoke();
  }
}

inherits(CurrentThreadScheduler, __super__);
function CurrentThreadScheduler() {
  __super__.call(this);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.ScheduledObserver" id="apidoc.module.rx.internals.ScheduledObserver">module rx.internals.ScheduledObserver</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.ScheduledObserver" id="apidoc.element.rx.internals.ScheduledObserver.ScheduledObserver">
        function <span class="apidocSignatureSpan">rx.internals.</span>ScheduledObserver
        <span class="apidocSignatureSpan">(scheduler, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScheduledObserver(scheduler, observer) {
  __super__.call(this);
  this.scheduler = scheduler;
  this.observer = observer;
  this.isAcquired = false;
  this.hasFaulted = false;
  this.queue = [];
  this.disposable = new SerialDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rx.internals.ScheduledObserver.prototype" id="apidoc.module.rx.internals.ScheduledObserver.prototype">module rx.internals.ScheduledObserver.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.prototype.completed" id="apidoc.element.rx.internals.ScheduledObserver.prototype.completed">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>completed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completed = function () {
  this.queue.push(enqueueCompleted(this.observer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Notifies the observer of the end of the sequence.
 */
AbstractObserver.prototype.onCompleted = function () {
  if (!this.isStopped) {
    this.isStopped = true;
    this.<span class="apidocCodeKeywordSpan">completed</span>();
  }
};

/**
 * Disposes the observer, causing it to transition to the stopped state.
 */
AbstractObserver.prototype.dispose = function () { this.isStopped = true; };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.prototype.constructor" id="apidoc.element.rx.internals.ScheduledObserver.prototype.constructor">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>constructor
        <span class="apidocSignatureSpan">(scheduler, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScheduledObserver(scheduler, observer) {
  __super__.call(this);
  this.scheduler = scheduler;
  this.observer = observer;
  this.isAcquired = false;
  this.hasFaulted = false;
  this.queue = [];
  this.disposable = new SerialDisposable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Rx.Observable.just(o);
}
    }).toArray();
  }

  function objectToObservable (obj) {
    var results = new obj.<span class="apidocCodeKeywordSpan">constructor</span>(), keys = Object.keys(obj), observables = [];
    for (var i = 0, len = keys.length; i &lt; len; i++) {
var key = keys[i];
var observable = toObservable.call(this, obj[key]);

if(observable &amp;&amp; Observable.isObservable(observable)) {
  defer(observable, key);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.prototype.dispose" id="apidoc.element.rx.internals.ScheduledObserver.prototype.dispose">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  __super__.prototype.dispose.call(this);
  this.disposable.dispose();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .map(quote =&gt; quote.price)
  .subscribe(
    price =&gt; console.log(`Prices higher than $30: ${price}`),
    err =&gt; console.log(`Something went wrong: ${err.message}`);
  );

/* When we're done */
subscription.<span class="apidocCodeKeywordSpan">dispose</span>();
```

The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in
receiving the data as it comes streaming in, we call `dispose` on our subscription.  Note the use of `subscribe` instead of `forEach
`.  We could also use `forEach` which is an alias for `subscribe` but we highly suggest you use `subscribe`.

## Batteries Included ##

Sure, there are a lot of libraries to get started with RxJS. Confused on where to get started?  Start out with the complete set
of operators with [`rx.all.js`](doc/libraries/main/rx.complete.md), then you can reduce it to the number of operators that you really
 need, and perhaps stick with something as small as [`rx.lite.js`](doc/libraries/lite/rx.lite.md).  If you're an implementor
 of RxJS, then you can start out with [`rx.core.js`](doc/libraries/core/rx.core.md).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.prototype.ensureActive" id="apidoc.element.rx.internals.ScheduledObserver.prototype.ensureActive">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>ensureActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureActive = function () {
  var isOwner = false;
  if (!this.hasFaulted &amp;&amp; this.queue.length &gt; 0) {
    isOwner = !this.isAcquired;
    this.isAcquired = true;
  }
  isOwner &amp;&amp;
    this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ObserveOnObserver(scheduler, observer, cancel) {
  __super__.call(this, scheduler, observer);
  this._cancel = cancel;
}

ObserveOnObserver.prototype.next = function (value) {
  __super__.prototype.next.call(this, value);
  this.<span class="apidocCodeKeywordSpan">ensureActive</span>();
};

ObserveOnObserver.prototype.error = function (e) {
  __super__.prototype.error.call(this, e);
  this.ensureActive();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.prototype.error" id="apidoc.element.rx.internals.ScheduledObserver.prototype.error">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>error
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (e) {
  this.queue.push(enqueueError(this.observer, e));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Notifies the observer that an exception has occurred.
 * @param {Any} error The error that has occurred.
 */
AbstractObserver.prototype.onError = function (error) {
  if (!this.isStopped) {
    this.isStopped = true;
    this.<span class="apidocCodeKeywordSpan">error</span>(error);
  }
};

/**
 * Notifies the observer of the end of the sequence.
 */
AbstractObserver.prototype.onCompleted = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rx.internals.ScheduledObserver.prototype.next" id="apidoc.element.rx.internals.ScheduledObserver.prototype.next">
        function <span class="apidocSignatureSpan">rx.internals.ScheduledObserver.prototype.</span>next
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (x) {
  this.queue.push(enqueueNext(this.observer, x));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AbstractObserver.prototype.completed = notImplemented;

/**
 * Notifies the observer of a new element in the sequence.
 * @param {Any} value Next element in the sequence.
 */
AbstractObserver.prototype.onNext = function (value) {
  !this.isStopped &amp;&amp; this.<span class="apidocCodeKeywordSpan">next</span>(value);
};

/**
 * Notifies the observer that an exception has occurred.
 * @param {Any} error The error that has occurred.
 */
AbstractObserver.prototype.onError = function (error) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>